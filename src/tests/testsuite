#! /bin/sh
# Generated from local.at by GNU Autoconf 2.69.
#
# Copyright (C) 2009-2012 Free Software Foundation, Inc.
#
# This test suite is free software; the Free Software Foundation gives
# unlimited permission to copy, distribute and modify it.
## -------------------- ##
## M4sh Initialization. ##
## -------------------- ##

# Be more Bourne compatible
DUALCASE=1; export DUALCASE # for MKS sh
if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '${1+"$@"}'='"$@"'
  setopt NO_GLOB_SUBST
else
  case `(set -o) 2>/dev/null` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi


as_nl='
'
export as_nl
# Printing a long string crashes Solaris 7 /usr/bin/printf.
as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
# Prefer a ksh shell builtin over an external printf program on Solaris,
# but without wasting forks for bash or zsh.
if test -z "$BASH_VERSION$ZSH_VERSION" \
    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='print -r --'
  as_echo_n='print -rn --'
elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
  as_echo='printf %s\n'
  as_echo_n='printf %s'
else
  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
    as_echo_n='/usr/ucb/echo -n'
  else
    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
    as_echo_n_body='eval
      arg=$1;
      case $arg in #(
      *"$as_nl"*)
	expr "X$arg" : "X\\(.*\\)$as_nl";
	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
      esac;
      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
    '
    export as_echo_n_body
    as_echo_n='sh -c $as_echo_n_body as_echo'
  fi
  export as_echo_body
  as_echo='sh -c $as_echo_body as_echo'
fi

# The user is always right.
if test "${PATH_SEPARATOR+set}" != set; then
  PATH_SEPARATOR=:
  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
      PATH_SEPARATOR=';'
  }
fi


# IFS
# We need space, tab and new line, in precisely that order.  Quoting is
# there to prevent editors from complaining about space-tab.
# (If _AS_PATH_WALK were called with IFS unset, it would disable word
# splitting by setting IFS to empty value.)
IFS=" ""	$as_nl"

# Find who we are.  Look in the path if we contain no directory separator.
as_myself=
case $0 in #((
  *[\\/]* ) as_myself=$0 ;;
  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
  done
IFS=$as_save_IFS

     ;;
esac
# We did not find ourselves, most probably we were run as `sh COMMAND'
# in which case we are not to be found in the path.
if test "x$as_myself" = x; then
  as_myself=$0
fi
if test ! -f "$as_myself"; then
  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
  exit 1
fi

# Unset variables that we do not need and which cause bugs (e.g. in
# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
# suppresses any "Segmentation fault" message there.  '((' could
# trigger a bug in pdksh 5.2.14.
for as_var in BASH_ENV ENV MAIL MAILPATH
do eval test x\${$as_var+set} = xset \
  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
done
PS1='$ '
PS2='> '
PS4='+ '

# NLS nuisances.
LC_ALL=C
export LC_ALL
LANGUAGE=C
export LANGUAGE

# CDPATH.
(unset CDPATH) >/dev/null 2>&1 && unset CDPATH

if test "x$CONFIG_SHELL" = x; then
  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
  emulate sh
  NULLCMD=:
  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
  # is contrary to our usage.  Disable this feature.
  alias -g '\${1+\"\$@\"}'='\"\$@\"'
  setopt NO_GLOB_SUBST
else
  case \`(set -o) 2>/dev/null\` in #(
  *posix*) :
    set -o posix ;; #(
  *) :
     ;;
esac
fi
"
  as_required="as_fn_return () { (exit \$1); }
as_fn_success () { as_fn_return 0; }
as_fn_failure () { as_fn_return 1; }
as_fn_ret_success () { return 0; }
as_fn_ret_failure () { return 1; }

exitcode=0
as_fn_success || { exitcode=1; echo as_fn_success failed.; }
as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :

else
  exitcode=1; echo positional parameters were not saved.
fi
test x\$exitcode = x0 || exit 1
test -x / || exit 1"
  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
test \$(( 1 + 1 )) = 2 || exit 1"
  if (eval "$as_required") 2>/dev/null; then :
  as_have_required=yes
else
  as_have_required=no
fi
  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :

else
  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
as_found=false
for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
  as_found=:
  case $as_dir in #(
	 /*)
	   for as_base in sh bash ksh sh5; do
	     # Try only shells that exist, to save several forks.
	     as_shell=$as_dir/$as_base
	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
  CONFIG_SHELL=$as_shell as_have_required=yes
		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
  break 2
fi
fi
	   done;;
       esac
  as_found=false
done
$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
  CONFIG_SHELL=$SHELL as_have_required=yes
fi; }
IFS=$as_save_IFS


      if test "x$CONFIG_SHELL" != x; then :
  export CONFIG_SHELL
             # We cannot yet assume a decent shell, so we have to provide a
# neutralization value for shells without unset; and this also
# works around shells that cannot unset nonexistent variables.
# Preserve -v and -x to the replacement shell.
BASH_ENV=/dev/null
ENV=/dev/null
(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
case $- in # ((((
  *v*x* | *x*v* ) as_opts=-vx ;;
  *v* ) as_opts=-v ;;
  *x* ) as_opts=-x ;;
  * ) as_opts= ;;
esac
exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
# Admittedly, this is quite paranoid, since all the known shells bail
# out after a failed `exec'.
$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
exit 255
fi

    if test x$as_have_required = xno; then :
  $as_echo "$0: This script requires a shell more modern than all"
  $as_echo "$0: the shells that I found on your system."
  if test x${ZSH_VERSION+set} = xset ; then
    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
  else
    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
$0: including any error possibly output before this
$0: message. Then install a modern shell, or manually run
$0: the script under such a shell if you do have one."
  fi
  exit 1
fi
fi
fi
SHELL=${CONFIG_SHELL-/bin/sh}
export SHELL
# Unset more variables known to interfere with behavior of common tools.
CLICOLOR_FORCE= GREP_OPTIONS=
unset CLICOLOR_FORCE GREP_OPTIONS

## --------------------- ##
## M4sh Shell Functions. ##
## --------------------- ##
# as_fn_unset VAR
# ---------------
# Portably unset VAR.
as_fn_unset ()
{
  { eval $1=; unset $1;}
}
as_unset=as_fn_unset

# as_fn_set_status STATUS
# -----------------------
# Set $? to STATUS, without forking.
as_fn_set_status ()
{
  return $1
} # as_fn_set_status

# as_fn_exit STATUS
# -----------------
# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
as_fn_exit ()
{
  set +e
  as_fn_set_status $1
  exit $1
} # as_fn_exit

# as_fn_mkdir_p
# -------------
# Create "$as_dir" as a directory, including parents if necessary.
as_fn_mkdir_p ()
{

  case $as_dir in #(
  -*) as_dir=./$as_dir;;
  esac
  test -d "$as_dir" || eval $as_mkdir_p || {
    as_dirs=
    while :; do
      case $as_dir in #(
      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
      *) as_qdir=$as_dir;;
      esac
      as_dirs="'$as_qdir' $as_dirs"
      as_dir=`$as_dirname -- "$as_dir" ||
$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
	 X"$as_dir" : 'X\(//\)[^/]' \| \
	 X"$as_dir" : 'X\(//\)$' \| \
	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X"$as_dir" |
    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)[^/].*/{
	    s//\1/
	    q
	  }
	  /^X\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`
      test -d "$as_dir" && break
    done
    test -z "$as_dirs" || eval "mkdir $as_dirs"
  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"


} # as_fn_mkdir_p

# as_fn_executable_p FILE
# -----------------------
# Test if FILE is an executable regular file.
as_fn_executable_p ()
{
  test -f "$1" && test -x "$1"
} # as_fn_executable_p
# as_fn_append VAR VALUE
# ----------------------
# Append the text in VALUE to the end of the definition contained in VAR. Take
# advantage of any shell optimizations that allow amortized linear growth over
# repeated appends, instead of the typical quadratic growth present in naive
# implementations.
if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
  eval 'as_fn_append ()
  {
    eval $1+=\$2
  }'
else
  as_fn_append ()
  {
    eval $1=\$$1\$2
  }
fi # as_fn_append

# as_fn_arith ARG...
# ------------------
# Perform arithmetic evaluation on the ARGs, and store the result in the
# global $as_val. Take advantage of shells that can avoid forks. The arguments
# must be portable across $(()) and expr.
if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
  eval 'as_fn_arith ()
  {
    as_val=$(( $* ))
  }'
else
  as_fn_arith ()
  {
    as_val=`expr "$@" || test $? -eq 1`
  }
fi # as_fn_arith


# as_fn_error STATUS ERROR [LINENO LOG_FD]
# ----------------------------------------
# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
# script with STATUS, using 1 if that was 0.
as_fn_error ()
{
  as_status=$1; test $as_status -eq 0 && as_status=1
  if test "$4"; then
    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
  fi
  $as_echo "$as_me: error: $2" >&2
  as_fn_exit $as_status
} # as_fn_error

if expr a : '\(a\)' >/dev/null 2>&1 &&
   test "X`expr 00001 : '.*\(...\)'`" = X001; then
  as_expr=expr
else
  as_expr=false
fi

if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
  as_basename=basename
else
  as_basename=false
fi

as_me=`$as_basename -- "$0" ||
$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
	 X"$0" : 'X\(//\)$' \| \
	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
$as_echo X/"$0" |
    sed '/^.*\/\([^/][^/]*\)\/*$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\/\)$/{
	    s//\1/
	    q
	  }
	  /^X\/\(\/\).*/{
	    s//\1/
	    q
	  }
	  s/.*/./; q'`

if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
  as_dirname=dirname
else
  as_dirname=false
fi

# Avoid depending upon Character Ranges.
as_cr_letters='abcdefghijklmnopqrstuvwxyz'
as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
as_cr_Letters=$as_cr_letters$as_cr_LETTERS
as_cr_digits='0123456789'
as_cr_alnum=$as_cr_Letters$as_cr_digits


  as_lineno_1=$LINENO as_lineno_1a=$LINENO
  as_lineno_2=$LINENO as_lineno_2a=$LINENO
  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
  sed -n '
    p
    /[$]LINENO/=
  ' <$as_myself |
    sed '
      s/[$]LINENO.*/&-/
      t lineno
      b
      :lineno
      N
      :loop
      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
      t loop
      s/-\n.*//
    ' >$as_me.lineno &&
  chmod +x "$as_me.lineno" ||
    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }

  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
  # already done that, so ensure we don't try to do so again and fall
  # in an infinite loop.  This has already happened in practice.
  _as_can_reexec=no; export _as_can_reexec
  # Don't try to exec as it changes $[0], causing all sort of problems
  # (the dirname of $[0] is not the place where we might find the
  # original and so on.  Autoconf is especially sensitive to this).
  . "./$as_me.lineno"
  # Exit status is that of the last command.
  exit
}

ECHO_C= ECHO_N= ECHO_T=
case `echo -n x` in #(((((
-n*)
  case `echo 'xy\c'` in
  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
  xy)  ECHO_C='\c';;
  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
       ECHO_T='	';;
  esac;;
*)
  ECHO_N='-n';;
esac

rm -f conf$$ conf$$.exe conf$$.file
if test -d conf$$.dir; then
  rm -f conf$$.dir/conf$$.file
else
  rm -f conf$$.dir
  mkdir conf$$.dir 2>/dev/null
fi
if (echo >conf$$.file) 2>/dev/null; then
  if ln -s conf$$.file conf$$ 2>/dev/null; then
    as_ln_s='ln -s'
    # ... but there are two gotchas:
    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
    # In both cases, we have to default to `cp -pR'.
    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
      as_ln_s='cp -pR'
  elif ln conf$$.file conf$$ 2>/dev/null; then
    as_ln_s=ln
  else
    as_ln_s='cp -pR'
  fi
else
  as_ln_s='cp -pR'
fi
rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
rmdir conf$$.dir 2>/dev/null

if mkdir -p . 2>/dev/null; then
  as_mkdir_p='mkdir -p "$as_dir"'
else
  test -d ./-p && rmdir ./-p
  as_mkdir_p=false
fi

as_test_x='test -x'
as_executable_p=as_fn_executable_p

# Sed expression to map a string onto a valid CPP name.
as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"

# Sed expression to map a string onto a valid variable name.
as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"





SHELL=${CONFIG_SHELL-/bin/sh}

# How were we run?
at_cli_args="$@"


# Not all shells have the 'times' builtin; the subshell is needed to make
# sure we discard the 'times: not found' message from the shell.
at_times_p=false
(times) >/dev/null 2>&1 && at_times_p=:

# CLI Arguments to pass to the debugging scripts.
at_debug_args=
# -e sets to true
at_errexit_p=false
# Shall we be verbose?  ':' means no, empty means yes.
at_verbose=:
at_quiet=
# Running several jobs in parallel, 0 means as many as test groups.
at_jobs=1
at_traceon=:
at_trace_echo=:
at_check_filter_trace=:

# Shall we keep the debug scripts?  Must be `:' when the suite is
# run by a debug script, so that the script doesn't remove itself.
at_debug_p=false
# Display help message?
at_help_p=false
# Display the version message?
at_version_p=false
# List test groups?
at_list_p=false
# --clean
at_clean=false
# Test groups to run
at_groups=
# Whether to rerun failed tests.
at_recheck=
# Whether a write failure occurred
at_write_fail=0

# The directory we run the suite in.  Default to . if no -C option.
at_dir=`pwd`
# An absolute reference to this testsuite script.
case $as_myself in
  [\\/]* | ?:[\\/]* ) at_myself=$as_myself ;;
  * ) at_myself=$at_dir/$as_myself ;;
esac
# Whether -C is in effect.
at_change_dir=false

# Whether to enable colored test results.
at_color=no
# List of the tested programs.
at_tested=''
# As many question marks as there are digits in the last test group number.
# Used to normalize the test group numbers so that `ls' lists them in
# numerical order.
at_format='???'
# Description of all the test groups.
at_help_all="1;utils.at:9;sr_strcmp0;;
2;utils.at:29;sr_strchr_location;;
3;utils.at:65;sr_strstr_location;;
4;utils.at:105;sr_strspn_location;;
5;utils.at:138;sr_skip_char;;
6;utils.at:155;sr_skip_char_limited;;
7;utils.at:173;sr_parse_char_limited;;
8;utils.at:210;sr_skip_char_sequence;;
9;utils.at:228;sr_skip_char_span;;
10;utils.at:250;sr_skip_char_span_location;;
11;utils.at:284;sr_parse_char_span;;
12;utils.at:308;sr_parse_char_cspan;;
13;utils.at:332;sr_skip_string;;
14;utils.at:352;sr_parse_string;;
15;utils.at:372;sr_skip_uint;;
16;utils.at:389;sr_parse_uint32;;
17;utils.at:409;sr_skip_hexadecimal_0xuint;;
18;utils.at:426;sr_parse_hexadecimal_0xuint64;;
19;utils.at:450;sr_indent;;
20;utils.at:468;sr_struniq;;
21;utils.at:509;sr_sha1_hash;;
22;utils.at:559;sr_demangle_symbol;;
23;strbuf.at:8;sr_strbuf_append_char;;
24;strbuf.at:37;sr_strbuf_append_str;;
25;gdb_frame.at:8;sr_gdb_frame_dup;;
26;gdb_frame.at:63;sr_gdb_frame_parse_frame_start;;
27;gdb_frame.at:112;sr_gdb_frame_parseadd_operator;;
28;gdb_frame.at:157;sr_gdb_frame_parse_function_name;;
29;gdb_frame.at:221;sr_gdb_frame_skip_function_args;;
30;gdb_frame.at:268;sr_gdb_frame_parse_function_call;;
31;gdb_frame.at:375;sr_gdb_frame_parse_address_in_function;;
32;gdb_frame.at:434;sr_gdb_frame_parse_file_location;;
33;gdb_frame.at:498;sr_gdb_frame_parse_header;;
34;gdb_frame.at:591;sr_gdb_frame_parse;;
35;gdb_thread.at:8;sr_gdb_thread_remove_frame;;
36;gdb_thread.at:73;sr_gdb_thread_remove_frames_above;;
37;gdb_thread.at:139;sr_gdb_thread_remove_frames_below_n;;
38;gdb_thread.at:206;sr_gdb_thread_parse;;
39;gdb_thread.at:305;sr_gdb_thread_parse-locations;;
40;gdb_thread.at:375;sr_gdb_thread_skip_lwp;;
41;gdb_stacktrace.at:8;sr_gdb_stacktrace_remove_threads_except_one;;
42;gdb_stacktrace.at:62;sr_gdb_stacktrace_find_crash_thread;;
43;gdb_stacktrace.at:113;sr_gdb_stacktrace_limit_frame_depth;;
44;gdb_stacktrace.at:153;sr_gdb_stacktrace_quality_complex;;
45;gdb_stacktrace.at:182;sr_gdb_stacktrace_get_crash_frame;;
46;gdb_stacktrace.at:216;sr_gdb_stacktrace_parse_no_thread_header;;
47;gdb_sharedlib.at:8;sr_gdb_sharedlib_parse;;
48;gdb_sharedlib.at:35;sr_gdb_sharedlib_count;;
49;gdb_sharedlib.at:59;sr_gdb_sharedlib_append;;
50;gdb_sharedlib.at:85;sr_gdb_sharedlib_find_address;;
51;java_frame.at:8;sr_java_frame_cmp;;
52;java_frame.at:87;sr_java_frame_dup;;
53;java_frame.at:186;sr_java_frame_append_to_str;;
54;java_frame.at:275;sr_java_frame_parse;;
55;java_frame.at:497;sr_java_frame_parse_exception;;
56;java_thread.at:8;sr_java_thread_cmp;;
57;java_thread.at:53;sr_java_thread_dup;;
58;java_thread.at:82;sr_java_thread_remove_frame;;
59;java_thread.at:127;sr_java_thread_remove_frames_above;;
60;java_thread.at:173;sr_java_thread_remove_frames_below_n;;
61;java_thread.at:221;sr_java_thread_parse;;
62;java_stacktrace.at:8;sr_java_stacktrace_cmp;;
63;java_stacktrace.at:45;sr_java_stacktrace_dup;;
64;java_stacktrace.at:77;sr_java_stacktrace_parse;;
65;java_stacktrace.at:144;sr_java_stacktrace_reason;;
66;koops_frame.at:9;sr_koops_skip_timestamp;;
67;koops_frame.at:45;sr_koops_parse_address;;
68;koops_frame.at:82;sr_koops_parse_module_name;;
69;koops_frame.at:124;sr_koops_parse_function;;
70;koops_frame.at:178;sr_koops_frame_parse;;
71;koops_frame.at:250;sr_koops_frame_to_json;;
72;koops_stacktrace.at:8;sr_koops_stacktrace_parse_modules;;
73;koops_stacktrace.at:89;sr_koops_stacktrace_parse;;
74;koops_stacktrace.at:256;sr_koops_stacktrace_to_json;;
75;core_frame.at:9;sr_core_frame_dup;;
76;core_frame.at:65;sr_core_frame_to_json;;
77;core_frame.at:101;sr_core_frame_abstract_functions;;
78;core_thread.at:9;sr_core_thread_to_json;;
79;core_thread.at:67;sr_core_thread_abstract_functions;;
80;core_stacktrace.at:9;sr_core_stacktrace_to_json;;
81;core_stacktrace.at:124;sr_core_stacktrace_from_json;;
82;operating_system.at:8;sr_operating_system_parse_etc_system_release;;
83;operating_system.at:45;sr_operating_system_parse_etc_os_release;;
84;normalize.at:47;sr_normalize_gdb_thread_removes_zeroes;;
85;normalize.at:92;sr_normalize_gdb_paired_unknown_function_names;;
86;normalize.at:166;sr_normalize_gdb_thread_jvm_frames;;
87;metrics.at:48;metrics_all_one_thread_empty;;
88;metrics.at:65;metrics_all_both_threads_empty;;
89;metrics.at:82;metrics_all_both_starting_??_levendistance3_a;;
90;metrics.at:99;metrics_all_both_starting_??_levendistance3_b;;
91;metrics.at:116;metrics_levenshtein_random_??_levendistance0_a;;
92;metrics.at:131;metrics_levenshtein_random_??_levendistance0_b;;
93;metrics.at:146;metrics_levenshtein_random_??_distance1;;
94;metrics.at:161;metrics_levenshtein_random_??_distance2_a;;
95;metrics.at:176;metrics_levenshtein_random_??_distance2_b;;
96;metrics.at:191;metrics_levenshtein_random_??_distance2_c;;
97;metrics.at:206;metrics_levenshtein_trans_??_distance2_a;;
98;metrics.at:224;metrics_levenshtein_trans_??_distance2_b;;
99;metrics.at:242;metrics_levenshtein_swap_trans_distance2_a;;
100;metrics.at:257;metrics_levenshtein_swap_notrans_distance3_a;;
101;metrics.at:272;metrics_jaccard_random_??_distance0_a;;
102;metrics.at:290;metrics_jaccard_random_??_distance23_a;;
103;metrics.at:306;metrics_jaccard_random_??_distance35;;
104;metrics.at:322;distances_basic_properties;;
105;metrics.at:353;distances_threads_compare;;
106;cluster.at:3;sr_distances_cluster_objects;;
107;cluster.at:72;sr_dendrogram_cut;;
108;rpm.at:8;sr_rpm_package_parse_nvr;;
109;rpm.at:33;sr_rpm_package_parse_nevra;;
110;rpm.at:86;sr_rpm_package_uniq;;
111;rpm.at:190;sr_rpm_package_uniq3;;
112;abrt.at:8;sr_abrt_parse_dso_list;;
113;report.at:9;sr_report_type_to_string;;
114;report.at:37;sr_report_type_from_string;;
115;python_bindings.at:9;python_bindings_for_misc;;
116;python_bindings.at:10;python_bindings_for_gdb;;
117;python_bindings.at:11;python_bindings_for_koops;;
118;python_bindings.at:12;python_bindings_for_python;;
119;python_bindings.at:13;python_bindings_for_java;;
120;python_bindings.at:14;python_bindings_for_core;;
121;python_bindings.at:15;python_bindings_for_metrics;;
122;python_bindings.at:16;python_bindings_for_report;;
"
# List of the all the test groups.
at_groups_all=`$as_echo "$at_help_all" | sed 's/;.*//'`

# at_fn_validate_ranges NAME...
# -----------------------------
# Validate and normalize the test group number contained in each variable
# NAME. Leading zeroes are treated as decimal.
at_fn_validate_ranges ()
{
  for at_grp
  do
    eval at_value=\$$at_grp
    if test $at_value -lt 1 || test $at_value -gt 122; then
      $as_echo "invalid test group: $at_value" >&2
      exit 1
    fi
    case $at_value in
      0*) # We want to treat leading 0 as decimal, like expr and test, but
	  # AS_VAR_ARITH treats it as octal if it uses $(( )).
	  # With XSI shells, ${at_value#${at_value%%[1-9]*}} avoids the
	  # expr fork, but it is not worth the effort to determine if the
	  # shell supports XSI when the user can just avoid leading 0.
	  eval $at_grp='`expr $at_value + 0`' ;;
    esac
  done
}

at_prev=
for at_option
do
  # If the previous option needs an argument, assign it.
  if test -n "$at_prev"; then
    at_option=$at_prev=$at_option
    at_prev=
  fi

  case $at_option in
  *=?*) at_optarg=`expr "X$at_option" : '[^=]*=\(.*\)'` ;;
  *)    at_optarg= ;;
  esac

  # Accept the important Cygnus configure options, so we can diagnose typos.

  case $at_option in
    --help | -h )
	at_help_p=:
	;;

    --list | -l )
	at_list_p=:
	;;

    --version | -V )
	at_version_p=:
	;;

    --clean | -c )
	at_clean=:
	;;

    --color )
	at_color=always
	;;
    --color=* )
	case $at_optarg in
	no | never | none) at_color=never ;;
	auto | tty | if-tty) at_color=auto ;;
	always | yes | force) at_color=always ;;
	*) at_optname=`echo " $at_option" | sed 's/^ //; s/=.*//'`
	   as_fn_error $? "unrecognized argument to $at_optname: $at_optarg" ;;
	esac
	;;

    --debug | -d )
	at_debug_p=:
	;;

    --errexit | -e )
	at_debug_p=:
	at_errexit_p=:
	;;

    --verbose | -v )
	at_verbose=; at_quiet=:
	;;

    --trace | -x )
	at_traceon='set -x'
	at_trace_echo=echo
	at_check_filter_trace=at_fn_filter_trace
	;;

    [0-9] | [0-9][0-9] | [0-9][0-9][0-9] | [0-9][0-9][0-9][0-9])
	at_fn_validate_ranges at_option
	as_fn_append at_groups "$at_option$as_nl"
	;;

    # Ranges
    [0-9]- | [0-9][0-9]- | [0-9][0-9][0-9]- | [0-9][0-9][0-9][0-9]-)
	at_range_start=`echo $at_option |tr -d X-`
	at_fn_validate_ranges at_range_start
	at_range=`$as_echo "$at_groups_all" | \
	  sed -ne '/^'$at_range_start'$/,$p'`
	as_fn_append at_groups "$at_range$as_nl"
	;;

    -[0-9] | -[0-9][0-9] | -[0-9][0-9][0-9] | -[0-9][0-9][0-9][0-9])
	at_range_end=`echo $at_option |tr -d X-`
	at_fn_validate_ranges at_range_end
	at_range=`$as_echo "$at_groups_all" | \
	  sed -ne '1,/^'$at_range_end'$/p'`
	as_fn_append at_groups "$at_range$as_nl"
	;;

    [0-9]-[0-9] | [0-9]-[0-9][0-9] | [0-9]-[0-9][0-9][0-9] | \
    [0-9]-[0-9][0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9] | \
    [0-9][0-9]-[0-9][0-9][0-9] | [0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9] | \
    [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] | \
    [0-9][0-9][0-9][0-9]-[0-9][0-9][0-9][0-9] )
	at_range_start=`expr $at_option : '\(.*\)-'`
	at_range_end=`expr $at_option : '.*-\(.*\)'`
	if test $at_range_start -gt $at_range_end; then
	  at_tmp=$at_range_end
	  at_range_end=$at_range_start
	  at_range_start=$at_tmp
	fi
	at_fn_validate_ranges at_range_start at_range_end
	at_range=`$as_echo "$at_groups_all" | \
	  sed -ne '/^'$at_range_start'$/,/^'$at_range_end'$/p'`
	as_fn_append at_groups "$at_range$as_nl"
	;;

    # Directory selection.
    --directory | -C )
	at_prev=--directory
	;;
    --directory=* )
	at_change_dir=:
	at_dir=$at_optarg
	if test x- = "x$at_dir" ; then
	  at_dir=./-
	fi
	;;

    # Parallel execution.
    --jobs | -j )
	at_jobs=0
	;;
    --jobs=* | -j[0-9]* )
	if test -n "$at_optarg"; then
	  at_jobs=$at_optarg
	else
	  at_jobs=`expr X$at_option : 'X-j\(.*\)'`
	fi
	case $at_jobs in *[!0-9]*)
	  at_optname=`echo " $at_option" | sed 's/^ //; s/[0-9=].*//'`
	  as_fn_error $? "non-numeric argument to $at_optname: $at_jobs" ;;
	esac
	;;

    # Keywords.
    --keywords | -k )
	at_prev=--keywords
	;;
    --keywords=* )
	at_groups_selected=$at_help_all
	at_save_IFS=$IFS
	IFS=,
	set X $at_optarg
	shift
	IFS=$at_save_IFS
	for at_keyword
	do
	  at_invert=
	  case $at_keyword in
	  '!'*)
	    at_invert="-v"
	    at_keyword=`expr "X$at_keyword" : 'X!\(.*\)'`
	    ;;
	  esac
	  # It is on purpose that we match the test group titles too.
	  at_groups_selected=`$as_echo "$at_groups_selected" |
	      grep -i $at_invert "^[1-9][^;]*;.*[; ]$at_keyword[ ;]"`
	done
	# Smash the keywords.
	at_groups_selected=`$as_echo "$at_groups_selected" | sed 's/;.*//'`
	as_fn_append at_groups "$at_groups_selected$as_nl"
	;;
    --recheck)
	at_recheck=:
	;;

    *=*)
	at_envvar=`expr "x$at_option" : 'x\([^=]*\)='`
	# Reject names that are not valid shell variable names.
	case $at_envvar in
	  '' | [0-9]* | *[!_$as_cr_alnum]* )
	    as_fn_error $? "invalid variable name: \`$at_envvar'" ;;
	esac
	at_value=`$as_echo "$at_optarg" | sed "s/'/'\\\\\\\\''/g"`
	# Export now, but save eval for later and for debug scripts.
	export $at_envvar
	as_fn_append at_debug_args " $at_envvar='$at_value'"
	;;

     *) $as_echo "$as_me: invalid option: $at_option" >&2
	$as_echo "Try \`$0 --help' for more information." >&2
	exit 1
	;;
  esac
done

# Verify our last option didn't require an argument
if test -n "$at_prev"; then :
  as_fn_error $? "\`$at_prev' requires an argument"
fi

# The file containing the suite.
at_suite_log=$at_dir/$as_me.log

# Selected test groups.
if test -z "$at_groups$at_recheck"; then
  at_groups=$at_groups_all
else
  if test -n "$at_recheck" && test -r "$at_suite_log"; then
    at_oldfails=`sed -n '
      /^Failed tests:$/,/^Skipped tests:$/{
	s/^[ ]*\([1-9][0-9]*\):.*/\1/p
      }
      /^Unexpected passes:$/,/^## Detailed failed tests/{
	s/^[ ]*\([1-9][0-9]*\):.*/\1/p
      }
      /^## Detailed failed tests/q
      ' "$at_suite_log"`
    as_fn_append at_groups "$at_oldfails$as_nl"
  fi
  # Sort the tests, removing duplicates.
  at_groups=`$as_echo "$at_groups" | sort -nu | sed '/^$/d'`
fi

if test x"$at_color" = xalways \
   || { test x"$at_color" = xauto && test -t 1; }; then
  at_red=`printf '\033[0;31m'`
  at_grn=`printf '\033[0;32m'`
  at_lgn=`printf '\033[1;32m'`
  at_blu=`printf '\033[1;34m'`
  at_std=`printf '\033[m'`
else
  at_red= at_grn= at_lgn= at_blu= at_std=
fi

# Help message.
if $at_help_p; then
  cat <<_ATEOF || at_write_fail=1
Usage: $0 [OPTION]... [VARIABLE=VALUE]... [TESTS]

Run all the tests, or the selected TESTS, given by numeric ranges, and
save a detailed log file.  Upon failure, create debugging scripts.

Do not change environment variables directly.  Instead, set them via
command line arguments.  Set \`AUTOTEST_PATH' to select the executables
to exercise.  Each relative directory is expanded as build and source
directories relative to the top level of this distribution.
E.g., from within the build directory /tmp/foo-1.0, invoking this:

  $ $0 AUTOTEST_PATH=bin

is equivalent to the following, assuming the source directory is /src/foo-1.0:

  PATH=/tmp/foo-1.0/bin:/src/foo-1.0/bin:\$PATH $0
_ATEOF
cat <<_ATEOF || at_write_fail=1

Operation modes:
  -h, --help     print the help message, then exit
  -V, --version  print version number, then exit
  -c, --clean    remove all the files this test suite might create and exit
  -l, --list     describes all the tests, or the selected TESTS
_ATEOF
cat <<_ATEOF || at_write_fail=1

Execution tuning:
  -C, --directory=DIR
                 change to directory DIR before starting
      --color[=never|auto|always]
                 enable colored test results on terminal, or always
  -j, --jobs[=N]
                 Allow N jobs at once; infinite jobs with no arg (default 1)
  -k, --keywords=KEYWORDS
                 select the tests matching all the comma-separated KEYWORDS
                 multiple \`-k' accumulate; prefixed \`!' negates a KEYWORD
      --recheck  select all tests that failed or passed unexpectedly last time
  -e, --errexit  abort as soon as a test fails; implies --debug
  -v, --verbose  force more detailed output
                 default for debugging scripts
  -d, --debug    inhibit clean up and top-level logging
                 default for debugging scripts
  -x, --trace    enable tests shell tracing
_ATEOF
cat <<_ATEOF || at_write_fail=1

Report bugs to <crash-catcher@fedorahosted.org>.
_ATEOF
  exit $at_write_fail
fi

# List of tests.
if $at_list_p; then
  cat <<_ATEOF || at_write_fail=1
satyr 0.13 test suite test groups:

 NUM: FILE-NAME:LINE     TEST-GROUP-NAME
      KEYWORDS

_ATEOF
  # Pass an empty line as separator between selected groups and help.
  $as_echo "$at_groups$as_nl$as_nl$at_help_all" |
    awk 'NF == 1 && FS != ";" {
	   selected[$ 1] = 1
	   next
	 }
	 /^$/ { FS = ";" }
	 NF > 0 {
	   if (selected[$ 1]) {
	     printf " %3d: %-18s %s\n", $ 1, $ 2, $ 3
	     if ($ 4) {
	       lmax = 79
	       indent = "     "
	       line = indent
	       len = length (line)
	       n = split ($ 4, a, " ")
	       for (i = 1; i <= n; i++) {
		 l = length (a[i]) + 1
		 if (i > 1 && len + l > lmax) {
		   print line
		   line = indent " " a[i]
		   len = length (line)
		 } else {
		   line = line " " a[i]
		   len += l
		 }
	       }
	       if (n)
		 print line
	     }
	   }
	 }' || at_write_fail=1
  exit $at_write_fail
fi
if $at_version_p; then
  $as_echo "$as_me (satyr 0.13)" &&
  cat <<\_ATEOF || at_write_fail=1

Copyright (C) 2012 Free Software Foundation, Inc.
This test suite is free software; the Free Software Foundation gives
unlimited permission to copy, distribute and modify it.
_ATEOF
  exit $at_write_fail
fi

# Should we print banners?  Yes if more than one test is run.
case $at_groups in #(
  *$as_nl* )
      at_print_banners=: ;; #(
  * ) at_print_banners=false ;;
esac
# Text for banner N, set to a single space once printed.
# Banner 1. utils.at:3
# Category starts at test group 1.
at_banner_text_1="Utils"
# Banner 2. strbuf.at:3
# Category starts at test group 23.
at_banner_text_2="String buffer"
# Banner 3. gdb_frame.at:3
# Category starts at test group 25.
at_banner_text_3="GDB frames"
# Banner 4. gdb_thread.at:3
# Category starts at test group 35.
at_banner_text_4="GDB threads"
# Banner 5. gdb_stacktrace.at:3
# Category starts at test group 41.
at_banner_text_5="GDB stacktraces"
# Banner 6. gdb_sharedlib.at:3
# Category starts at test group 47.
at_banner_text_6="GDB sharedlib"
# Banner 7. java_frame.at:3
# Category starts at test group 51.
at_banner_text_7="Java frames"
# Banner 8. java_thread.at:3
# Category starts at test group 56.
at_banner_text_8="Java threads"
# Banner 9. java_stacktrace.at:3
# Category starts at test group 62.
at_banner_text_9="Java stacktrace"
# Banner 10. koops_frame.at:3
# Category starts at test group 66.
at_banner_text_10="Kerneloops frames"
# Banner 11. koops_stacktrace.at:3
# Category starts at test group 72.
at_banner_text_11="Kerneloops stacktraces"
# Banner 12. core_frame.at:3
# Category starts at test group 75.
at_banner_text_12="Core frames"
# Banner 13. core_thread.at:3
# Category starts at test group 78.
at_banner_text_13="Core threads"
# Banner 14. core_stacktrace.at:3
# Category starts at test group 80.
at_banner_text_14="Core stacktraces"
# Banner 15. operating_system.at:3
# Category starts at test group 82.
at_banner_text_15="Operating system"
# Banner 16. normalize.at:3
# Category starts at test group 84.
at_banner_text_16="Normalization"
# Banner 17. metrics.at:1
# Category starts at test group 87.
at_banner_text_17="Metrics"
# Banner 18. cluster.at:1
# Category starts at test group 106.
at_banner_text_18="Clustering"
# Banner 19. rpm.at:3
# Category starts at test group 108.
at_banner_text_19="RPM"
# Banner 20. abrt.at:3
# Category starts at test group 112.
at_banner_text_20="ABRT"
# Banner 21. report.at:3
# Category starts at test group 113.
at_banner_text_21="Report"
# Banner 22. python_bindings.at:7
# Category starts at test group 115.
at_banner_text_22="BINDINGS"

# Take any -C into account.
if $at_change_dir ; then
  test x != "x$at_dir" && cd "$at_dir" \
    || as_fn_error $? "unable to change directory"
  at_dir=`pwd`
fi

# Load the config files for any default variable assignments.
for at_file in atconfig atlocal
do
  test -r $at_file || continue
  . ./$at_file || as_fn_error $? "invalid content: $at_file"
done

# Autoconf <=2.59b set at_top_builddir instead of at_top_build_prefix:
: "${at_top_build_prefix=$at_top_builddir}"

# Perform any assignments requested during argument parsing.
eval "$at_debug_args"

# atconfig delivers names relative to the directory the test suite is
# in, but the groups themselves are run in testsuite-dir/group-dir.
if test -n "$at_top_srcdir"; then
  builddir=../..
  for at_dir_var in srcdir top_srcdir top_build_prefix
  do
    eval at_val=\$at_$at_dir_var
    case $at_val in
      [\\/$]* | ?:[\\/]* ) at_prefix= ;;
      *) at_prefix=../../ ;;
    esac
    eval "$at_dir_var=\$at_prefix\$at_val"
  done
fi

## -------------------- ##
## Directory structure. ##
## -------------------- ##

# This is the set of directories and files used by this script
# (non-literals are capitalized):
#
# TESTSUITE         - the testsuite
# TESTSUITE.log     - summarizes the complete testsuite run
# TESTSUITE.dir/    - created during a run, remains after -d or failed test
# + at-groups/      - during a run: status of all groups in run
# | + NNN/          - during a run: meta-data about test group NNN
# | | + check-line  - location (source file and line) of current AT_CHECK
# | | + status      - exit status of current AT_CHECK
# | | + stdout      - stdout of current AT_CHECK
# | | + stder1      - stderr, including trace
# | | + stderr      - stderr, with trace filtered out
# | | + test-source - portion of testsuite that defines group
# | | + times       - timestamps for computing duration
# | | + pass        - created if group passed
# | | + xpass       - created if group xpassed
# | | + fail        - created if group failed
# | | + xfail       - created if group xfailed
# | | + skip        - created if group skipped
# + at-stop         - during a run: end the run if this file exists
# + at-source-lines - during a run: cache of TESTSUITE line numbers for extraction
# + 0..NNN/         - created for each group NNN, remains after -d or failed test
# | + TESTSUITE.log - summarizes the group results
# | + ...           - files created during the group

# The directory the whole suite works in.
# Should be absolute to let the user `cd' at will.
at_suite_dir=$at_dir/$as_me.dir
# The file containing the suite ($at_dir might have changed since earlier).
at_suite_log=$at_dir/$as_me.log
# The directory containing helper files per test group.
at_helper_dir=$at_suite_dir/at-groups
# Stop file: if it exists, do not start new jobs.
at_stop_file=$at_suite_dir/at-stop
# The fifo used for the job dispatcher.
at_job_fifo=$at_suite_dir/at-job-fifo

if $at_clean; then
  test -d "$at_suite_dir" &&
    find "$at_suite_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
  rm -f -r "$at_suite_dir" "$at_suite_log"
  exit $?
fi

# Don't take risks: use only absolute directories in PATH.
#
# For stand-alone test suites (ie. atconfig was not found),
# AUTOTEST_PATH is relative to `.'.
#
# For embedded test suites, AUTOTEST_PATH is relative to the top level
# of the package.  Then expand it into build/src parts, since users
# may create executables in both places.
AUTOTEST_PATH=`$as_echo "$AUTOTEST_PATH" | sed "s|:|$PATH_SEPARATOR|g"`
at_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $AUTOTEST_PATH $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -n "$at_path" && as_fn_append at_path $PATH_SEPARATOR
case $as_dir in
  [\\/]* | ?:[\\/]* )
    as_fn_append at_path "$as_dir"
    ;;
  * )
    if test -z "$at_top_build_prefix"; then
      # Stand-alone test suite.
      as_fn_append at_path "$as_dir"
    else
      # Embedded test suite.
      as_fn_append at_path "$at_top_build_prefix$as_dir$PATH_SEPARATOR"
      as_fn_append at_path "$at_top_srcdir/$as_dir"
    fi
    ;;
esac
  done
IFS=$as_save_IFS


# Now build and simplify PATH.
#
# There might be directories that don't exist, but don't redirect
# builtins' (eg., cd) stderr directly: Ultrix's sh hates that.
at_new_path=
as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $at_path
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -d "$as_dir" || continue
case $as_dir in
  [\\/]* | ?:[\\/]* ) ;;
  * ) as_dir=`(cd "$as_dir" && pwd) 2>/dev/null` ;;
esac
case $PATH_SEPARATOR$at_new_path$PATH_SEPARATOR in
  *$PATH_SEPARATOR$as_dir$PATH_SEPARATOR*) ;;
  $PATH_SEPARATOR$PATH_SEPARATOR) at_new_path=$as_dir ;;
  *) as_fn_append at_new_path "$PATH_SEPARATOR$as_dir" ;;
esac
  done
IFS=$as_save_IFS

PATH=$at_new_path
export PATH

# Setting up the FDs.



# 5 is the log file.  Not to be overwritten if `-d'.
if $at_debug_p; then
  at_suite_log=/dev/null
else
  : >"$at_suite_log"
fi
exec 5>>"$at_suite_log"

# Banners and logs.
$as_echo "## ---------------------- ##
## satyr 0.13 test suite. ##
## ---------------------- ##"
{
  $as_echo "## ---------------------- ##
## satyr 0.13 test suite. ##
## ---------------------- ##"
  echo

  $as_echo "$as_me: command line was:"
  $as_echo "  \$ $0 $at_cli_args"
  echo

  # If ChangeLog exists, list a few lines in case it might help determining
  # the exact version.
  if test -n "$at_top_srcdir" && test -f "$at_top_srcdir/ChangeLog"; then
    $as_echo "## ---------- ##
## ChangeLog. ##
## ---------- ##"
    echo
    sed 's/^/| /;10q' "$at_top_srcdir/ChangeLog"
    echo
  fi

  {
cat <<_ASUNAME
## --------- ##
## Platform. ##
## --------- ##

hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
uname -m = `(uname -m) 2>/dev/null || echo unknown`
uname -r = `(uname -r) 2>/dev/null || echo unknown`
uname -s = `(uname -s) 2>/dev/null || echo unknown`
uname -v = `(uname -v) 2>/dev/null || echo unknown`

/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`

/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`

_ASUNAME

as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    $as_echo "PATH: $as_dir"
  done
IFS=$as_save_IFS

}
  echo

  # Contents of the config files.
  for at_file in atconfig atlocal
  do
    test -r $at_file || continue
    $as_echo "$as_me: $at_file:"
    sed 's/^/| /' $at_file
    echo
  done
} >&5


## ------------------------- ##
## Autotest shell functions. ##
## ------------------------- ##

# at_fn_banner NUMBER
# -------------------
# Output banner NUMBER, provided the testsuite is running multiple groups and
# this particular banner has not yet been printed.
at_fn_banner ()
{
  $at_print_banners || return 0
  eval at_banner_text=\$at_banner_text_$1
  test "x$at_banner_text" = "x " && return 0
  eval "at_banner_text_$1=\" \""
  if test -z "$at_banner_text"; then
    $at_first || echo
  else
    $as_echo "$as_nl$at_banner_text$as_nl"
  fi
} # at_fn_banner

# at_fn_check_prepare_notrace REASON LINE
# ---------------------------------------
# Perform AT_CHECK preparations for the command at LINE for an untraceable
# command; REASON is the reason for disabling tracing.
at_fn_check_prepare_notrace ()
{
  $at_trace_echo "Not enabling shell tracing (command contains $1)"
  $as_echo "$2" >"$at_check_line_file"
  at_check_trace=: at_check_filter=:
  : >"$at_stdout"; : >"$at_stderr"
}

# at_fn_check_prepare_trace LINE
# ------------------------------
# Perform AT_CHECK preparations for the command at LINE for a traceable
# command.
at_fn_check_prepare_trace ()
{
  $as_echo "$1" >"$at_check_line_file"
  at_check_trace=$at_traceon at_check_filter=$at_check_filter_trace
  : >"$at_stdout"; : >"$at_stderr"
}

# at_fn_check_prepare_dynamic COMMAND LINE
# ----------------------------------------
# Decide if COMMAND at LINE is traceable at runtime, and call the appropriate
# preparation function.
at_fn_check_prepare_dynamic ()
{
  case $1 in
    *$as_nl*)
      at_fn_check_prepare_notrace 'an embedded newline' "$2" ;;
    *)
      at_fn_check_prepare_trace "$2" ;;
  esac
}

# at_fn_filter_trace
# ------------------
# Remove the lines in the file "$at_stderr" generated by "set -x" and print
# them to stderr.
at_fn_filter_trace ()
{
  mv "$at_stderr" "$at_stder1"
  grep '^ *+' "$at_stder1" >&2
  grep -v '^ *+' "$at_stder1" >"$at_stderr"
}

# at_fn_log_failure FILE-LIST
# ---------------------------
# Copy the files in the list on stdout with a "> " prefix, and exit the shell
# with a failure exit code.
at_fn_log_failure ()
{
  for file
    do $as_echo "$file:"; sed 's/^/> /' "$file"; done
  echo 1 > "$at_status_file"
  exit 1
}

# at_fn_check_skip EXIT-CODE LINE
# -------------------------------
# Check whether EXIT-CODE is a special exit code (77 or 99), and if so exit
# the test group subshell with that same exit code. Use LINE in any report
# about test failure.
at_fn_check_skip ()
{
  case $1 in
    99) echo 99 > "$at_status_file"; at_failed=:
	$as_echo "$2: hard failure"; exit 99;;
    77) echo 77 > "$at_status_file"; exit 77;;
  esac
}

# at_fn_check_status EXPECTED EXIT-CODE LINE
# ------------------------------------------
# Check whether EXIT-CODE is the EXPECTED exit code, and if so do nothing.
# Otherwise, if it is 77 or 99, exit the test group subshell with that same
# exit code; if it is anything else print an error message referring to LINE,
# and fail the test.
at_fn_check_status ()
{
  case $2 in
    $1 ) ;;
    77) echo 77 > "$at_status_file"; exit 77;;
    99) echo 99 > "$at_status_file"; at_failed=:
	$as_echo "$3: hard failure"; exit 99;;
    *) $as_echo "$3: exit code was $2, expected $1"
      at_failed=:;;
  esac
}

# at_fn_diff_devnull FILE
# -----------------------
# Emit a diff between /dev/null and FILE. Uses "test -s" to avoid useless diff
# invocations.
at_fn_diff_devnull ()
{
  test -s "$1" || return 0
  $at_diff "$at_devnull" "$1"
}

# at_fn_test NUMBER
# -----------------
# Parse out test NUMBER from the tail of this file.
at_fn_test ()
{
  eval at_sed=\$at_sed$1
  sed "$at_sed" "$at_myself" > "$at_test_source"
}

# at_fn_create_debugging_script
# -----------------------------
# Create the debugging script $at_group_dir/run which will reproduce the
# current test group.
at_fn_create_debugging_script ()
{
  {
    echo "#! /bin/sh" &&
    echo 'test "${ZSH_VERSION+set}" = set && alias -g '\''${1+"$@"}'\''='\''"$@"'\''' &&
    $as_echo "cd '$at_dir'" &&
    $as_echo "exec \${CONFIG_SHELL-$SHELL} \"$at_myself\" -v -d $at_debug_args $at_group \${1+\"\$@\"}" &&
    echo 'exit 1'
  } >"$at_group_dir/run" &&
  chmod +x "$at_group_dir/run"
}

## -------------------------------- ##
## End of autotest shell functions. ##
## -------------------------------- ##
{
  $as_echo "## ---------------- ##
## Tested programs. ##
## ---------------- ##"
  echo
} >&5

# Report what programs are being tested.
for at_program in : $at_tested
do
  test "$at_program" = : && continue
  case $at_program in
    [\\/]* | ?:[\\/]* ) $at_program_=$at_program ;;
    * )
    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
for as_dir in $PATH
do
  IFS=$as_save_IFS
  test -z "$as_dir" && as_dir=.
    test -f "$as_dir/$at_program" && break
  done
IFS=$as_save_IFS

    at_program_=$as_dir/$at_program ;;
  esac
  if test -f "$at_program_"; then
    {
      $as_echo "$at_srcdir/local.at:27: $at_program_ --version"
      "$at_program_" --version </dev/null
      echo
    } >&5 2>&1
  else
    as_fn_error $? "cannot find $at_program" "$LINENO" 5
  fi
done

{
  $as_echo "## ------------------ ##
## Running the tests. ##
## ------------------ ##"
} >&5

at_start_date=`date`
at_start_time=`date +%s 2>/dev/null`
$as_echo "$as_me: starting at: $at_start_date" >&5

# Create the master directory if it doesn't already exist.
as_dir="$at_suite_dir"; as_fn_mkdir_p ||
  as_fn_error $? "cannot create \`$at_suite_dir'" "$LINENO" 5

# Can we diff with `/dev/null'?  DU 5.0 refuses.
if diff /dev/null /dev/null >/dev/null 2>&1; then
  at_devnull=/dev/null
else
  at_devnull=$at_suite_dir/devnull
  >"$at_devnull"
fi

# Use `diff -u' when possible.
if at_diff=`diff -u "$at_devnull" "$at_devnull" 2>&1` && test -z "$at_diff"
then
  at_diff='diff -u'
else
  at_diff=diff
fi

# Get the last needed group.
for at_group in : $at_groups; do :; done

# Extract the start and end lines of each test group at the tail
# of this file
awk '
BEGIN { FS="" }
/^#AT_START_/ {
  start = NR
}
/^#AT_STOP_/ {
  test = substr ($ 0, 10)
  print "at_sed" test "=\"1," start "d;" (NR-1) "q\""
  if (test == "'"$at_group"'") exit
}' "$at_myself" > "$at_suite_dir/at-source-lines" &&
. "$at_suite_dir/at-source-lines" ||
  as_fn_error $? "cannot create test line number cache" "$LINENO" 5
rm -f "$at_suite_dir/at-source-lines"

# Set number of jobs for `-j'; avoid more jobs than test groups.
set X $at_groups; shift; at_max_jobs=$#
if test $at_max_jobs -eq 0; then
  at_jobs=1
fi
if test $at_jobs -ne 1 &&
   { test $at_jobs -eq 0 || test $at_jobs -gt $at_max_jobs; }; then
  at_jobs=$at_max_jobs
fi

# If parallel mode, don't output banners, don't split summary lines.
if test $at_jobs -ne 1; then
  at_print_banners=false
  at_quiet=:
fi

# Set up helper dirs.
rm -rf "$at_helper_dir" &&
mkdir "$at_helper_dir" &&
cd "$at_helper_dir" &&
{ test -z "$at_groups" || mkdir $at_groups; } ||
as_fn_error $? "testsuite directory setup failed" "$LINENO" 5

# Functions for running a test group.  We leave the actual
# test group execution outside of a shell function in order
# to avoid hitting zsh 4.x exit status bugs.

# at_fn_group_prepare
# -------------------
# Prepare for running a test group.
at_fn_group_prepare ()
{
  # The directory for additional per-group helper files.
  at_job_dir=$at_helper_dir/$at_group
  # The file containing the location of the last AT_CHECK.
  at_check_line_file=$at_job_dir/check-line
  # The file containing the exit status of the last command.
  at_status_file=$at_job_dir/status
  # The files containing the output of the tested commands.
  at_stdout=$at_job_dir/stdout
  at_stder1=$at_job_dir/stder1
  at_stderr=$at_job_dir/stderr
  # The file containing the code for a test group.
  at_test_source=$at_job_dir/test-source
  # The file containing dates.
  at_times_file=$at_job_dir/times

  # Be sure to come back to the top test directory.
  cd "$at_suite_dir"

  # Clearly separate the test groups when verbose.
  $at_first || $at_verbose echo

  at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'


  # Create a fresh directory for the next test group, and enter.
  # If one already exists, the user may have invoked ./run from
  # within that directory; we remove the contents, but not the
  # directory itself, so that we aren't pulling the rug out from
  # under the shell's notion of the current directory.
  at_group_dir=$at_suite_dir/$at_group_normalized
  at_group_log=$at_group_dir/$as_me.log
  if test -d "$at_group_dir"; then
  find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx {} \;
  rm -fr "$at_group_dir"/* "$at_group_dir"/.[!.] "$at_group_dir"/.??*
fi ||
    { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: test directory for $at_group_normalized could not be cleaned" >&5
$as_echo "$as_me: WARNING: test directory for $at_group_normalized could not be cleaned" >&2;}
  # Be tolerant if the above `rm' was not able to remove the directory.
  as_dir="$at_group_dir"; as_fn_mkdir_p

  echo 0 > "$at_status_file"

  # In verbose mode, append to the log file *and* show on
  # the standard output; in quiet mode only write to the log.
  if test -z "$at_verbose"; then
    at_tee_pipe='tee -a "$at_group_log"'
  else
    at_tee_pipe='cat >> "$at_group_log"'
  fi
}

# at_fn_group_banner ORDINAL LINE DESC PAD [BANNER]
# -------------------------------------------------
# Declare the test group ORDINAL, located at LINE with group description DESC,
# and residing under BANNER. Use PAD to align the status column.
at_fn_group_banner ()
{
  at_setup_line="$2"
  test -n "$5" && at_fn_banner $5
  at_desc="$3"
  case $1 in
    [0-9])      at_desc_line="  $1: ";;
    [0-9][0-9]) at_desc_line=" $1: " ;;
    *)          at_desc_line="$1: "  ;;
  esac
  as_fn_append at_desc_line "$3$4"
  $at_quiet $as_echo_n "$at_desc_line"
  echo "#                             -*- compilation -*-" >> "$at_group_log"
}

# at_fn_group_postprocess
# -----------------------
# Perform cleanup after running a test group.
at_fn_group_postprocess ()
{
  # Be sure to come back to the suite directory, in particular
  # since below we might `rm' the group directory we are in currently.
  cd "$at_suite_dir"

  if test ! -f "$at_check_line_file"; then
    sed "s/^ */$as_me: WARNING: /" <<_ATEOF
      A failure happened in a test group before any test could be
      run. This means that test suite is improperly designed.  Please
      report this failure to <crash-catcher@fedorahosted.org>.
_ATEOF
    $as_echo "$at_setup_line" >"$at_check_line_file"
    at_status=99
  fi
  $at_verbose $as_echo_n "$at_group. $at_setup_line: "
  $as_echo_n "$at_group. $at_setup_line: " >> "$at_group_log"
  case $at_xfail:$at_status in
    yes:0)
	at_msg="UNEXPECTED PASS"
	at_res=xpass
	at_errexit=$at_errexit_p
	at_color=$at_red
	;;
    no:0)
	at_msg="ok"
	at_res=pass
	at_errexit=false
	at_color=$at_grn
	;;
    *:77)
	at_msg='skipped ('`cat "$at_check_line_file"`')'
	at_res=skip
	at_errexit=false
	at_color=$at_blu
	;;
    no:* | *:99)
	at_msg='FAILED ('`cat "$at_check_line_file"`')'
	at_res=fail
	at_errexit=$at_errexit_p
	at_color=$at_red
	;;
    yes:*)
	at_msg='expected failure ('`cat "$at_check_line_file"`')'
	at_res=xfail
	at_errexit=false
	at_color=$at_lgn
	;;
  esac
  echo "$at_res" > "$at_job_dir/$at_res"
  # In parallel mode, output the summary line only afterwards.
  if test $at_jobs -ne 1 && test -n "$at_verbose"; then
    $as_echo "$at_desc_line $at_color$at_msg$at_std"
  else
    # Make sure there is a separator even with long titles.
    $as_echo " $at_color$at_msg$at_std"
  fi
  at_log_msg="$at_group. $at_desc ($at_setup_line): $at_msg"
  case $at_status in
    0|77)
      # $at_times_file is only available if the group succeeded.
      # We're not including the group log, so the success message
      # is written in the global log separately.  But we also
      # write to the group log in case they're using -d.
      if test -f "$at_times_file"; then
	at_log_msg="$at_log_msg     ("`sed 1d "$at_times_file"`')'
	rm -f "$at_times_file"
      fi
      $as_echo "$at_log_msg" >> "$at_group_log"
      $as_echo "$at_log_msg" >&5

      # Cleanup the group directory, unless the user wants the files
      # or the success was unexpected.
      if $at_debug_p || test $at_res = xpass; then
	at_fn_create_debugging_script
	if test $at_res = xpass && $at_errexit; then
	  echo stop > "$at_stop_file"
	fi
      else
	if test -d "$at_group_dir"; then
	  find "$at_group_dir" -type d ! -perm -700 -exec chmod u+rwx \{\} \;
	  rm -fr "$at_group_dir"
	fi
	rm -f "$at_test_source"
      fi
      ;;
    *)
      # Upon failure, include the log into the testsuite's global
      # log.  The failure message is written in the group log.  It
      # is later included in the global log.
      $as_echo "$at_log_msg" >> "$at_group_log"

      # Upon failure, keep the group directory for autopsy, and create
      # the debugging script.  With -e, do not start any further tests.
      at_fn_create_debugging_script
      if $at_errexit; then
	echo stop > "$at_stop_file"
      fi
      ;;
  esac
}


## ------------ ##
## Driver loop. ##
## ------------ ##


if (set -m && set +m && set +b) >/dev/null 2>&1; then
  set +b
  at_job_control_on='set -m' at_job_control_off='set +m' at_job_group=-
else
  at_job_control_on=: at_job_control_off=: at_job_group=
fi

for at_signal in 1 2 15; do
  trap 'set +x; set +e
	$at_job_control_off
	at_signal='"$at_signal"'
	echo stop > "$at_stop_file"
	trap "" $at_signal
	at_pgids=
	for at_pgid in `jobs -p 2>/dev/null`; do
	  at_pgids="$at_pgids $at_job_group$at_pgid"
	done
	test -z "$at_pgids" || kill -$at_signal $at_pgids 2>/dev/null
	wait
	if test "$at_jobs" -eq 1 || test -z "$at_verbose"; then
	  echo >&2
	fi
	at_signame=`kill -l $at_signal 2>&1 || echo $at_signal`
	set x $at_signame
	test 0 -gt 2 && at_signame=$at_signal
	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: caught signal $at_signame, bailing out" >&5
$as_echo "$as_me: WARNING: caught signal $at_signame, bailing out" >&2;}
	as_fn_arith 128 + $at_signal && exit_status=$as_val
	as_fn_exit $exit_status' $at_signal
done

rm -f "$at_stop_file"
at_first=:

if test $at_jobs -ne 1 &&
     rm -f "$at_job_fifo" &&
     test -n "$at_job_group" &&
     ( mkfifo "$at_job_fifo" && trap 'exit 1' PIPE STOP TSTP ) 2>/dev/null
then
  # FIFO job dispatcher.

  trap 'at_pids=
	for at_pid in `jobs -p`; do
	  at_pids="$at_pids $at_job_group$at_pid"
	done
	if test -n "$at_pids"; then
	  at_sig=TSTP
	  test "${TMOUT+set}" = set && at_sig=STOP
	  kill -$at_sig $at_pids 2>/dev/null
	fi
	kill -STOP $$
	test -z "$at_pids" || kill -CONT $at_pids 2>/dev/null' TSTP

  echo
  # Turn jobs into a list of numbers, starting from 1.
  at_joblist=`$as_echo "$at_groups" | sed -n 1,${at_jobs}p`

  set X $at_joblist
  shift
  for at_group in $at_groups; do
    $at_job_control_on 2>/dev/null
    (
      # Start one test group.
      $at_job_control_off
      if $at_first; then
	exec 7>"$at_job_fifo"
      else
	exec 6<&-
      fi
      trap 'set +x; set +e
	    trap "" PIPE
	    echo stop > "$at_stop_file"
	    echo >&7
	    as_fn_exit 141' PIPE
      at_fn_group_prepare
      if cd "$at_group_dir" &&
	 at_fn_test $at_group &&
	 . "$at_test_source"
      then :; else
	{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unable to parse test group: $at_group" >&5
$as_echo "$as_me: WARNING: unable to parse test group: $at_group" >&2;}
	at_failed=:
      fi
      at_fn_group_postprocess
      echo >&7
    ) &
    $at_job_control_off
    if $at_first; then
      at_first=false
      exec 6<"$at_job_fifo" 7>"$at_job_fifo"
    fi
    shift # Consume one token.
    if test $# -gt 0; then :; else
      read at_token <&6 || break
      set x $*
    fi
    test -f "$at_stop_file" && break
  done
  exec 7>&-
  # Read back the remaining ($at_jobs - 1) tokens.
  set X $at_joblist
  shift
  if test $# -gt 0; then
    shift
    for at_job
    do
      read at_token
    done <&6
  fi
  exec 6<&-
  wait
else
  # Run serially, avoid forks and other potential surprises.
  for at_group in $at_groups; do
    at_fn_group_prepare
    if cd "$at_group_dir" &&
       at_fn_test $at_group &&
       . "$at_test_source"; then :; else
      { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unable to parse test group: $at_group" >&5
$as_echo "$as_me: WARNING: unable to parse test group: $at_group" >&2;}
      at_failed=:
    fi
    at_fn_group_postprocess
    test -f "$at_stop_file" && break
    at_first=false
  done
fi

# Wrap up the test suite with summary statistics.
cd "$at_helper_dir"

# Use ?..???? when the list must remain sorted, the faster * otherwise.
at_pass_list=`for f in */pass; do echo $f; done | sed '/\*/d; s,/pass,,'`
at_skip_list=`for f in */skip; do echo $f; done | sed '/\*/d; s,/skip,,'`
at_xfail_list=`for f in */xfail; do echo $f; done | sed '/\*/d; s,/xfail,,'`
at_xpass_list=`for f in ?/xpass ??/xpass ???/xpass ????/xpass; do
		 echo $f; done | sed '/?/d; s,/xpass,,'`
at_fail_list=`for f in ?/fail ??/fail ???/fail ????/fail; do
		echo $f; done | sed '/?/d; s,/fail,,'`

set X $at_pass_list $at_xpass_list $at_xfail_list $at_fail_list $at_skip_list
shift; at_group_count=$#
set X $at_xpass_list; shift; at_xpass_count=$#; at_xpass_list=$*
set X $at_xfail_list; shift; at_xfail_count=$#
set X $at_fail_list; shift; at_fail_count=$#; at_fail_list=$*
set X $at_skip_list; shift; at_skip_count=$#

as_fn_arith $at_group_count - $at_skip_count && at_run_count=$as_val
as_fn_arith $at_xpass_count + $at_fail_count && at_unexpected_count=$as_val
as_fn_arith $at_xfail_count + $at_fail_count && at_total_fail_count=$as_val

# Back to the top directory.
cd "$at_dir"
rm -rf "$at_helper_dir"

# Compute the duration of the suite.
at_stop_date=`date`
at_stop_time=`date +%s 2>/dev/null`
$as_echo "$as_me: ending at: $at_stop_date" >&5
case $at_start_time,$at_stop_time in
  [0-9]*,[0-9]*)
    as_fn_arith $at_stop_time - $at_start_time && at_duration_s=$as_val
    as_fn_arith $at_duration_s / 60 && at_duration_m=$as_val
    as_fn_arith $at_duration_m / 60 && at_duration_h=$as_val
    as_fn_arith $at_duration_s % 60 && at_duration_s=$as_val
    as_fn_arith $at_duration_m % 60 && at_duration_m=$as_val
    at_duration="${at_duration_h}h ${at_duration_m}m ${at_duration_s}s"
    $as_echo "$as_me: test suite duration: $at_duration" >&5
    ;;
esac

echo
$as_echo "## ------------- ##
## Test results. ##
## ------------- ##"
echo
{
  echo
  $as_echo "## ------------- ##
## Test results. ##
## ------------- ##"
  echo
} >&5

if test $at_run_count = 1; then
  at_result="1 test"
  at_were=was
else
  at_result="$at_run_count tests"
  at_were=were
fi
if $at_errexit_p && test $at_unexpected_count != 0; then
  if test $at_xpass_count = 1; then
    at_result="$at_result $at_were run, one passed"
  else
    at_result="$at_result $at_were run, one failed"
  fi
  at_result="$at_result unexpectedly and inhibited subsequent tests."
  at_color=$at_red
else
  # Don't you just love exponential explosion of the number of cases?
  at_color=$at_red
  case $at_xpass_count:$at_fail_count:$at_xfail_count in
    # So far, so good.
    0:0:0) at_result="$at_result $at_were successful." at_color=$at_grn ;;
    0:0:*) at_result="$at_result behaved as expected." at_color=$at_lgn ;;

    # Some unexpected failures
    0:*:0) at_result="$at_result $at_were run,
$at_fail_count failed unexpectedly." ;;

    # Some failures, both expected and unexpected
    0:*:1) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    0:*:*) at_result="$at_result $at_were run,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;

    # No unexpected failures, but some xpasses
    *:0:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly." ;;

    # No expected failures, but failures and xpasses
    *:1:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failure)." ;;
    *:*:0) at_result="$at_result $at_were run,
$at_unexpected_count did not behave as expected ($at_fail_count unexpected failures)." ;;

    # All of them.
    *:*:1) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failure)." ;;
    *:*:*) at_result="$at_result $at_were run,
$at_xpass_count passed unexpectedly,
$at_total_fail_count failed ($at_xfail_count expected failures)." ;;
  esac

  if test $at_skip_count = 0 && test $at_run_count -gt 1; then
    at_result="All $at_result"
  fi
fi

# Now put skips in the mix.
case $at_skip_count in
  0) ;;
  1) at_result="$at_result
1 test was skipped." ;;
  *) at_result="$at_result
$at_skip_count tests were skipped." ;;
esac

if test $at_unexpected_count = 0; then
  echo "$at_color$at_result$at_std"
  echo "$at_result" >&5
else
  echo "${at_color}ERROR: $at_result$at_std" >&2
  echo "ERROR: $at_result" >&5
  {
    echo
    $as_echo "## ------------------------ ##
## Summary of the failures. ##
## ------------------------ ##"

    # Summary of failed and skipped tests.
    if test $at_fail_count != 0; then
      echo "Failed tests:"
      $SHELL "$at_myself" $at_fail_list --list
      echo
    fi
    if test $at_skip_count != 0; then
      echo "Skipped tests:"
      $SHELL "$at_myself" $at_skip_list --list
      echo
    fi
    if test $at_xpass_count != 0; then
      echo "Unexpected passes:"
      $SHELL "$at_myself" $at_xpass_list --list
      echo
    fi
    if test $at_fail_count != 0; then
      $as_echo "## ---------------------- ##
## Detailed failed tests. ##
## ---------------------- ##"
      echo
      for at_group in $at_fail_list
      do
	at_group_normalized=$at_group

  eval 'while :; do
    case $at_group_normalized in #(
    '"$at_format"'*) break;;
    esac
    at_group_normalized=0$at_group_normalized
  done'

	cat "$at_suite_dir/$at_group_normalized/$as_me.log"
	echo
      done
      echo
    fi
    if test -n "$at_top_srcdir"; then
      sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## ${at_top_build_prefix}config.log ##
_ASBOX
      sed 's/^/| /' ${at_top_build_prefix}config.log
      echo
    fi
  } >&5

  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
## $as_me.log was created. ##
_ASBOX

  echo
  if $at_debug_p; then
    at_msg='per-test log files'
  else
    at_msg="\`${at_testdir+${at_testdir}/}$as_me.log'"
  fi
  $as_echo "Please send $at_msg and all information you think might help:

   To: <crash-catcher@fedorahosted.org>
   Subject: [satyr 0.13] $as_me: $at_fail_list${at_fail_list:+ failed${at_xpass_list:+, }}$at_xpass_list${at_xpass_list:+ passed unexpectedly}

You may investigate any problem if you feel able to do so, in which
case the test suite provides a good starting point.  Its output may
be found below \`${at_testdir+${at_testdir}/}$as_me.dir'.
"
  exit 1
fi

exit 0

## ------------- ##
## Actual tests. ##
## ------------- ##
#AT_START_1
at_fn_group_banner 1 'utils.at:9' \
  "sr_strcmp0" "                                     " 1
at_xfail=no
(
  $as_echo "1. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_strcmp0.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  assert(0 == sr_strcmp0(NULL, NULL));
  assert(0 == sr_strcmp0("abab", "abab"));
  assert(0 > sr_strcmp0("aba", "abab"));
  assert(0 > sr_strcmp0(NULL, "abab"));
  assert(0 < sr_strcmp0("abab", NULL));
  assert(0 < sr_strcmp0("abab", "aba"));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:9: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_strcmp0 sr_strcmp0.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strcmp0 sr_strcmp0.c $LIBS" "utils.at:9"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strcmp0 sr_strcmp0.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:9: ./sr_strcmp0"
at_fn_check_prepare_trace "utils.at:9"
( $at_check_trace; ./sr_strcmp0
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_1
#AT_START_2
at_fn_group_banner 2 'utils.at:29' \
  "sr_strchr_location" "                             " 1
at_xfail=no
(
  $as_echo "2. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_strchr_location.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  /* The character is on the first line.*/
  int line, column;
  char *result = sr_strchr_location("test string", 'r', &line, &column);
  assert(0 == strcmp(result, "ring"));
  assert(1 == line);
  assert(7 == column);

  /* The character is on the third line. */
  result = sr_strchr_location("\ntest\n string", 'r', &line, &column);
  assert(0 == strcmp(result, "ring"));
  assert(3 == line);
  assert(3 == column);

  /* The character is not found. */
  result = sr_strchr_location("\ntest\n string", 'z', &line, &column);
  assert(!result);

  /* The character _is_ a newline. */
  result = sr_strchr_location("abcd\nefgh", '\n', &line, &column);
  assert(0 == strcmp(result, "\nefgh"));
  assert(1 == line);
  assert(4 == column);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:29: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_strchr_location sr_strchr_location.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strchr_location sr_strchr_location.c $LIBS" "utils.at:29"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strchr_location sr_strchr_location.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:29"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:29: ./sr_strchr_location"
at_fn_check_prepare_trace "utils.at:29"
( $at_check_trace; ./sr_strchr_location
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:29"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_2
#AT_START_3
at_fn_group_banner 3 'utils.at:65' \
  "sr_strstr_location" "                             " 1
at_xfail=no
(
  $as_echo "3. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_strstr_location.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  /* The substring is on the first line.*/
  int line, column;
  char *result = sr_strstr_location("test string", "ri", &line, &column);
  assert(0 == strcmp(result, "ring"));
  assert(1 == line);
  assert(7 == column);

  /* The substring is on the third line. */
  result = sr_strstr_location("\ntest\n string", "ri", &line, &column);
  assert(0 == strcmp(result, "ring"));
  assert(3 == line);
  assert(3 == column);

  /* The substring is not found, but the first char is. */
  result = sr_strstr_location("\ntest\n string", "rz", &line, &column);
  assert(!result);

  /* The substring is not found. */
  result = sr_strstr_location("\ntest\n string", "zr", &line, &column);
  assert(!result);

  /* The substring _is_ a newline. */
  result = sr_strstr_location("abcd\nefgh", "\n", &line, &column);
  assert(0 == strcmp(result, "\nefgh"));
  assert(1 == line);
  assert(4 == column);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:65: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_strstr_location sr_strstr_location.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strstr_location sr_strstr_location.c $LIBS" "utils.at:65"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strstr_location sr_strstr_location.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:65"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:65: ./sr_strstr_location"
at_fn_check_prepare_trace "utils.at:65"
( $at_check_trace; ./sr_strstr_location
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:65"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_3
#AT_START_4
at_fn_group_banner 4 'utils.at:105' \
  "sr_strspn_location" "                             " 1
at_xfail=no
(
  $as_echo "4. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_strspn_location.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  /* No newline in the input.*/
  int line, column;
  size_t count = sr_strspn_location("test string",
                                     "tes ",
                                     &line,
                                     &column);
  assert(7 == count);
  assert(1 == line);
  assert(7 == column);

  /* With some newlines. */
  count = sr_strspn_location("te\nst \nstring",
                              "tes \n",
                              &line,
                              &column);
  assert(9 == count);
  assert(3 == line);
  assert(2 == column);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:105: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_strspn_location sr_strspn_location.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strspn_location sr_strspn_location.c $LIBS" "utils.at:105"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strspn_location sr_strspn_location.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:105"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:105: ./sr_strspn_location"
at_fn_check_prepare_trace "utils.at:105"
( $at_check_trace; ./sr_strspn_location
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:105"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_4
#AT_START_5
at_fn_group_banner 5 'utils.at:138' \
  "sr_skip_char" "                                   " 1
at_xfail=no
(
  $as_echo "5. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_skip_char.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "abc";
  assert(sr_skip_char(&input, 'a'));
  assert(!sr_skip_char(&input, 'c'));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:138: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_skip_char sr_skip_char.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_char sr_skip_char.c $LIBS" "utils.at:138"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_char sr_skip_char.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:138"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:138: ./sr_skip_char"
at_fn_check_prepare_trace "utils.at:138"
( $at_check_trace; ./sr_skip_char
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:138"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_5
#AT_START_6
at_fn_group_banner 6 'utils.at:155' \
  "sr_skip_char_limited" "                           " 1
at_xfail=no
(
  $as_echo "6. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_skip_char_limited.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "abc";
  assert(sr_skip_char_limited(&input, "ab"));
  assert(sr_skip_char_limited(&input, "ab"));
  assert(!sr_skip_char_limited(&input, "ab"));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:155: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_skip_char_limited sr_skip_char_limited.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_char_limited sr_skip_char_limited.c $LIBS" "utils.at:155"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_char_limited sr_skip_char_limited.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:155"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:155: ./sr_skip_char_limited"
at_fn_check_prepare_trace "utils.at:155"
( $at_check_trace; ./sr_skip_char_limited
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:155"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_6
#AT_START_7
at_fn_group_banner 7 'utils.at:173' \
  "sr_parse_char_limited" "                          " 1
at_xfail=no
(
  $as_echo "7. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_parse_char_limited.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "abc";
  char result;

  /* First char in allowed is used. */
  assert(sr_parse_char_limited(&input, "ab", &result));
  assert(*input == 'b' && result == 'a');

  /* No char in allowed is used. */
  assert(!sr_parse_char_limited(&input, "cd", &result));
  assert(*input == 'b' && result == 'a');

  /* Second char in allowed is used. */
  assert(sr_parse_char_limited(&input, "ab", &result));
  assert(*input == 'c' && result == 'b');

  /* Empty set of allowed chars. */
  assert(!sr_parse_char_limited(&input, "", &result));
  assert(*input == 'c' && result == 'b');

  /* Char is multiple times in allowed. */
  assert(sr_parse_char_limited(&input, "cdc", &result));
  assert(*input == '\0' && result == 'c');

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:173: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_parse_char_limited sr_parse_char_limited.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_char_limited sr_parse_char_limited.c $LIBS" "utils.at:173"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_char_limited sr_parse_char_limited.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:173: ./sr_parse_char_limited"
at_fn_check_prepare_trace "utils.at:173"
( $at_check_trace; ./sr_parse_char_limited
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_7
#AT_START_8
at_fn_group_banner 8 'utils.at:210' \
  "sr_skip_char_sequence" "                          " 1
at_xfail=no
(
  $as_echo "8. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_skip_char_sequence.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "aaaaabc";
  assert(5 == sr_skip_char_sequence(&input, 'a'));
  assert(1 == sr_skip_char_sequence(&input, 'b'));
  assert(0 == sr_skip_char_sequence(&input, 'b'));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:210: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_skip_char_sequence sr_skip_char_sequence.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_char_sequence sr_skip_char_sequence.c $LIBS" "utils.at:210"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_char_sequence sr_skip_char_sequence.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:210"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:210: ./sr_skip_char_sequence"
at_fn_check_prepare_trace "utils.at:210"
( $at_check_trace; ./sr_skip_char_sequence
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:210"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_8
#AT_START_9
at_fn_group_banner 9 'utils.at:228' \
  "sr_skip_char_span" "                              " 1
at_xfail=no
(
  $as_echo "9. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_skip_char_span.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "aabaabc";
  assert(6 == sr_skip_char_span(&input, "ba"));
  assert(0 == sr_skip_char_span(&input, "b"));
  assert(1 == sr_skip_char_span(&input, "bc"));

  /* Test that it can parse empty string. */
  assert(0 == sr_skip_char_span(&input, "abc"));

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:228: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_skip_char_span sr_skip_char_span.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_char_span sr_skip_char_span.c $LIBS" "utils.at:228"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_char_span sr_skip_char_span.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:228: ./sr_skip_char_span"
at_fn_check_prepare_trace "utils.at:228"
( $at_check_trace; ./sr_skip_char_span
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:228"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_9
#AT_START_10
at_fn_group_banner 10 'utils.at:250' \
  "sr_skip_char_span_location" "                     " 1
at_xfail=no
(
  $as_echo "10. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_skip_char_span_location.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "aab\naabc";
  int line, column;

  assert(7 == sr_skip_char_span_location(&input, "ba\n", &line, &column));
  assert(2 == line);
  assert(3 == column);

  assert(0 == sr_skip_char_span_location(&input, "b", &line, &column));
  assert(1 == line);
  assert(0 == column);

  assert(1 == sr_skip_char_span_location(&input, "bc", &line, &column));
  assert(1 == line);
  assert(1 == column);

  /* Test that it can parse empty string. */
  assert(0 == sr_skip_char_span_location(&input, "abc", &line, &column));
  assert(1 == line);
  assert(0 == column);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:250: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_skip_char_span_location sr_skip_char_span_location.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_char_span_location sr_skip_char_span_location.c $LIBS" "utils.at:250"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_char_span_location sr_skip_char_span_location.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:250"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:250: ./sr_skip_char_span_location"
at_fn_check_prepare_trace "utils.at:250"
( $at_check_trace; ./sr_skip_char_span_location
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:250"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_10
#AT_START_11
at_fn_group_banner 11 'utils.at:284' \
  "sr_parse_char_span" "                             " 1
at_xfail=no
(
  $as_echo "11. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_parse_char_span.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "abcd";
  char *result;
  assert(2 == sr_parse_char_span(&input, "ba", &result));
  assert(*input == 'c' && strcmp(result, "ab") == 0);
  assert(0 == sr_parse_char_span(&input, "ba", &result));
  assert(*input == 'c' && strcmp(result, "ab") == 0);
  free(result);
  assert(2 == sr_parse_char_span(&input, "ecfd", &result));
  assert(*input == '\0' && strcmp(result, "cd") == 0);
  free(result);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:284: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_parse_char_span sr_parse_char_span.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_char_span sr_parse_char_span.c $LIBS" "utils.at:284"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_char_span sr_parse_char_span.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:284"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:284: ./sr_parse_char_span"
at_fn_check_prepare_trace "utils.at:284"
( $at_check_trace; ./sr_parse_char_span
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:284"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_11
#AT_START_12
at_fn_group_banner 12 'utils.at:308' \
  "sr_parse_char_cspan" "                            " 1
at_xfail=no
(
  $as_echo "12. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_parse_char_cspan.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "abcd";
  char *result;
  assert(sr_parse_char_cspan(&input, "c", &result));
  assert(*input == 'c' && strcmp(result, "ab") == 0);
  assert(!sr_parse_char_cspan(&input, "c", &result));
  assert(*input == 'c' && strcmp(result, "ab") == 0);
  free(result);
  assert(sr_parse_char_cspan(&input, "e", &result));
  assert(*input == '\0' && strcmp(result, "cd") == 0);
  free(result);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:308: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_parse_char_cspan sr_parse_char_cspan.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_char_cspan sr_parse_char_cspan.c $LIBS" "utils.at:308"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_char_cspan sr_parse_char_cspan.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:308"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:308: ./sr_parse_char_cspan"
at_fn_check_prepare_trace "utils.at:308"
( $at_check_trace; ./sr_parse_char_cspan
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:308"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_12
#AT_START_13
at_fn_group_banner 13 'utils.at:332' \
  "sr_skip_string" "                                 " 1
at_xfail=no
(
  $as_echo "13. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_skip_string.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "abcd";
  assert(2 == sr_skip_string(&input, "ab"));
  assert(*input == 'c');
  assert(0 == sr_skip_string(&input, "cde"));
  assert(2 == sr_skip_string(&input, "cd"));
  assert(0 == sr_skip_string(&input, "cd"));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:332: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_skip_string sr_skip_string.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_string sr_skip_string.c $LIBS" "utils.at:332"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_string sr_skip_string.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:332"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:332: ./sr_skip_string"
at_fn_check_prepare_trace "utils.at:332"
( $at_check_trace; ./sr_skip_string
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:332"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_13
#AT_START_14
at_fn_group_banner 14 'utils.at:352' \
  "sr_parse_string" "                                " 1
at_xfail=no
(
  $as_echo "14. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_parse_string.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "abcd";
  char *result;
  assert(sr_parse_string(&input, "ab", &result));
  assert(0 == strcmp(result, "ab"));
  assert(*input == 'c');
  free(result);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:352: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_parse_string sr_parse_string.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_string sr_parse_string.c $LIBS" "utils.at:352"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_string sr_parse_string.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:352"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:352: ./sr_parse_string"
at_fn_check_prepare_trace "utils.at:352"
( $at_check_trace; ./sr_parse_string
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:352"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_14
#AT_START_15
at_fn_group_banner 15 'utils.at:372' \
  "sr_skip_uint" "                                   " 1
at_xfail=no
(
  $as_echo "15. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_skip_uint.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "10";
  assert(2 == sr_skip_uint(&input));
  assert(*input == '\0');
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:372: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_skip_uint sr_skip_uint.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_uint sr_skip_uint.c $LIBS" "utils.at:372"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_uint sr_skip_uint.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:372"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:372: ./sr_skip_uint"
at_fn_check_prepare_trace "utils.at:372"
( $at_check_trace; ./sr_skip_uint
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:372"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_15
#AT_START_16
at_fn_group_banner 16 'utils.at:389' \
  "sr_parse_uint32" "                                " 1
at_xfail=no
(
  $as_echo "16. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_parse_uint32.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
#include <stdint.h>
int main(void)
{
  char *input = "10";
  uint32_t result;
  assert(2 == sr_parse_uint32(&input, &result));
  assert('\0' == *input);
  assert(10 == result);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:389: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_parse_uint32 sr_parse_uint32.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_uint32 sr_parse_uint32.c $LIBS" "utils.at:389"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_uint32 sr_parse_uint32.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:389"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:389: ./sr_parse_uint32"
at_fn_check_prepare_trace "utils.at:389"
( $at_check_trace; ./sr_parse_uint32
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:389"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_16
#AT_START_17
at_fn_group_banner 17 'utils.at:409' \
  "sr_skip_hexadecimal_0xuint" "                     " 1
at_xfail=no
(
  $as_echo "17. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_skip_hexadecimal_0xuint.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
int main(void)
{
  char *input = "0xffddffddff";
  assert(12 == sr_skip_hexadecimal_0xuint(&input));
  assert(*input == '\0');
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:409: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_skip_hexadecimal_0xuint sr_skip_hexadecimal_0xuint.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_hexadecimal_0xuint sr_skip_hexadecimal_0xuint.c $LIBS" "utils.at:409"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_skip_hexadecimal_0xuint sr_skip_hexadecimal_0xuint.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:409"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:409: ./sr_skip_hexadecimal_0xuint"
at_fn_check_prepare_trace "utils.at:409"
( $at_check_trace; ./sr_skip_hexadecimal_0xuint
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:409"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_17
#AT_START_18
at_fn_group_banner 18 'utils.at:426' \
  "sr_parse_hexadecimal_0xuint64" "                  " 1
at_xfail=no
(
  $as_echo "18. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_parse_hexadecimal_0xuint64.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
#include <stdint.h>
int main(void)
{
  char *input = "0x0fafaffff 0x2badf00dbaadf00d";
  uint64_t num;
  assert(11 == sr_parse_hexadecimal_0xuint64(&input, &num));
  assert(*input == ' ');
  assert(num == 0xfafaffff);
  *input++;
  assert(18 == sr_parse_hexadecimal_0xuint64(&input, &num));
  assert(*input == '\0');
  assert(num == 0x2badf00dbaadf00d);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:426: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_parse_hexadecimal_0xuint64 sr_parse_hexadecimal_0xuint64.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_hexadecimal_0xuint64 sr_parse_hexadecimal_0xuint64.c $LIBS" "utils.at:426"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_parse_hexadecimal_0xuint64 sr_parse_hexadecimal_0xuint64.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:426"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:426: ./sr_parse_hexadecimal_0xuint64"
at_fn_check_prepare_trace "utils.at:426"
( $at_check_trace; ./sr_parse_hexadecimal_0xuint64
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:426"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_18
#AT_START_19
at_fn_group_banner 19 'utils.at:450' \
  "sr_indent" "                                      " 1
at_xfail=no
(
  $as_echo "19. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_indent.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
#include <stdint.h>
int main(void)
{
  assert(0 == strcmp(sr_indent("text", 2), "  text"));
  assert(0 == strcmp(sr_indent("text\n", 2), "  text\n"));
  assert(0 == strcmp(sr_indent("text\n\n", 2), "  text\n  \n"));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:450: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_indent sr_indent.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_indent sr_indent.c $LIBS" "utils.at:450"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_indent sr_indent.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:450"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:450: ./sr_indent"
at_fn_check_prepare_trace "utils.at:450"
( $at_check_trace; ./sr_indent
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:450"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_19
#AT_START_20
at_fn_group_banner 20 'utils.at:468' \
  "sr_struniq" "                                     " 1
at_xfail=no
(
  $as_echo "20. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_struniq.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
void do_check(char **in, size_t inlen, char **out, size_t outlen)
{
  printf("%d %d\n", inlen, outlen);
  sr_struniq(in, &inlen);
  assert(inlen == outlen);

  int i;
  for (i = 0; i < outlen; i++)
  {
    assert(0 == strcmp(in[i], out[i]));
  }
}
#define check(x,y) do_check(x, sizeof(x)/sizeof(x[0]), y, sizeof(y)/sizeof(y[0]))

int main(void)
{
  size_t size = 0;
  sr_struniq(NULL, &size);
  assert(size == 0);

  char *a1[] = {"a"}, *b1[] = {"a"};
  check(a1, b1);

  char *a2[] = {"a", "a"}, *b2[] = {"a"};
  check(a2, b2);

  char *a3[] = {"a", "b"}, *b3[] = {"a", "b"};
  check(a3, b3);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:468: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_struniq sr_struniq.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_struniq sr_struniq.c $LIBS" "utils.at:468"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_struniq sr_struniq.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:468"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:468: ./sr_struniq"
at_fn_check_prepare_trace "utils.at:468"
( $at_check_trace; ./sr_struniq
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:468"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_20
#AT_START_21
at_fn_group_banner 21 'utils.at:509' \
  "sr_sha1_hash" "                                   " 1
at_xfail=no
(
  $as_echo "21. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_sha1_hash.c <<'_ATEOF'

#include "sha1.h"
#include "utils.h"
#include <assert.h>
#include <string.h>

char *in[] = {
  "",
  "foo",
  "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz" /* no comma = concat */
  "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ",
  "Thread\n"
  "   mail_shell_view_execute_search\n"
  "   gtk_combo_box_set_active_internal\n"
  "   gtk_combo_box_set_active_iter\n"
};

char *out[] = {
  "da39a3ee5e6b4b0d3255bfef95601890afd80709",
  "0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33",
  "d5d08faa5a1d41faecae99f6a3052458a17e5091",
  "4bf106d7a9cfc2c40200a8c778882c4ea28c11e5"
};

char result_bytes[SR_SHA1_RESULT_BIN_LEN];
char result[SR_SHA1_RESULT_LEN];
struct sr_sha1_state sha1ctx;
int i;

int main(void)
{
  for (i = 0; i < sizeof(in)/sizeof(in[0]); i++)
  {
    sr_sha1_begin(&sha1ctx);
    sr_sha1_hash(&sha1ctx, in[i], strlen(in[i]));
    sr_sha1_end(&sha1ctx, result_bytes);
    sr_bin2hex(result, result_bytes, SR_SHA1_RESULT_BIN_LEN)[0] = '\0';

    assert(0 == strcmp(result, out[i]));
  }

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:509: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_sha1_hash sr_sha1_hash.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_sha1_hash sr_sha1_hash.c $LIBS" "utils.at:509"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_sha1_hash sr_sha1_hash.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:509"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:509: ./sr_sha1_hash"
at_fn_check_prepare_trace "utils.at:509"
( $at_check_trace; ./sr_sha1_hash
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:509"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_21
#AT_START_22
at_fn_group_banner 22 'utils.at:559' \
  "sr_demangle_symbol" "                             " 1
at_xfail=no
(
  $as_echo "22. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_demangle_symbol.c <<'_ATEOF'

#include "utils.h"
#include <assert.h>
#include <string.h>
#include <stdio.h>

int main(void)
{
    sr_debug_parser = true;

    char *result = sr_demangle_symbol("_ZN3Job8WaitDoneEv");
    assert(0 == strcmp(result, "Job::WaitDone()"));

    result = sr_demangle_symbol("not_mangled");
    assert(result == 0);

    result = sr_demangle_symbol("f");
    assert(result == 0);

    return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/utils.at:559: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_demangle_symbol sr_demangle_symbol.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_demangle_symbol sr_demangle_symbol.c $LIBS" "utils.at:559"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_demangle_symbol sr_demangle_symbol.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:559"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/utils.at:559: ./sr_demangle_symbol"
at_fn_check_prepare_trace "utils.at:559"
( $at_check_trace; ./sr_demangle_symbol
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/utils.at:559"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_22
#AT_START_23
at_fn_group_banner 23 'strbuf.at:8' \
  "sr_strbuf_append_char" "                          " 2
at_xfail=no
(
  $as_echo "23. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_strbuf_append_char.c <<'_ATEOF'

#include "strbuf.h"
#include <assert.h>

int
main(void)
{
  int i;
  struct sr_strbuf *strbuf = sr_strbuf_new();
  for (i = 0; i < 100; ++i)
  {
    assert(strbuf->len == i);
    assert(strbuf->alloc > strbuf->len);
    assert(strbuf->buf[i] == '\0');
    sr_strbuf_append_char(strbuf, 'a');
    assert(strbuf->buf[i] == 'a');
    assert(strbuf->buf[i+1] == '\0');
    assert(strbuf->len == i + 1);
    assert(strbuf->alloc > strbuf->len);
  }
  sr_strbuf_free(strbuf);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/strbuf.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_strbuf_append_char sr_strbuf_append_char.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strbuf_append_char sr_strbuf_append_char.c $LIBS" "strbuf.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strbuf_append_char sr_strbuf_append_char.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/strbuf.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/strbuf.at:8: ./sr_strbuf_append_char"
at_fn_check_prepare_trace "strbuf.at:8"
( $at_check_trace; ./sr_strbuf_append_char
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/strbuf.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_23
#AT_START_24
at_fn_group_banner 24 'strbuf.at:37' \
  "sr_strbuf_append_str" "                           " 2
at_xfail=no
(
  $as_echo "24. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_strbuf_append_str.c <<'_ATEOF'

#include "strbuf.h"
#include <assert.h>

/* Test appending strings of certain length. 'len' must be < 50. */
static void
test(int len)
{
  int i;
  char str[50];
  for (i = 0; i < len; ++i)
    str[i] = 'a';
  str[i] = '\0';

  struct sr_strbuf *strbuf = sr_strbuf_new();
  for (i = 0; i < 100; ++i)
  {
    assert(strbuf->len == i*len);
    assert(strbuf->alloc > strbuf->len);
    assert(strbuf->buf[i*len] == '\0');
    sr_strbuf_append_str(strbuf, str);
    assert(strbuf->buf[i*len] == str[0]);
    assert(strbuf->buf[i*len+len] == '\0');
    assert(strbuf->len == i*len + len);
    assert(strbuf->alloc > strbuf->len);
  }
  sr_strbuf_free(strbuf);
}

int
main(void)
{
  int i;
  for (i = 0; i < 50; ++i)
    test(i);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/strbuf.at:37: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_strbuf_append_str sr_strbuf_append_str.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strbuf_append_str sr_strbuf_append_str.c $LIBS" "strbuf.at:37"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_strbuf_append_str sr_strbuf_append_str.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/strbuf.at:37"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/strbuf.at:37: ./sr_strbuf_append_str"
at_fn_check_prepare_trace "strbuf.at:37"
( $at_check_trace; ./sr_strbuf_append_str
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/strbuf.at:37"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_24
#AT_START_25
at_fn_group_banner 25 'gdb_frame.at:8' \
  "sr_gdb_frame_dup" "                               " 3
at_xfail=no
(
  $as_echo "25. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_frame_dup.c <<'_ATEOF'

#include "gdb/frame.h"
#include "utils.h"
#include <assert.h>

int
main(void)
{
  struct sr_gdb_frame *frame1 = sr_gdb_frame_new();;
  frame1->function_name = sr_strdup("test1");
  frame1->function_type = sr_strdup("type1");
  frame1->number = 10;
  frame1->source_file = sr_strdup("file1");
  frame1->source_line = 11;
  frame1->address = 12;

  struct sr_gdb_frame *frame0 = sr_gdb_frame_new();;
  frame0->function_name = sr_strdup("test0");
  frame0->function_type = sr_strdup("type0");
  frame0->number = 13;
  frame0->source_file = sr_strdup("file0");
  frame0->source_line = 14;
  frame0->address = 15;
  frame0->next = frame1;

  /* Test the duplication without siblings. */
  struct sr_gdb_frame *frame = sr_gdb_frame_dup(frame0, false);
  assert(NULL == frame->next);
  assert(frame->function_name != frame0->function_name);
  assert(frame->function_type != frame0->function_type);
  assert(frame->source_file != frame0->source_file);
  assert(0 == sr_gdb_frame_cmp(frame, frame0, true));
  sr_gdb_frame_free(frame);

  /* Test the duplication with the siblings. */
  frame = sr_gdb_frame_dup(frame0, true);
  assert(frame->function_name != frame0->function_name);
  assert(frame->function_type != frame0->function_type);
  assert(frame->source_file != frame0->source_file);
  assert(0 == sr_gdb_frame_cmp(frame, frame0, true));
  assert(frame->next != frame1);
  assert(0 == sr_gdb_frame_cmp(frame->next, frame1, true));
  sr_gdb_frame_free(frame->next);
  sr_gdb_frame_free(frame);

  sr_gdb_frame_free(frame1);
  sr_gdb_frame_free(frame0);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_frame_dup sr_gdb_frame_dup.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_dup sr_gdb_frame_dup.c $LIBS" "gdb_frame.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_dup sr_gdb_frame_dup.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:8: ./sr_gdb_frame_dup"
at_fn_check_prepare_trace "gdb_frame.at:8"
( $at_check_trace; ./sr_gdb_frame_dup
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_25
#AT_START_26
at_fn_group_banner 26 'gdb_frame.at:63' \
  "sr_gdb_frame_parse_frame_start" "                 " 3
at_xfail=no
(
  $as_echo "26. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_frame_parse_frame_start.c <<'_ATEOF'

#include "gdb/frame.h"
#include <assert.h>

/**
 * @param input
 * The input text stream.
 * @param parsed_char_count
 * The expected number of characters parsed (taken) from input.
 * @param expected_frame_number
 * The expected parsed frame number.
 */
static void
check(char *input,
      int parsed_char_count,
      unsigned expected_frame_number)
{
  int number;
  char *old_input = input;
  assert(parsed_char_count == sr_gdb_frame_parse_frame_start(&input, &number));
  if (0 < parsed_char_count)
  {
    assert(number == expected_frame_number);
    assert(*input == '\0');
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int
main(void)
{
  check("#10 "    , 4, 10);
  check("#0  "    , 4, 0);
  check("#99999  ", 8, 99999);
  check("ab "     , 0, 0);
  check("#ab "    , 0, 0);
  check("#-9999 " , 0, 9999);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:63: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_frame_parse_frame_start sr_gdb_frame_parse_frame_start.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_frame_start sr_gdb_frame_parse_frame_start.c $LIBS" "gdb_frame.at:63"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_frame_start sr_gdb_frame_parse_frame_start.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:63"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:63: ./sr_gdb_frame_parse_frame_start"
at_fn_check_prepare_trace "gdb_frame.at:63"
( $at_check_trace; ./sr_gdb_frame_parse_frame_start
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:63"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_26
#AT_START_27
at_fn_group_banner 27 'gdb_frame.at:112' \
  "sr_gdb_frame_parseadd_operator" "                 " 3
at_xfail=no
(
  $as_echo "27. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_frame_parseadd_operator.c <<'_ATEOF'

#include "gdb/frame.h"
#include "strbuf.h"
#include <assert.h>
#include <string.h>

static void
check(char *input, int parsed_length)
{
  printf("Testing '%s' -> %d\n", input, parsed_length);
  char *old_input = input;
  struct sr_strbuf *strbuf = sr_strbuf_new();
  assert(parsed_length == sr_gdb_frame_parseadd_operator(&input, strbuf));
  printf("  input = '%s', old_input = '%s'\n", input, old_input);

  /* Check that the input pointer was updated properly. */
  assert(*input == old_input[parsed_length]);

  /* Check that the strbuf has been modified accordingly to what was parsed. */
  assert(0 == strncmp(strbuf->buf, old_input, parsed_length));
  assert(strbuf->len == parsed_length);

  sr_strbuf_free(strbuf);
}

int
main(void)
{
  check("operator>", strlen("operator>"));
  check("operator->", strlen("operator->"));
  check("operator new", strlen("operator new"));
  check("operator new[]", strlen("operator new[]"));
  check("operator delete", strlen("operator delete"));
  check("operator del", 0);
  check("operator delete[] (test)", strlen("operator delete[]"));
  /* Red Hat Bugzilla bug #542445 */
  check("cairo_add_operator (test)", 0);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:112: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_frame_parseadd_operator sr_gdb_frame_parseadd_operator.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parseadd_operator sr_gdb_frame_parseadd_operator.c $LIBS" "gdb_frame.at:112"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parseadd_operator sr_gdb_frame_parseadd_operator.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:112"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:112: ./sr_gdb_frame_parseadd_operator"
at_fn_check_prepare_trace "gdb_frame.at:112"
( $at_check_trace; ./sr_gdb_frame_parseadd_operator
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:112"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_27
#AT_START_28
at_fn_group_banner 28 'gdb_frame.at:157' \
  "sr_gdb_frame_parse_function_name" "               " 3
at_xfail=no
(
  $as_echo "28. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_frame_parse_function_name.c <<'_ATEOF'

#include "gdb/frame.h"
#include "utils.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>

static void
check(bool success, char *input)
{
  /* Function name must be ended with a space. */
  char *input_with_space = sr_malloc(strlen(input) + 2);
  strcpy(input_with_space, input);
  input_with_space[strlen(input)] = ' ';
  input_with_space[strlen(input) + 1] = '\0';

  char *function_name = NULL, *function_type = NULL;
  char *old_input_with_space = input_with_space;
  printf("Parsing '%s'\n", input);
  struct sr_location location;
  sr_location_init(&location);
  assert(success == sr_gdb_frame_parse_function_name(&input_with_space,
                                                     &function_name,
                                                     &function_type,
                                                     &location));

  if (success)
  {
    assert(function_name);
    printf("Function name '%s'\n", function_name);
    assert(strcmp(function_name, input) == 0);
    assert(function_type == NULL);
    free(function_name);
    assert(*input_with_space == ' ');
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input_with_space == input_with_space);
  }

  free(old_input_with_space);
}

int
main(void)
{
  check(true, "??");
  check(true, "IA__g_bookmark_file_to_file");
  check(true, "pthread_cond_timedwait@@GLIBC_2.3.2");
  check(true, "_pixman_walk_composite_region");
  check(true, "CairoOutputDev::tilingPatternFill");
  check(true, "sdr::(anonymous namespace)::ViewContact::~ViewContact");
  check(true, "operator==<nsIAtom, nsICSSPseudoClass>");
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:157: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_frame_parse_function_name sr_gdb_frame_parse_function_name.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_function_name sr_gdb_frame_parse_function_name.c $LIBS" "gdb_frame.at:157"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_function_name sr_gdb_frame_parse_function_name.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:157"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:157: ./sr_gdb_frame_parse_function_name"
at_fn_check_prepare_trace "gdb_frame.at:157"
( $at_check_trace; ./sr_gdb_frame_parse_function_name
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:157"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_28
#AT_START_29
at_fn_group_banner 29 'gdb_frame.at:221' \
  "sr_gdb_frame_skip_function_args" "                " 3
at_xfail=no
(
  $as_echo "29. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_frame_skip_function_args.c <<'_ATEOF'

#include "gdb/frame.h"
#include "location.h"
#include <assert.h>

static void
check(bool success, char *input)
{
  char *old_input = input;
  struct sr_location location;
  sr_location_init(&location);
  assert(success == sr_gdb_frame_skip_function_args(&input, &location));
  if (success)
  {
    assert(*input == '\0');
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int
main(void)
{
  /* minimal */
  check(true, "()");
  /* newline */
  check(true, "(\n"
              "page=0x7f186003e280, \n"
              "cairo=0x7f18600efd10, printing=0)");
  /* value optimized out */
  check(true, "(this=0x7f1860023400, DPI=<value optimized out>)");
  /* string */
  check(true, "(filename=0x18971b0 \"/home/jfclere/.recently-used.xbel\")");
  /* problematic frame #33 from rhbz#803600 */
  check(true, "(func=<function at remote 0x1b3aa28>, arg=(<vmmAsyncJob(show_progress=False, topwin=<gtk.Window at remote 0x1b43690>, cancel_args=[<...>], _gobject_handles=[], _signal_id_map={}, cancel_job=None, window=<gtk.glade.XML at remote 0x1b43aa0>, _gobject_timeouts=[], config=<vmmConfig(rhel6_defaults=False, support_threading=True, glade_dir='/usr/share/virt-manager', _spice_error=None, conf_dir='/apps/virt-manager', appname='virt-manager', libvirt_packages=['libvirt'], support_inspection=False, keyring=None, appversion='0.9.0', preferred_distros=['rhel', 'fedora'], hv_packages=['qemu-kvm'], conf=<gconf.Client at remote 0x17ea9b0>, _objects=['<vmmErrorDialog object at 0x1885460 (virtManager+error+vmmErrorDialog at 0xfe9080)>', '<vmmEngine object at 0x1acaaf0 (virtManager+engine+vmmEngine at 0xfe8920)>', '<vmmErrorDialog object at 0x1acacd0 (virtManager+error+vmmErrorDialog at 0xfe2000)>', '<vmmSystray object at 0x1acad20 (virtManager+systray+vmmSystray at 0xfe8e60)>', '<vmmErrorDialog object at 0x1acad70 (virtManager+error+vmmErrorDialog at 0xd9b120)>', '<vm...(truncated), kw={})");
  /* TODO: parentesis balance */
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:221: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_frame_skip_function_args sr_gdb_frame_skip_function_args.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_skip_function_args sr_gdb_frame_skip_function_args.c $LIBS" "gdb_frame.at:221"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_skip_function_args sr_gdb_frame_skip_function_args.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:221"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:221: ./sr_gdb_frame_skip_function_args"
at_fn_check_prepare_trace "gdb_frame.at:221"
( $at_check_trace; ./sr_gdb_frame_skip_function_args
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:221"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_29
#AT_START_30
at_fn_group_banner 30 'gdb_frame.at:268' \
  "sr_gdb_frame_parse_function_call" "               " 3
at_xfail=no
(
  $as_echo "30. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_frame_parse_function_call.c <<'_ATEOF'

#include "gdb/frame.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>

static void
check(bool success,
      char *input,
      char *expected_function_name,
      char *expected_function_type)
{
  char *old_input = input;
  char *function_name, *function_type;
  struct sr_location location;
  sr_location_init(&location);
  assert(success == sr_gdb_frame_parse_function_call(&input,
                                                  &function_name,
                                                  &function_type,
                                                  &location));
  if (success)
  {
    printf("Expected: '%s', got '%s'\n", expected_function_name, function_name);
    assert(0 == strcmp(expected_function_name, function_name));
    assert((!expected_function_type && !function_type) ||
           0 == strcmp(expected_function_type, function_type));
    assert(*input == '\0');
    free(function_name);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int
main(void)
{
  /* minimal */
  check(true, "?? ()", "??", NULL);
  check(true, "fsync ()", "fsync", NULL);
  /* newlines */
  check(true,
    "write_to_temp_file (\n"
      "filename=0x18971b0 \"/home/jfclere/.recently-used.xbel\", \n"
      "contents=<value optimized out>, length=29917, error=0x7fff3cbe4110)",
    "write_to_temp_file",
    NULL);
  /* C++ */
  check(true,
        "osgText::Font::GlyphTexture::apply(osg::State&) const ()",
        "osgText::Font::GlyphTexture::apply(osg::State&) const",
        NULL);
  check(true,
        "osgUtil::RenderStage::drawInner(osg::RenderInfo&, osgUtil::RenderLeaf*&, bool&) ()",
        "osgUtil::RenderStage::drawInner(osg::RenderInfo&, osgUtil::RenderLeaf*&, bool&)",
        NULL);
  check(true,
        "nsRegion::RgnRect::operator new ()",
        "nsRegion::RgnRect::operator new",
        NULL);
  check(true,
        "sigc::internal::slot_call0<sigc::bound_mem_functor0<void, Driver>, void>::call_it (this=0x6c)",
        "sigc::internal::slot_call0<sigc::bound_mem_functor0<void, Driver>, void>::call_it",
        NULL);
  check(true,
        "sigc::internal::slot_call0<sigc::bound_mem_functor0<void, GameWindow>, void>::call_it(sigc::internal::slot_rep*) ()",
        "sigc::internal::slot_call0<sigc::bound_mem_functor0<void, GameWindow>, void>::call_it(sigc::internal::slot_rep*)",
        NULL);
  /* C++ operator< and templates */
  check(true,
        "operator< <char, std::char_traits<char>, std::allocator<char> > (__s1=<value optimized out>)",
        "operator< <char, std::char_traits<char>, std::allocator<char> >",
        NULL);
  /* C++ plain operator-> */
  check(true, "operator-> ()", "operator->", NULL);
  /* Not an operator, but includes the keyword 'operator' (Red Hat Bugzilla bug #542445) */
  check(true,
        "cairo_set_operator (cr=0x0, op=CAIRO_OPERATOR_OVER)",
        "cairo_set_operator",
        NULL);
  /* type included */
  #define TYPE "void"
  #define FUNCTION "boost::throw_exception<"                          \
                   "boost::filesystem::basic_filesystem_error<"       \
                   "boost::filesystem::basic_path<"                   \
                   "std::basic_string<"                               \
                   "char, std::char_traits<char>, "                   \
                   "std::allocator<char> >, "                         \
                   "boost::filesystem::path_traits> > >"              \
                   "(boost::filesystem::basic_filesystem_error<"      \
                   "boost::filesystem::basic_path<"                   \
                   "std::basic_string<char, std::char_traits<char>, " \
                   "std::allocator<char> >, "                         \
                   "boost::filesystem::path_traits> > const&)"
  #define ARGS "()"
  #define FUNCALL TYPE " " FUNCTION " " ARGS
  check(true, FUNCALL, FUNCTION, TYPE);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:268: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_frame_parse_function_call sr_gdb_frame_parse_function_call.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_function_call sr_gdb_frame_parse_function_call.c $LIBS" "gdb_frame.at:268"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_function_call sr_gdb_frame_parse_function_call.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:268"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:268: ./sr_gdb_frame_parse_function_call"
at_fn_check_prepare_trace "gdb_frame.at:268"
( $at_check_trace; ./sr_gdb_frame_parse_function_call
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:268"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_30
#AT_START_31
at_fn_group_banner 31 'gdb_frame.at:375' \
  "sr_gdb_frame_parse_address_in_function" "         " 3
at_xfail=no
(
  $as_echo "31. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_frame_parse_address_in_function.c <<'_ATEOF'

#include "gdb/frame.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>

static void
check(bool success,
      char *input,
      uint64_t expected_address,
      char *expected_function)
{
  char *old_input = input;
  char *function;
  char *type;
  uint64_t address;
  struct sr_location location;
  sr_location_init(&location);
  assert(success == sr_gdb_frame_parse_address_in_function(&input,
                                                           &address,
                                                           &function,
                                                           &type,
                                                           &location));
  if (success)
  {
    assert(strcmp(function, expected_function) == 0);
    assert(address == expected_address);
    assert(*input == '\0');
    free(function);
    free(type);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int
main(void)
{
  /* minimal */
  check(true, "raise (sig=6)", -1, "raise");
  /* still simple */
  check(true, "0x00ad0a91 in raise (sig=6)", 0xad0a91, "raise");
  /* longnum */
  check(true, "0xf00000322221730e in IA__g_bookmark_file_to_file (\n"
    "filename=0x18971b0 \"/home/jfclere/.recently-used.xbel\", \n"
    "error=0x7fff3cbe4160)", 0xf00000322221730eULL,
    "IA__g_bookmark_file_to_file");
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:375: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_frame_parse_address_in_function sr_gdb_frame_parse_address_in_function.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_address_in_function sr_gdb_frame_parse_address_in_function.c $LIBS" "gdb_frame.at:375"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_address_in_function sr_gdb_frame_parse_address_in_function.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:375"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:375: ./sr_gdb_frame_parse_address_in_function"
at_fn_check_prepare_trace "gdb_frame.at:375"
( $at_check_trace; ./sr_gdb_frame_parse_address_in_function
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:375"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_31
#AT_START_32
at_fn_group_banner 32 'gdb_frame.at:434' \
  "sr_gdb_frame_parse_file_location" "               " 3
at_xfail=no
(
  $as_echo "32. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_frame_parse_file_location.c <<'_ATEOF'

#include "gdb/frame.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>

static void
check(bool success,
      char *input,
      char *expected_file,
      unsigned expected_line)
{
  char *old_input = input;
  char *file;
  unsigned line;
  struct sr_location location;
  sr_location_init(&location);
  assert(success == sr_gdb_frame_parse_file_location(&input,
                                                     &file,
                                                     &line,
                                                     &location));
  if (success)
  {
    assert(strcmp(file, expected_file) == 0);
    assert(line == expected_line);
    assert(*input == '\0');
    free(file);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int
main(void)
{
  /* Test with a newline and without a line number. */
  check(true, "\n at gtkrecentmanager.c", "gtkrecentmanager.c", -1);

  /* Test with a newline and with a line number.  */
  check(true, "\n at gtkrecentmanager.c:1377", "gtkrecentmanager.c", 1377);

  /* Test without a newline and a file name with a dash and an upper letter. */
  check(true,
        " at ../sysdeps/unix/syscall-template.S:82",
        "../sysdeps/unix/syscall-template.S",
        82);

  /* A file name starting with an underscore: Red Hat Bugzilla bug #530678. */
  check(true,
        " at _polkitauthenticationagent.c:885",
        "_polkitauthenticationagent.c",
        885);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:434: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_frame_parse_file_location sr_gdb_frame_parse_file_location.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_file_location sr_gdb_frame_parse_file_location.c $LIBS" "gdb_frame.at:434"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_file_location sr_gdb_frame_parse_file_location.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:434"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:434: ./sr_gdb_frame_parse_file_location"
at_fn_check_prepare_trace "gdb_frame.at:434"
( $at_check_trace; ./sr_gdb_frame_parse_file_location
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:434"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_32
#AT_START_33
at_fn_group_banner 33 'gdb_frame.at:498' \
  "sr_gdb_frame_parse_header" "                      " 3
at_xfail=no
(
  $as_echo "33. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_frame_parse_header.c <<'_ATEOF'

#include "gdb/frame.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

static void
check(char *input,
      struct sr_gdb_frame *expected_frame)
{
  printf("=================================================\n"
         "Testing %s\n",
         input);

  char *old_input = input;
  struct sr_location location;
  sr_location_init(&location);
  struct sr_gdb_frame *frame = sr_gdb_frame_parse_header(&input, &location);
  if (frame)
  {
    assert(*input == '\0');
    assert(sr_gdb_frame_cmp(frame, expected_frame, true) == 0);
    sr_gdb_frame_free(frame);
  }
  else
  {
    printf(" - parsing failed: %d:%d %s\n", location.line, location.column, location.message);

    /* Check that the pointer is not moved. */
    assert(old_input == input);
    assert(!expected_frame);
  }
}

int
main(void)
{
  /* no function address - rhbz#752811 */
  struct sr_gdb_frame frame;
  sr_gdb_frame_init(&frame);
  frame.function_name = "slot_tp_getattr_hook";
  frame.number = 0;
  frame.source_file = "/usr/src/debug/Python-2.7.1/Objects/typeobject.c";
  frame.source_line = 5436;
  frame.address = -1;
  check("#0  slot_tp_getattr_hook (self=<YumAvailableP...>) at /usr/src/debug/Python-2.7.1/Objects/typeobject.c:5436", &frame);

  /* basic */
  sr_gdb_frame_init(&frame);
  frame.function_name = "fsync";
  frame.number = 1;
  frame.source_file = "../sysdeps/unix/syscall-template.S";
  frame.source_line = 82;
  frame.address = 0x322160e7fdULL;
  check("#1  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82", &frame);

  /* C++ */
  sr_gdb_frame_init(&frame);
  frame.function_name = "nsRegion::RgnRect::operator new";
  frame.number = 4;
  frame.source_file = "nsRegion.cpp";
  frame.source_line = 214;
  frame.address = 0x3f96d71056ULL;
  check("#4  0x0000003f96d71056 in nsRegion::RgnRect::operator new ()\n"
        "    at nsRegion.cpp:214", &frame);

  /* Templates and no filename. */
  sr_gdb_frame_init(&frame);
  frame.function_name = "sigc::internal::slot_call0<sigc::bound_mem_functor0<void, GameWindow>, void>::call_it(sigc::internal::slot_rep*)";
  frame.number = 15;
  frame.address = 0x08201bdfULL;
  check("#15 0x08201bdf in sigc::internal::slot_call0<sigc::bound_mem_functor0<void, GameWindow>,"
        " void>::call_it(sigc::internal::slot_rep*) ()", &frame);

  /* No address, just the function call. Red Hat Bugzilla bug #530678 */
  sr_gdb_frame_init(&frame);
  frame.function_name = "handle_message";
  frame.number = 30;
  frame.source_file = "_polkitauthenticationagent.c";
  frame.source_line = 885;
  check("#30 handle_message (message=<value optimized out>,\n"
        "interface=<value optimized out>) at _polkitauthenticationagent.c:885", &frame);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:498: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_frame_parse_header sr_gdb_frame_parse_header.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_header sr_gdb_frame_parse_header.c $LIBS" "gdb_frame.at:498"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse_header sr_gdb_frame_parse_header.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:498"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:498: ./sr_gdb_frame_parse_header"
at_fn_check_prepare_trace "gdb_frame.at:498"
( $at_check_trace; ./sr_gdb_frame_parse_header
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:498"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_33
#AT_START_34
at_fn_group_banner 34 'gdb_frame.at:591' \
  "sr_gdb_frame_parse" "                             " 3
at_xfail=no
(
  $as_echo "34. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_frame_parse.c <<'_ATEOF'

#include "gdb/frame.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <string.h>

static void
check(char *input,
      struct sr_gdb_frame *expected_frame,
      char *expected_input,
      struct sr_location *expected_location)
{
  char *old_input = input;
  struct sr_location location;
  sr_location_init(&location);
  struct sr_gdb_frame *frame = sr_gdb_frame_parse(&input, &location);
  assert(input == expected_input);
  if (frame)
  {
    assert(0 == sr_gdb_frame_cmp(frame, expected_frame, true));
    puts(sr_location_to_string(&location));
    puts(sr_location_to_string(expected_location));
    assert(0 == sr_location_cmp(&location, expected_location, true));
    sr_gdb_frame_free(frame);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
    assert(0 == sr_location_cmp(&location, expected_location, true));
    assert(!expected_frame);
  }
}

int
main(void)
{
  /* basic */
  struct sr_gdb_frame frame;
  sr_gdb_frame_init(&frame);
  frame.function_name = "fsync";
  frame.number = 1;
  frame.source_file = "../sysdeps/unix/syscall-template.S";
  frame.source_line = 82;
  frame.address = 0x322160e7fdULL;
  char *c = "#1  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82\n"
            "No locals.";
  struct sr_location location;
  sr_location_init(&location);
  location.line = 2;
  location.column = 10;
  check(c, &frame, c + strlen(c), &location);

  c = "#1  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82\n"
      "No locals.\n"
      "#2  0x003f4f3f in IA__g_main_loop_run (loop=0x90e2c50) at gmain.c:2799\n"
      "        self = 0x8b80038\n"
      "  __PRETTY_FUNCTION__ = \"IA__g_main_loop_run\"\n";
  location.line = 3;
  location.column = 0;
  check(c, &frame, strstr(c, "#2"), &location);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:591: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_frame_parse sr_gdb_frame_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse sr_gdb_frame_parse.c $LIBS" "gdb_frame.at:591"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_frame_parse sr_gdb_frame_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:591"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_frame.at:591: ./sr_gdb_frame_parse"
at_fn_check_prepare_trace "gdb_frame.at:591"
( $at_check_trace; ./sr_gdb_frame_parse
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_frame.at:591"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_34
#AT_START_35
at_fn_group_banner 35 'gdb_thread.at:8' \
  "sr_gdb_thread_remove_frame" "                     " 4
at_xfail=no
(
  $as_echo "35. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_thread_remove_frame.c <<'_ATEOF'

#include "gdb/thread.h"
#include "gdb/frame.h"
#include "location.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  struct sr_gdb_frame *frame2 = sr_gdb_frame_new();
  frame2->function_name = sr_strdup("write");
  frame2->number = 2;
  frame2->source_file = sr_strdup("gfileutils.c");
  frame2->source_line = 120;
  frame2->address = 0x322160e7fdULL;

  struct sr_gdb_frame *frame1 = sr_gdb_frame_new();
  frame1->function_name = sr_strdup("write_to_temp_file");
  frame1->number = 1;
  frame1->source_file = sr_strdup("gfileutils.c");
  frame1->source_line = 980;
  frame1->address = 0x322160e7fdULL;
  frame1->next = frame2;

  struct sr_gdb_frame *frame0 = sr_gdb_frame_new();
  frame0->function_name = sr_strdup("fsync");
  frame0->number = 0;
  frame0->source_file = sr_strdup("../sysdeps/unix/syscall-template.S");
  frame0->source_line = 82;
  frame0->address = 0x322160e7fdULL;
  frame0->next = frame1;

  struct sr_gdb_thread thread;
  sr_gdb_thread_init(&thread);
  thread.number = 3;
  thread.frames = frame0;

  /* Remove the frame from the top of the stack. */
  assert(sr_gdb_thread_remove_frame(&thread, frame0));
  assert(frame1 == thread.frames);
  assert(frame2 == thread.frames->next);

  /* Remove the frame from the bottom of the stack. */
  assert(sr_gdb_thread_remove_frame(&thread, frame2));
  assert(frame1 == thread.frames);
  assert(NULL == thread.frames->next);

  /* Remove the last remaining frame. */
  assert(sr_gdb_thread_remove_frame(&thread, frame1));
  assert(NULL == thread.frames);

  /* Remove nonexistant frame -> should return false. */
  assert(!sr_gdb_thread_remove_frame(&thread, frame0));
  assert(NULL == thread.frames);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_thread_remove_frame sr_gdb_thread_remove_frame.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_remove_frame sr_gdb_thread_remove_frame.c $LIBS" "gdb_thread.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_remove_frame sr_gdb_thread_remove_frame.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:8: ./sr_gdb_thread_remove_frame"
at_fn_check_prepare_trace "gdb_thread.at:8"
( $at_check_trace; ./sr_gdb_thread_remove_frame
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_35
#AT_START_36
at_fn_group_banner 36 'gdb_thread.at:73' \
  "sr_gdb_thread_remove_frames_above" "              " 4
at_xfail=no
(
  $as_echo "36. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_thread_remove_frames_above.c <<'_ATEOF'

#include "gdb/thread.h"
#include "gdb/frame.h"
#include "location.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  struct sr_gdb_frame *frame2 = sr_gdb_frame_new();
  frame2->function_name = sr_strdup("write");
  frame2->number = 2;
  frame2->source_file = sr_strdup("gfileutils.c");
  frame2->source_line = 120;
  frame2->address = 0x322160e7fdULL;

  struct sr_gdb_frame *frame1 = sr_gdb_frame_new();
  frame1->function_name = sr_strdup("write_to_temp_file");
  frame1->number = 1;
  frame1->source_file = sr_strdup("gfileutils.c");
  frame1->source_line = 980;
  frame1->address = 0x322160e7fdULL;
  frame1->next = frame2;

  struct sr_gdb_frame *frame0 = sr_gdb_frame_new();
  frame0->function_name = sr_strdup("fsync");
  frame0->number = 0;
  frame0->source_file = sr_strdup("../sysdeps/unix/syscall-template.S");
  frame0->source_line = 82;
  frame0->address = 0x322160e7fdULL;
  frame0->next = frame1;

  struct sr_gdb_thread thread;
  sr_gdb_thread_init(&thread);
  thread.number = 3;
  thread.frames = frame0;

  /* Remove the frames above the top of the stack. */
  assert(sr_gdb_thread_remove_frames_above(&thread, frame0));
  assert(frame0 == thread.frames);
  assert(frame1 == thread.frames->next);

  /* Remove the frames above the second frame from the top of the stack. */
  assert(sr_gdb_thread_remove_frames_above(&thread, frame1));
  assert(frame1 == thread.frames);
  assert(frame2 == thread.frames->next);

  /* Remove the frames above the bottom of the stack. */
  assert(sr_gdb_thread_remove_frames_above(&thread, frame2));
  assert(frame2 == thread.frames);
  assert(NULL == thread.frames->next);

  /* Remove frames above a nonexistant frame -> should return false. */
  assert(!sr_gdb_thread_remove_frames_above(&thread, frame0));
  assert(frame2 == thread.frames);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:73: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_thread_remove_frames_above sr_gdb_thread_remove_frames_above.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_remove_frames_above sr_gdb_thread_remove_frames_above.c $LIBS" "gdb_thread.at:73"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_remove_frames_above sr_gdb_thread_remove_frames_above.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:73"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:73: ./sr_gdb_thread_remove_frames_above"
at_fn_check_prepare_trace "gdb_thread.at:73"
( $at_check_trace; ./sr_gdb_thread_remove_frames_above
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:73"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_36
#AT_START_37
at_fn_group_banner 37 'gdb_thread.at:139' \
  "sr_gdb_thread_remove_frames_below_n" "            " 4
at_xfail=no
(
  $as_echo "37. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_thread_remove_frames_below_n.c <<'_ATEOF'

#include "gdb/thread.h"
#include "gdb/frame.h"
#include "location.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  struct sr_gdb_frame *frame2 = sr_gdb_frame_new();
  frame2->function_name = sr_strdup("write");
  frame2->number = 2;
  frame2->source_file = sr_strdup("gfileutils.c");
  frame2->source_line = 120;
  frame2->address = 0x322160e7fdULL;

  struct sr_gdb_frame *frame1 = sr_gdb_frame_new();
  frame1->function_name = sr_strdup("write_to_temp_file");
  frame1->number = 1;
  frame1->source_file = sr_strdup("gfileutils.c");
  frame1->source_line = 980;
  frame1->address = 0x322160e7fdULL;
  frame1->next = frame2;

  struct sr_gdb_frame *frame0 = sr_gdb_frame_new();
  frame0->function_name = sr_strdup("fsync");
  frame0->number = 0;
  frame0->source_file = sr_strdup("../sysdeps/unix/syscall-template.S");
  frame0->source_line = 82;
  frame0->address = 0x322160e7fdULL;
  frame0->next = frame1;

  struct sr_gdb_thread thread;
  sr_gdb_thread_init(&thread);
  thread.number = 3;
  thread.frames = frame0;

  /* Remove no frame as n is too large. */
  sr_gdb_thread_remove_frames_below_n(&thread, 5);
  assert(frame0 == thread.frames);
  assert(frame1 == thread.frames->next);
  assert(frame2 == thread.frames->next->next);
  assert(NULL == thread.frames->next->next->next);

  /* Remove the frames below 1. */
  sr_gdb_thread_remove_frames_below_n(&thread, 1);
  assert(frame0 == thread.frames);
  assert(NULL == thread.frames->next);

  /* Remove the frames below 0. */
  sr_gdb_thread_remove_frames_below_n(&thread, 0);
  assert(NULL == thread.frames);

  /* Try to remove frames when no frame is present. */
  sr_gdb_thread_remove_frames_below_n(&thread, 4);
  assert(NULL == thread.frames);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:139: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_thread_remove_frames_below_n sr_gdb_thread_remove_frames_below_n.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_remove_frames_below_n sr_gdb_thread_remove_frames_below_n.c $LIBS" "gdb_thread.at:139"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_remove_frames_below_n sr_gdb_thread_remove_frames_below_n.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:139"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:139: ./sr_gdb_thread_remove_frames_below_n"
at_fn_check_prepare_trace "gdb_thread.at:139"
( $at_check_trace; ./sr_gdb_thread_remove_frames_below_n
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:139"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_37
#AT_START_38
at_fn_group_banner 38 'gdb_thread.at:206' \
  "sr_gdb_thread_parse" "                            " 4
at_xfail=no
(
  $as_echo "38. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_thread_parse.c <<'_ATEOF'

#include "gdb/thread.h"
#include "gdb/frame.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

static void
check(char *input,
      struct sr_gdb_thread *expected_thread)
{
  printf("===============================================\n"
         "Testing input: %s",
         input);

  char *old_input = input;
  struct sr_location location;
  sr_location_init(&location);
  struct sr_gdb_thread *thread = sr_gdb_thread_parse(&input, &location);
  assert(!expected_thread || thread);
  if (thread)
  {
    assert(*input == '\0');
    assert(0 == sr_gdb_thread_cmp(thread, expected_thread));
    sr_gdb_thread_free(thread);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
    assert(!expected_thread);
  }
}

int
main(void)
{
  /* Basic test. */
  struct sr_gdb_frame frame0, frame1;
  sr_gdb_frame_init(&frame0);
  frame0.function_name = "fsync";
  frame0.number = 0;
  frame0.source_file = "../sysdeps/unix/syscall-template.S";
  frame0.source_line = 82;
  frame0.address = 0x322160e7fdULL;
  frame0.next = &frame1;

  sr_gdb_frame_init(&frame1);
  frame1.function_name = "write_to_temp_file";
  frame1.number = 1;
  frame1.source_file = "gfileutils.c";
  frame1.source_line = 980;
  frame1.address = 0x322160e7fdULL;

  struct sr_gdb_thread thread;
  sr_gdb_thread_init(&thread);
  thread.number = 3;
  thread.frames = &frame0;

  check("Thread 3 (Thread 11917):\n"
        "#0  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82\n"
        "No locals.\n"
        "#1  0x000000322222987a in write_to_temp_file (\n"
        "    filename=0x18971b0 \"/home/jfclere/.recently-used.xbel\", \n"
        "    contents=<value optimized out>, length=29917, error=0x7fff3cbe4110)\n"
        "    at gfileutils.c:980\n"
        "        statbuf = {st_dev = 64768, st_ino = 13709, st_nlink = 1, \n"
        "          st_mode = 33152, st_uid = 500, st_gid = 500, __pad0 = 0, \n"
        "          st_rdev = 0, st_size = 29917, st_blksize = 4096, st_blocks = 64, \n"
        "          st_atim = {tv_sec = 1273231242, tv_nsec = 73521863}, st_mtim = {\n"
        "            tv_sec = 1273231242, tv_nsec = 82521015}, st_ctim = {\n"
        "            tv_sec = 1273231242, tv_nsec = 190522021}, __unused = {0, 0, 0}}\n",
        &thread);

  /* Check that it also handles more exotic header. */
  check("Thread 3 (Thread 0xdd119170 (LWP 6357)):\n"
        "#0  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82\n"
        "No locals.\n"
        "#1  0x000000322222987a in write_to_temp_file () at gfileutils.c:980\n"
        "No locals.\n",
        &thread);

  /* Another format of the header. */
  check("Thread 3 (LWP 635):\n"
        "#0  0x000000322160e7fd in fsync () at ../sysdeps/unix/syscall-template.S:82\n"
        "No locals.\n"
        "#1  0x000000322222987a in write_to_temp_file () at gfileutils.c:980\n"
        "No locals.\n",
        &thread);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:206: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_thread_parse sr_gdb_thread_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_parse sr_gdb_thread_parse.c $LIBS" "gdb_thread.at:206"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_parse sr_gdb_thread_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:206"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:206: ./sr_gdb_thread_parse"
at_fn_check_prepare_trace "gdb_thread.at:206"
( $at_check_trace; ./sr_gdb_thread_parse
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:206"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_38
#AT_START_39
at_fn_group_banner 39 'gdb_thread.at:305' \
  "sr_gdb_thread_parse-locations" "                  " 4
at_xfail=no
(
  $as_echo "39. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_thread_parse-locations.c <<'_ATEOF'

#include "gdb/thread.h"
#include "gdb/frame.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>

/**
 * Checks that the thread parser fails on ceratin location
 * (line and column), with an error message.
 */
static void
check(char *input,
      int expected_line,
      int expected_column)
{
  char *old_input = input;
  struct sr_location location;
  sr_location_init(&location);
  assert(NULL == sr_gdb_thread_parse(&input, &location));

  /* Check that the pointer is not moved. */
  assert(old_input == input);

  /* Check the location. */
  printf("location %d:%d '%s', expected %d:%d\n",
         location.line, location.column, location.message,
         expected_line, expected_column);

  assert(location.line == expected_line);
  assert(location.column == expected_column);
  assert(location.message);
  assert(location.message[0] != '\0');
}

int
main(void)
{
  /* Thread keyword */
  check("Thraed 3 (Thread 11917):\n", 1, 0);

  /* Spaces after the thread keyword. */
  check("Thread3 (Thread 11917):\n", 1, 6);

  /* Thread number. */
  check("Thread  a (Thread 11917):\n", 1, 8);

  /* Spaces after the thread number. */
  check("Thread 8(Thread 11917):\n", 1, 8);

  /* A parenthesis. */
  check("Thread 8 (11917):\n", 1, 9);

  /* Second number. */
  check("Thread 8 (Thread ffff):\n", 1, 17);

  /* Semicolon missing. */
  check("Thread 8 (Thread 1)\n", 1, 18);

  /* Not a single frame. */
  check("Thread 3 (Thread 11917):\n\n", 2, 0);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:305: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_thread_parse-locations sr_gdb_thread_parse-locations.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_parse-locations sr_gdb_thread_parse-locations.c $LIBS" "gdb_thread.at:305"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_parse-locations sr_gdb_thread_parse-locations.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:305"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:305: ./sr_gdb_thread_parse-locations"
at_fn_check_prepare_trace "gdb_thread.at:305"
( $at_check_trace; ./sr_gdb_thread_parse-locations
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:305"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_39
#AT_START_40
at_fn_group_banner 40 'gdb_thread.at:375' \
  "sr_gdb_thread_skip_lwp" "                         " 4
at_xfail=no
(
  $as_echo "40. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_thread_skip_lwp.c <<'_ATEOF'

#include "gdb/thread.h"
#include <assert.h>
#include <stdlib.h>

static void
check(char *input,
      int expected_count)
{
  char *old_input = input;
  assert(expected_count == sr_gdb_thread_skip_lwp(&input));
  assert(input - old_input == expected_count);
}

int
main(void)
{
  check("(LWP 20)", 8);
  check("(LWP 20)10", 8);
  check("(LWP 245443452355454343450)", 27);
  check("(LWP 245443452355454343450)  ", 27);

  check("", 0);
  check(" ", 0);
  check(" (LWP 20)", 0);
  check("(LWP", 0);
  check("(LWP 20", 0);
  check("(LWP )", 0);
  check("(LWP 20()", 0);
  check("(LWP 0x0)", 0);
  check("(LWP 20(", 0);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:375: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_thread_skip_lwp sr_gdb_thread_skip_lwp.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_skip_lwp sr_gdb_thread_skip_lwp.c $LIBS" "gdb_thread.at:375"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_thread_skip_lwp sr_gdb_thread_skip_lwp.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:375"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_thread.at:375: ./sr_gdb_thread_skip_lwp"
at_fn_check_prepare_trace "gdb_thread.at:375"
( $at_check_trace; ./sr_gdb_thread_skip_lwp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_thread.at:375"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_40
#AT_START_41
at_fn_group_banner 41 'gdb_stacktrace.at:8' \
  "sr_gdb_stacktrace_remove_threads_except_one" "    " 5
at_xfail=no
(
  $as_echo "41. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_stacktrace_remove_threads_except_one.c <<'_ATEOF'

#include "gdb/stacktrace.h"
#include "gdb/thread.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  /* Delete the thread except the middle one. */
  struct sr_gdb_thread *thread2 = sr_gdb_thread_new();
  struct sr_gdb_thread *thread1 = sr_gdb_thread_new();
  thread1->next = thread2;
  struct sr_gdb_thread *thread0 = sr_gdb_thread_new();
  thread0->next = thread1;
  struct sr_gdb_stacktrace *stacktrace = sr_gdb_stacktrace_new();
  stacktrace->threads = thread0;
  sr_gdb_stacktrace_remove_threads_except_one(stacktrace, thread1);
  assert(stacktrace->threads == thread1);
  assert(NULL == stacktrace->threads->next);

  /* Delete all threads except one when there is only one. */
  sr_gdb_stacktrace_remove_threads_except_one(stacktrace, thread1);
  assert(stacktrace->threads == thread1);
  assert(NULL == stacktrace->threads->next);

  /* Delete all threads except the first one. */
  thread0 = sr_gdb_thread_new();
  stacktrace->threads = thread0;
  thread0->next = thread1; // already exists
  thread2 = sr_gdb_thread_new();
  thread1->next = thread2;
  sr_gdb_stacktrace_remove_threads_except_one(stacktrace, thread0);
  assert(stacktrace->threads == thread0);
  assert(NULL == stacktrace->threads->next);

  /* Delete all threads except the last one. */
  thread1 = sr_gdb_thread_new();
  thread0->next = thread1;
  thread2 = sr_gdb_thread_new();
  thread1->next = thread2;
  sr_gdb_stacktrace_remove_threads_except_one(stacktrace, thread2);
  assert(stacktrace->threads == thread2);
  assert(NULL == stacktrace->threads->next);

  sr_gdb_stacktrace_free(stacktrace);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_stacktrace_remove_threads_except_one sr_gdb_stacktrace_remove_threads_except_one.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_remove_threads_except_one sr_gdb_stacktrace_remove_threads_except_one.c $LIBS" "gdb_stacktrace.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_remove_threads_except_one sr_gdb_stacktrace_remove_threads_except_one.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:8: ./sr_gdb_stacktrace_remove_threads_except_one"
at_fn_check_prepare_trace "gdb_stacktrace.at:8"
( $at_check_trace; ./sr_gdb_stacktrace_remove_threads_except_one
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_41
#AT_START_42
at_fn_group_banner 42 'gdb_stacktrace.at:62' \
  "sr_gdb_stacktrace_find_crash_thread" "            " 5
at_xfail=no
(
  $as_echo "42. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_stacktrace_find_crash_thread.c <<'_ATEOF'

#include "stacktrace.h"
#include "gdb/stacktrace.h"
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "location.h"
#include "utils.h"
#include <assert.h>
#include <string.h>

void
check(const char *path, const char *first_thread_function_name)
{
  /* Load the stacktrace from a file. */
  struct sr_location location;
  sr_location_init(&location);
  char *error_message;
  char *full_input = sr_file_to_string(path, &error_message);
  assert(full_input);
  char *input = full_input;
  struct sr_gdb_stacktrace *stacktrace = sr_gdb_stacktrace_parse(&input, &location);
  assert(stacktrace);

  /* Check that the crash thread is found. */
  struct sr_gdb_thread *crash_thread = sr_gdb_stacktrace_find_crash_thread(stacktrace);
  assert(crash_thread);
  assert(0 == strcmp(crash_thread->frames->function_name, first_thread_function_name));

  struct sr_gdb_thread *crash_thread2 = sr_stacktrace_find_crash_thread(stacktrace);
  assert(crash_thread2);
  assert(crash_thread == crash_thread2);

  sr_gdb_stacktrace_free(stacktrace);
  free(full_input);
}

int
main(void)
{
  /* Test the stacktrace from Red Hat Bugzilla bug #621492. */
  check("../../gdb_stacktraces/rhbz-621492", "raise");
  /* Test the stacktrace from Red Hat Bugzilla bug #803600. */
  check("../../gdb_stacktraces/rhbz-803600", "validate_row");
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:62: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_stacktrace_find_crash_thread sr_gdb_stacktrace_find_crash_thread.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_find_crash_thread sr_gdb_stacktrace_find_crash_thread.c $LIBS" "gdb_stacktrace.at:62"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_find_crash_thread sr_gdb_stacktrace_find_crash_thread.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:62"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:62: ./sr_gdb_stacktrace_find_crash_thread"
at_fn_check_prepare_trace "gdb_stacktrace.at:62"
( $at_check_trace; ./sr_gdb_stacktrace_find_crash_thread
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:62"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_42
#AT_START_43
at_fn_group_banner 43 'gdb_stacktrace.at:113' \
  "sr_gdb_stacktrace_limit_frame_depth" "            " 5
at_xfail=no
(
  $as_echo "43. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_stacktrace_limit_frame_depth.c <<'_ATEOF'

#include "gdb/stacktrace.h"
#include "gdb/thread.h"
#include "location.h"
#include "utils.h"
#include "thread.h"
#include <assert.h>

int
main(void)
{
  /* Load the stacktrace from Red Hat Bugzilla bug #621492. */
  struct sr_location location;
  sr_location_init(&location);
  char *error_message;
  char *full_input = sr_file_to_string("../../gdb_stacktraces/rhbz-621492", &error_message);
  assert(full_input);
  char *input = full_input;
  struct sr_gdb_stacktrace *stacktrace = sr_gdb_stacktrace_parse(&input, &location);
  assert(stacktrace);

  /* Check the frame depth limit. */
  sr_gdb_stacktrace_limit_frame_depth(stacktrace, 5);
  assert(11 == sr_gdb_stacktrace_get_thread_count(stacktrace));
  struct sr_gdb_thread *thread = stacktrace->threads;
  while (thread)
  {
    assert(5 == sr_thread_frame_count((struct sr_thread*) thread));
    thread = thread->next;
  }

  sr_gdb_stacktrace_free(stacktrace);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:113: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_stacktrace_limit_frame_depth sr_gdb_stacktrace_limit_frame_depth.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_limit_frame_depth sr_gdb_stacktrace_limit_frame_depth.c $LIBS" "gdb_stacktrace.at:113"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_limit_frame_depth sr_gdb_stacktrace_limit_frame_depth.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:113"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:113: ./sr_gdb_stacktrace_limit_frame_depth"
at_fn_check_prepare_trace "gdb_stacktrace.at:113"
( $at_check_trace; ./sr_gdb_stacktrace_limit_frame_depth
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:113"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_43
#AT_START_44
at_fn_group_banner 44 'gdb_stacktrace.at:153' \
  "sr_gdb_stacktrace_quality_complex" "              " 5
at_xfail=no
(
  $as_echo "44. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_stacktrace_quality_complex.c <<'_ATEOF'

#include "gdb/stacktrace.h"
#include "gdb/thread.h"
#include "location.h"
#include "utils.h"
#include <assert.h>

int
main(void)
{
  /* Load the stacktrace from Red Hat Bugzilla bug #621492. */
  struct sr_location location;
  sr_location_init(&location);
  char *error_message;
  char *full_input = sr_file_to_string("../../gdb_stacktraces/rhbz-621492", &error_message);
  assert(full_input);
  char *input = full_input;
  struct sr_gdb_stacktrace *stacktrace = sr_gdb_stacktrace_parse(&input, &location);
  assert(stacktrace);
  assert(1.0f == sr_gdb_stacktrace_quality_complex(stacktrace));
  sr_gdb_stacktrace_free(stacktrace);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:153: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_stacktrace_quality_complex sr_gdb_stacktrace_quality_complex.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_quality_complex sr_gdb_stacktrace_quality_complex.c $LIBS" "gdb_stacktrace.at:153"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_quality_complex sr_gdb_stacktrace_quality_complex.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:153"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:153: ./sr_gdb_stacktrace_quality_complex"
at_fn_check_prepare_trace "gdb_stacktrace.at:153"
( $at_check_trace; ./sr_gdb_stacktrace_quality_complex
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:153"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_44
#AT_START_45
at_fn_group_banner 45 'gdb_stacktrace.at:182' \
  "sr_gdb_stacktrace_get_crash_frame" "              " 5
at_xfail=no
(
  $as_echo "45. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_stacktrace_get_crash_frame.c <<'_ATEOF'

#include "gdb/stacktrace.h"
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "location.h"
#include "utils.h"
#include <assert.h>
#include <stdio.h>

int
main(void)
{
  /* Check the crash frame of stacktrace from Red Hat Bugzilla bug #803600. */
  struct sr_location location;
  sr_location_init(&location);
  char *error_message;
  char *full_input = sr_file_to_string("../../gdb_stacktraces/rhbz-803600", &error_message);
  assert(full_input);
  char *input = full_input;
  struct sr_gdb_stacktrace *stacktrace = sr_gdb_stacktrace_parse(&input, &location);
  assert(stacktrace);
  struct sr_gdb_frame *crash_frame = sr_gdb_stacktrace_get_crash_frame(stacktrace);
  puts(crash_frame->function_name);
  assert(0 == strcmp(crash_frame->function_name, "validate_row"));
  sr_gdb_frame_free(crash_frame);
  sr_gdb_stacktrace_free(stacktrace);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:182: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_stacktrace_get_crash_frame sr_gdb_stacktrace_get_crash_frame.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_get_crash_frame sr_gdb_stacktrace_get_crash_frame.c $LIBS" "gdb_stacktrace.at:182"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_get_crash_frame sr_gdb_stacktrace_get_crash_frame.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:182"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:182: ./sr_gdb_stacktrace_get_crash_frame"
at_fn_check_prepare_trace "gdb_stacktrace.at:182"
( $at_check_trace; ./sr_gdb_stacktrace_get_crash_frame
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:182"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_45
#AT_START_46
at_fn_group_banner 46 'gdb_stacktrace.at:216' \
  "sr_gdb_stacktrace_parse_no_thread_header" "       " 5
at_xfail=no
(
  $as_echo "46. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_stacktrace_parse_no_thread_header.c <<'_ATEOF'

#include "gdb/stacktrace.h"
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "location.h"
#include "utils.h"
#include <assert.h>
#include <stdio.h>

int
main(void)
{
  /* Check that satyr is able to parse backtrace with missing Thread header */
  struct sr_location location;
  sr_location_init(&location);
  char *error_message;
  char *full_input = sr_file_to_string("../../gdb_stacktraces/no-thread-header", &error_message);
  assert(full_input);
  char *input = full_input;
  struct sr_gdb_stacktrace *stacktrace = sr_gdb_stacktrace_parse(&input, &location);
  assert(stacktrace);
  assert(1 == sr_gdb_stacktrace_get_thread_count(stacktrace));
  struct sr_gdb_thread *crash_thread = sr_gdb_stacktrace_find_crash_thread(stacktrace);
  assert(6 == sr_thread_frame_count(crash_thread));
  assert(0 == crash_thread->number);
  struct sr_gdb_frame *crash_frame = sr_gdb_stacktrace_get_crash_frame(stacktrace);
  puts(crash_frame->function_name);
  assert(0 == strcmp(crash_frame->function_name, "write"));
  sr_gdb_frame_free(crash_frame);
  sr_gdb_stacktrace_free(stacktrace);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:216: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_stacktrace_parse_no_thread_header sr_gdb_stacktrace_parse_no_thread_header.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_parse_no_thread_header sr_gdb_stacktrace_parse_no_thread_header.c $LIBS" "gdb_stacktrace.at:216"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_stacktrace_parse_no_thread_header sr_gdb_stacktrace_parse_no_thread_header.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:216"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_stacktrace.at:216: ./sr_gdb_stacktrace_parse_no_thread_header"
at_fn_check_prepare_trace "gdb_stacktrace.at:216"
( $at_check_trace; ./sr_gdb_stacktrace_parse_no_thread_header
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_stacktrace.at:216"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_46
#AT_START_47
at_fn_group_banner 47 'gdb_sharedlib.at:8' \
  "sr_gdb_sharedlib_parse" "                         " 6
at_xfail=no
(
  $as_echo "47. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_sharedlib_parse.c <<'_ATEOF'

#include "gdb/sharedlib.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  char *error_message;
  char *bt = sr_file_to_string("../../gdb_stacktraces/rhbz-621492", &error_message);
  assert(bt);
  struct sr_gdb_sharedlib *libs = sr_gdb_sharedlib_parse(bt);
  assert(libs);
  assert(libs->from == 0x0000003848c05640);
  assert(libs->to == 0x0000003848c10e48);
  assert(libs->symbols == SYMS_OK);
  assert(strcmp("/lib64/libpthread.so.0", libs->soname) == 0);
  sr_gdb_sharedlib_free(libs);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_sharedlib.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_sharedlib_parse sr_gdb_sharedlib_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_sharedlib_parse sr_gdb_sharedlib_parse.c $LIBS" "gdb_sharedlib.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_sharedlib_parse sr_gdb_sharedlib_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_sharedlib.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_sharedlib.at:8: ./sr_gdb_sharedlib_parse"
at_fn_check_prepare_trace "gdb_sharedlib.at:8"
( $at_check_trace; ./sr_gdb_sharedlib_parse
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_sharedlib.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_47
#AT_START_48
at_fn_group_banner 48 'gdb_sharedlib.at:35' \
  "sr_gdb_sharedlib_count" "                         " 6
at_xfail=no
(
  $as_echo "48. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_sharedlib_count.c <<'_ATEOF'

#include "gdb/sharedlib.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  char *error_message;
  char *bt = sr_file_to_string("../../gdb_stacktraces/rhbz-621492", &error_message);
  assert(bt);
  struct sr_gdb_sharedlib *libs = sr_gdb_sharedlib_parse(bt);
  assert(libs);
  assert(sr_gdb_sharedlib_count(libs) == 185);
  sr_gdb_sharedlib_free(libs);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_sharedlib.at:35: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_sharedlib_count sr_gdb_sharedlib_count.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_sharedlib_count sr_gdb_sharedlib_count.c $LIBS" "gdb_sharedlib.at:35"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_sharedlib_count sr_gdb_sharedlib_count.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_sharedlib.at:35"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_sharedlib.at:35: ./sr_gdb_sharedlib_count"
at_fn_check_prepare_trace "gdb_sharedlib.at:35"
( $at_check_trace; ./sr_gdb_sharedlib_count
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_sharedlib.at:35"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_48
#AT_START_49
at_fn_group_banner 49 'gdb_sharedlib.at:59' \
  "sr_gdb_sharedlib_append" "                        " 6
at_xfail=no
(
  $as_echo "49. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_sharedlib_append.c <<'_ATEOF'

#include "gdb/sharedlib.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  struct sr_gdb_sharedlib *lib1 = sr_gdb_sharedlib_new();
  assert(lib1);
  struct sr_gdb_sharedlib *lib2 = sr_gdb_sharedlib_new();
  assert(lib2);
  assert(sr_gdb_sharedlib_count(lib1) == 1);
  assert(sr_gdb_sharedlib_count(lib2) == 1);
  sr_gdb_sharedlib_append(lib1, lib2);
  assert(sr_gdb_sharedlib_count(lib1) == 2);
  assert(sr_gdb_sharedlib_count(lib2) == 1);
  sr_gdb_sharedlib_free(lib1);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_sharedlib.at:59: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_sharedlib_append sr_gdb_sharedlib_append.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_sharedlib_append sr_gdb_sharedlib_append.c $LIBS" "gdb_sharedlib.at:59"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_sharedlib_append sr_gdb_sharedlib_append.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_sharedlib.at:59"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_sharedlib.at:59: ./sr_gdb_sharedlib_append"
at_fn_check_prepare_trace "gdb_sharedlib.at:59"
( $at_check_trace; ./sr_gdb_sharedlib_append
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_sharedlib.at:59"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_49
#AT_START_50
at_fn_group_banner 50 'gdb_sharedlib.at:85' \
  "sr_gdb_sharedlib_find_address" "                  " 6
at_xfail=no
(
  $as_echo "50. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_gdb_sharedlib_find_address.c <<'_ATEOF'

#include "gdb/sharedlib.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  char *error_message;
  char *bt = sr_file_to_string("../../gdb_stacktraces/rhbz-621492", &error_message);
  assert(bt);
  struct sr_gdb_sharedlib *libs = sr_gdb_sharedlib_parse(bt);
  assert(libs);
  assert(sr_gdb_sharedlib_find_address(libs, 0x0000003848c08000));
  assert(sr_gdb_sharedlib_find_address(libs, 0x00007f907d3f0000));
  assert(!sr_gdb_sharedlib_find_address(libs, 0));
  assert(!sr_gdb_sharedlib_find_address(libs, 0xffff00000000ffff));
  sr_gdb_sharedlib_free(libs);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/gdb_sharedlib.at:85: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_gdb_sharedlib_find_address sr_gdb_sharedlib_find_address.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_sharedlib_find_address sr_gdb_sharedlib_find_address.c $LIBS" "gdb_sharedlib.at:85"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_gdb_sharedlib_find_address sr_gdb_sharedlib_find_address.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_sharedlib.at:85"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/gdb_sharedlib.at:85: ./sr_gdb_sharedlib_find_address"
at_fn_check_prepare_trace "gdb_sharedlib.at:85"
( $at_check_trace; ./sr_gdb_sharedlib_find_address
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/gdb_sharedlib.at:85"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_50
#AT_START_51
at_fn_group_banner 51 'java_frame.at:8' \
  "sr_java_frame_cmp" "                              " 7
at_xfail=no
(
  $as_echo "51. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_frame_cmp.c <<'_ATEOF'

#include "java/frame.h"
#include "utils.h"
#include <assert.h>

int
main(void)
{
  struct sr_java_frame *frame1 = sr_java_frame_new();
  frame1->name = sr_strdup("name.space.test1.ctor");
  frame1->file_name = sr_strdup("test1.java");
  frame1->file_line = 1;
  frame1->class_path = sr_strdup("/usr/share/jar1");

  struct sr_java_frame *frame0 = sr_java_frame_new();
  frame0->name = sr_strdup(frame1->name);
  frame0->file_name = sr_strdup(frame1->file_name);
  frame0->file_line = frame1->file_line;
  frame0->class_path = sr_strdup(frame1->class_path);

  assert(0 == sr_java_frame_cmp(frame0, frame1));

  frame0->file_line += 1;

  assert(0 != sr_java_frame_cmp(frame0, frame1));

  frame0->file_line -= 1;
  char *bck = frame0->name;
  frame0->name = NULL;

  assert(0 != sr_java_frame_cmp(frame0, frame1));

  frame0->name = bck;
  bck = frame0->file_name;
  frame0->file_name = NULL;

  assert(0 != sr_java_frame_cmp(frame0, frame1));

  frame0->file_name = bck;
  bck = frame0->class_path;
  frame0->class_path = NULL;

  assert(0 != sr_java_frame_cmp(frame0, frame1));

  struct sr_java_frame *exception0 = sr_java_frame_new_exception();
  exception0->name = sr_strdup("com.sun.java.NullPointer");
  exception0->message = sr_strdup("Null pointer exception");

  struct sr_java_frame *exception1 = sr_java_frame_new_exception();
  exception1->name = sr_strdup(exception0->name);
  exception1->message = sr_strdup(exception0->message);

  assert(0 == sr_java_frame_cmp(exception0, exception1));
  assert(0 != sr_java_frame_cmp(frame0, exception1));
  assert(0 != sr_java_frame_cmp(exception0, frame1));

  free(exception1->message);
  exception1->message = NULL;

  assert(0 == sr_java_frame_cmp(exception0, exception1));

  free(exception1->name);
  exception1->name = sr_strdup("com.sun.java.InvalidOperation");

  assert(0 != sr_java_frame_cmp(exception0, exception1));

  sr_java_frame_free(frame0);
  sr_java_frame_free(frame1);
  sr_java_frame_free(exception0);
  sr_java_frame_free(exception1);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_frame.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_frame_cmp sr_java_frame_cmp.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_frame_cmp sr_java_frame_cmp.c $LIBS" "java_frame.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_frame_cmp sr_java_frame_cmp.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_frame.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_frame.at:8: ./sr_java_frame_cmp"
at_fn_check_prepare_trace "java_frame.at:8"
( $at_check_trace; ./sr_java_frame_cmp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_frame.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_51
#AT_START_52
at_fn_group_banner 52 'java_frame.at:87' \
  "sr_java_frame_dup" "                              " 7
at_xfail=no
(
  $as_echo "52. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_frame_dup.c <<'_ATEOF'

#include "java/frame.h"
#include "utils.h"
#include <assert.h>

int
main(void)
{
  struct sr_java_frame *frame1 = sr_java_frame_new();
  frame1->name = sr_strdup("name.space.test1.ctor");
  frame1->file_name = sr_strdup("test1.java");
  frame1->file_line = 1;
  frame1->class_path = sr_strdup("/usr/share/jar1");

  struct sr_java_frame *frame0 = sr_java_frame_new();;
  frame0->name = sr_strdup("name.space.test0.ctor");
  frame0->file_name = sr_strdup("test0.java");
  frame0->file_line = 2;
  frame0->class_path = sr_strdup("/usr/share/jar0");
  frame0->next = frame1;

  /* Test the duplication without siblings. */
  struct sr_java_frame *frame = sr_java_frame_dup(frame0, false);
  assert(NULL == frame->next);

  assert(frame->name != frame0->name);
  assert(0 == strcmp(frame->name, frame0->name));

  assert(frame->file_name != frame0->file_name);
  assert(0 == strcmp(frame->file_name, frame0->file_name));

  assert(frame->file_line == frame0->file_line);

  assert(frame->class_path != frame0->class_path);
  assert(0 == strcmp(frame->class_path, frame0->class_path));

  assert(0 == sr_java_frame_cmp(frame, frame0));
  sr_java_frame_free(frame);

  /* Test the duplication with the siblings. */
  frame = sr_java_frame_dup(frame0, true);
  assert(frame->name != frame0->name);
  assert(0 == strcmp(frame->name, frame0->name));

  assert(frame->file_name != frame0->file_name);
  assert(0 == strcmp(frame->file_name, frame0->file_name));

  assert(frame->file_line == frame0->file_line);

  assert(frame->class_path != frame0->class_path);
  assert(0 == strcmp(frame->class_path, frame0->class_path));

  assert(frame->next != frame1);
  assert(0 == sr_java_frame_cmp(frame->next, frame1));

  sr_java_frame_free(frame->next);
  sr_java_frame_free(frame);

  struct sr_java_frame *exception0 = sr_java_frame_new_exception();
  exception0->name = sr_strdup("com.sun.java.NullPointer");
  exception0->message = sr_strdup("Null pointer exception");
  exception0->next = frame0;

  struct sr_java_frame *exception = sr_java_frame_dup(exception0, false);
  assert(NULL == exception->next);

  assert(exception->name != exception0->name);
  assert(0 == strcmp(exception->name, exception0->name));

  assert(exception->message != exception0->message);
  assert(0 == strcmp(exception->message, exception0->message));
  sr_java_frame_free(exception);

  exception = sr_java_frame_dup(exception0, true);
  assert(NULL != exception->next);
  assert(exception->next != frame0);

  assert(exception->name != exception0->name);
  assert(0 == strcmp(exception->name, exception0->name));

  assert(exception->message != exception0->message);
  assert(0 == strcmp(exception->message, exception0->message));

  assert(0 == sr_java_frame_cmp(exception->next, frame0));
  assert(0 == sr_java_frame_cmp(exception->next->next, frame1));

  sr_java_frame_free(exception);
  sr_java_frame_free(exception0);
  sr_java_frame_free(frame0);
  sr_java_frame_free(frame1);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_frame.at:87: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_frame_dup sr_java_frame_dup.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_frame_dup sr_java_frame_dup.c $LIBS" "java_frame.at:87"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_frame_dup sr_java_frame_dup.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_frame.at:87"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_frame.at:87: ./sr_java_frame_dup"
at_fn_check_prepare_trace "java_frame.at:87"
( $at_check_trace; ./sr_java_frame_dup
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_frame.at:87"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_52
#AT_START_53
at_fn_group_banner 53 'java_frame.at:186' \
  "sr_java_frame_append_to_str" "                    " 7
at_xfail=no
(
  $as_echo "53. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_frame_append_to_str.c <<'_ATEOF'

#include "java/frame.h"
#include "strbuf.h"
#include "utils.h"
#include "frame.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

void
check(struct sr_java_frame *frame, const char *expected)
{
  struct sr_strbuf *buf = sr_strbuf_new();
  sr_java_frame_append_to_str(frame, buf);

  printf(
"<==============================================================================>\n"
"%s == %s\n"
"<==============================================================================>\n",
  expected, buf->buf);

  assert(strcmp(expected, buf->buf) == 0);

  struct sr_strbuf *buf2 = sr_strbuf_new();
  sr_frame_append_to_str((struct sr_frame*)frame, buf2);
  assert(strcmp(expected, buf2->buf) == 0);

  sr_strbuf_free(buf);
  sr_strbuf_free(buf2);
}

int
main(void)
{
  /* basic */
  struct sr_java_frame frame;
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.file_name = sr_strdup("duke.java");
  frame.file_line = 666;

  check(&frame, "\tat com.redhat.abrt.duke.nuke(duke.java:666) [unknown]");

  frame.file_line = 0;
  frame.is_native = true;
  check(&frame, "\tat com.redhat.abrt.duke.nuke(Native Method) [unknown]");
  frame.is_native = false;

  free(frame.file_name);
  frame.file_name = NULL;

  check(&frame, "\tat com.redhat.abrt.duke.nuke(Unknown Source) [unknown]");

  frame.class_path = "/usr/lib/java/Foo.class";
  check(&frame, "\tat com.redhat.abrt.duke.nuke(Unknown Source) [file:/usr/lib/java/Foo.class]");

  frame.class_path = "http://localhost/Foo.class";
  check(&frame, "\tat com.redhat.abrt.duke.nuke(Unknown Source) [http://localhost/Foo.class]");

  struct sr_java_frame *exception0 = sr_java_frame_new_exception();
  exception0->name = sr_strdup("com.sun.java.NullPointer");
  exception0->message = sr_strdup("Null pointer exception");

  check(exception0, "com.sun.java.NullPointer: Null pointer exception");

  free(exception0->message);
  exception0->message = NULL;

  check(exception0, "com.sun.java.NullPointer");

  free(exception0->name);
  exception0->name = NULL;

  check(exception0, "");

  exception0->message = sr_strdup("Null pointer exception");

  check(exception0, ": Null pointer exception");

  return 0;
}

_ATEOF

{ set +x
$as_echo "$at_srcdir/java_frame.at:186: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_frame_append_to_str sr_java_frame_append_to_str.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_frame_append_to_str sr_java_frame_append_to_str.c $LIBS" "java_frame.at:186"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_frame_append_to_str sr_java_frame_append_to_str.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_frame.at:186"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_frame.at:186: ./sr_java_frame_append_to_str"
at_fn_check_prepare_trace "java_frame.at:186"
( $at_check_trace; ./sr_java_frame_append_to_str
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_frame.at:186"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_53
#AT_START_54
at_fn_group_banner 54 'java_frame.at:275' \
  "sr_java_frame_parse" "                            " 7
at_xfail=no
(
  $as_echo "54. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_frame_parse.c <<'_ATEOF'

#include "java/frame.h"
#include "location.h"
#include "strbuf.h"
#include "utils.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

static void
check(char *input,
      struct sr_java_frame *expected_frame,
      char *expected_input,
      struct sr_location *expected_location)
{
  char *old_input = input;
  struct sr_location location;
  sr_location_init(&location);
  struct sr_java_frame *frame = sr_java_frame_parse((const char **)&input, &location);
  assert(input == expected_input);
  if (frame)
  {
    struct sr_strbuf *buf = sr_strbuf_new();
    sr_java_frame_append_to_str(frame, buf);

    char *tmp_input = sr_strdup(old_input);
    size_t len = strlen(tmp_input);
    if (len > 0 && tmp_input[len-1] == '\n')
        tmp_input[len-1] = '\0';

    const char *fr1 = sr_skip_whitespace(tmp_input);
    const char *fr2 = sr_skip_whitespace(buf->buf);

    printf("<==============================================================================>\n");
    printf("'%s' == '%s'\n", fr1, fr2);
    printf("<==============================================================================>\n");

    /* Uncomment the line above once satyr prints a frame in same format as the input
       assert(strcmp(fr1, fr2) == 0);
     */

    free(tmp_input);
    sr_strbuf_free(buf);

    assert(0 == sr_java_frame_cmp(frame, expected_frame));
    puts(sr_location_to_string(&location));
    puts(sr_location_to_string(expected_location));
    assert(0 == sr_location_cmp(&location, expected_location, true));
    sr_java_frame_free(frame);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
    assert(0 == sr_location_cmp(&location, expected_location, true));
    assert(!expected_frame);
  }
}

int
main(void)
{
  /* basic */
  struct sr_java_frame frame;
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.file_name = sr_strdup("duke.java");
  frame.file_line = 666;

  char *c = "    at com.redhat.abrt.duke.nuke(duke.java:666)";
  struct sr_location location;
  sr_location_init(&location);
  location.line = 1;
  location.column = 46;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.file_name = sr_strdup("duke.java");
  frame.file_line = 666;
  frame.class_path = sr_strdup("/usr/lib/java/foo.class");

  c = "    at com.redhat.abrt.duke.nuke(duke.java:666) [file:/usr/lib/java/foo.class]";
  sr_location_init(&location);
  location.line = 1;
  location.column = 77;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.file_name = sr_strdup("duke.java");
  frame.file_line = 666;
  frame.class_path = sr_strdup("http://localhost/foo.class");

  c = "    at com.redhat.abrt.duke.nuke(duke.java:666) [http://localhost/foo.class]";
  sr_location_init(&location);
  location.line = 1;
  location.column = 75;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.file_name = sr_strdup("duke.java");
  frame.file_line = 666;
  frame.class_path = sr_strdup("/usr/lib/java/foo.jar");

  c = "    at com.redhat.abrt.duke.nuke(duke.java:666) [jar:file:/usr/lib/java/foo.jar!/foo.class]";
  sr_location_init(&location);
  location.line = 1;
  location.column = 90;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.file_name = sr_strdup("duke.java");
  frame.file_line = 666;
  frame.class_path = sr_strdup("http://localhost/foo.jar");

  c = "    at com.redhat.abrt.duke.nuke(duke.java:666) [jar:http://localhost/foo.jar!/foo.class]";
  sr_location_init(&location);
  location.line = 1;
  location.column = 88;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.file_name = sr_strdup("duke.java");
  frame.file_line = 666;

  c = "    at com.redhat.abrt.duke.nuke(duke.java:666) [unknown]";
  sr_location_init(&location);
  location.line = 1;
  location.column = 56;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.file_line = 666;

  c = "    at com.redhat.abrt.duke.nuke(Unknown Source:666)\n";
  sr_location_init(&location);
  location.line = 2;
  location.column = 0;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);
  frame.file_name = sr_strdup("duke.java");
  frame.file_line = 666;

  c = "    at (duke.java:666)\n";
  sr_location_init(&location);
  location.line = 2;
  location.column = 0;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.file_name = sr_strdup("duke.java");

  c = "    at com.redhat.abrt.duke.nuke(duke.java)\n";
  sr_location_init(&location);
  location.line = 2;
  location.column = 0;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.file_name = sr_strdup("duke.java");
  frame.class_path = sr_strdup("/usr/lib/java/foo.class");

  c = "    at com.redhat.abrt.duke.nuke(duke.java:-1) [file:/usr/lib/java/foo.class]\n";
  sr_location_init(&location);
  location.line = 2;
  location.column = 0;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);
  frame.name = sr_strdup("com.redhat.abrt.duke.nuke");
  frame.is_native = true;

  c = "    at com.redhat.abrt.duke.nuke(Native Method)\n";
  sr_location_init(&location);
  location.line = 2;
  location.column = 0;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  sr_java_frame_init(&frame);

  c = "  at (Unknown Source)\n";
  sr_location_init(&location);
  location.line = 2;
  location.column = 0;
  check(c, &frame, c + strlen(c), &location);

  /** next frame **/
  c = " fasdfd";
  sr_location_init(&location);
  location.message = "Frame expected";
  check(c, NULL, c, &location);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_frame.at:275: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_frame_parse sr_java_frame_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_frame_parse sr_java_frame_parse.c $LIBS" "java_frame.at:275"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_frame_parse sr_java_frame_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_frame.at:275"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_frame.at:275: ./sr_java_frame_parse"
at_fn_check_prepare_trace "java_frame.at:275"
( $at_check_trace; ./sr_java_frame_parse
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_frame.at:275"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_54
#AT_START_55
at_fn_group_banner 55 'java_frame.at:497' \
  "sr_java_frame_parse_exception" "                  " 7
at_xfail=no
(
  $as_echo "55. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_frame_parse_exception.c <<'_ATEOF'

#include "java/frame.h"
#include "location.h"
#include "strbuf.h"
#include "utils.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>

#include "java_testcases.c"

static void
check(char *input,
      const char *expected,
      struct sr_java_frame *expected_frame,
      char *expected_input,
      struct sr_location *expected_location)
{
  const char *old_input = input;
  struct sr_location location;
  sr_location_init(&location);
  struct sr_java_frame *frame = sr_java_frame_parse_exception((const char **)&input, &location);
  assert(input == expected_input);
  puts("--------------------------------------------------------------------------------");
  puts(sr_location_to_string(&location));
  puts(sr_location_to_string(expected_location));
  if (frame)
  {
    struct sr_strbuf *buf = sr_strbuf_new();
    sr_java_frame_append_to_str(frame, buf);

    const char *fr2 = buf->buf;

    printf("<==============================================================================>\n");
    printf("'%s' == '%s'\n", expected, fr2);
    printf("<==============================================================================>\n");

    assert(strcmp(expected, fr2) == 0);

    sr_strbuf_free(buf);

    struct sr_java_frame *tmp_expected = expected_frame;
    struct sr_java_frame *parsed = frame;
    while (parsed && tmp_expected)
    {
        assert(0 == sr_java_frame_cmp(parsed, tmp_expected));
        parsed = parsed->next;
        tmp_expected = tmp_expected->next;
    }

    assert(parsed == tmp_expected);
    assert(0 == sr_location_cmp(&location, expected_location, true));
    sr_java_frame_free_full(frame);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
    assert(0 == sr_location_cmp(&location, expected_location, true));
    assert(!expected_frame);
  }
}

int
main(void)
{
  /* basic */
  {
      struct sr_java_frame* exception = sr_java_frame_new_exception();
      exception->name = sr_strdup("com.sun.java.NullPointer");
      exception->message = sr_strdup("Null Pointer Exception");

      char *c = "com.sun.java.NullPointer: Null Pointer Exception";

      struct sr_location location;
      sr_location_init(&location);
      location.line = 1;
      location.column = 48;
      check(c, c, exception, c + strlen(c), &location);

      sr_java_frame_free(exception);
  }

  /* Next exception */
  {
      struct sr_java_frame* exception = sr_java_frame_new_exception();
      exception->name = sr_strdup("com.sun.java.NullPointer");

      char *c = "com.sun.java.NullPointer: ";

      struct sr_location location;
      sr_location_init(&location);
      location.line = 1;
      location.column = 26;
      check(c, "com.sun.java.NullPointer", exception, c + strlen(c), &location);

      sr_java_frame_free(exception);
  }

  /* Next exception */
  {
      struct sr_java_frame* exception = sr_java_frame_new_exception();
      exception->name = sr_strdup("com.sun.java.NullPointer");

      char *c = "com.sun.java.NullPointer  ";

      struct sr_location location;
      sr_location_init(&location);
      location.line = 1;
      location.column = 26;
      check(c, "com.sun.java.NullPointer", exception, c + strlen(c), &location);

      sr_java_frame_free(exception);
  }

  /* Next Exception */
  {
      char *c = ": Null Pointer Exception";

      struct sr_location location;
      sr_location_init(&location);
      location.line = 1;
      location.column = 0;
      location.message = "Expected exception name";
      check(c, NULL, NULL, c, &location);
  }

  /* Next Exception */
  {
      char *c = "";

      struct sr_location location;
      sr_location_init(&location);
      location.line = 1;
      location.column = 0;
      location.message = "Expected exception name";
      check(c, NULL, NULL, c, &location);
  }

  /* Next Exception */
  {
      struct sr_java_frame *frame = sr_java_frame_new();
      frame->name = sr_strdup("com.redhat.abrt.duke.nuke");
      frame->file_name = sr_strdup("duke.java");
      frame->file_line = 666;

      struct sr_java_frame* exception = sr_java_frame_new_exception();
      exception->name = sr_strdup("com.sun.java.NullPointer");
      exception->message = sr_strdup("Null Pointer Exception");
      exception->next = frame;

      char *c =
"com.sun.java.NullPointer: Null Pointer Exception\n"
"\tat com.redhat.abrt.duke.nuke(duke.java:666)";

      struct sr_location location;
      sr_location_init(&location);
      location.line = 2;
      location.column = 43;
      check(c, "com.sun.java.NullPointer: Null Pointer Exception", exception, c + strlen(c), &location);

      sr_java_frame_free_full(exception);
  }

  /* Next Exception */
  {
      struct sr_java_frame *frame = sr_java_frame_new();
      frame->name = sr_strdup("com.redhat.abrt.duke.nuke");
      frame->file_name = sr_strdup("duke.java");
      frame->file_line = 666;

      struct sr_java_frame *frame1 = sr_java_frame_dup(frame, false);
      struct sr_java_frame *frame2 = sr_java_frame_dup(frame, false);

      struct sr_java_frame* exception = sr_java_frame_new_exception();
      exception->name = sr_strdup("com.sun.java.NullPointer");
      exception->message = sr_strdup("Null Pointer Exception");
      exception->next = frame;

      struct sr_java_frame* exception1 = sr_java_frame_new_exception();
      exception1->name = sr_strdup("com.sun.java.InvalidOperation");

      struct sr_java_frame* exception2 = sr_java_frame_dup(exception1, false);

      frame1->next = exception;  //   ^
      exception1->next = frame1; //   |
      frame2->next = exception1; //   |
      exception2->next = frame2; //   |

      char *c =
"com.sun.java.NullPointer: Null Pointer Exception\n"
"\tat com.redhat.abrt.duke.nuke(duke.java:666)\n"
"\tCaused by: com.sun.java.InvalidOperation: Invalid Operation\n"
"\tat com.redhat.abrt.duke.nuke(duke.java:666)\n"
"\t... 1 more\n"
"\tCaused by: com.sun.java.InvalidOperation: Invalid Operation\n"
"\tat com.redhat.abrt.duke.nuke(duke.java:666)\n"
"\t... 2 more";

      struct sr_location location;
      sr_location_init(&location);
      location.line = 8;
      location.column = 11;
      check(c, "com.sun.java.InvalidOperation: Invalid Operation", exception2, c + strlen(c), &location);

      sr_java_frame_free_full(exception2);
  }
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_frame.at:497: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_frame_parse_exception sr_java_frame_parse_exception.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_frame_parse_exception sr_java_frame_parse_exception.c $LIBS" "java_frame.at:497"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_frame_parse_exception sr_java_frame_parse_exception.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_frame.at:497"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_frame.at:497: ./sr_java_frame_parse_exception"
at_fn_check_prepare_trace "java_frame.at:497"
( $at_check_trace; ./sr_java_frame_parse_exception
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_frame.at:497"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_55
#AT_START_56
at_fn_group_banner 56 'java_thread.at:8' \
  "sr_java_thread_cmp" "                             " 8
at_xfail=no
(
  $as_echo "56. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_thread_cmp.c <<'_ATEOF'

#include "java/thread.h"
#include "java/frame.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#include "java_testcases.c"

int
main(void)
{
  struct sr_java_thread *thread0 = create_real_main_thread_objects();
  struct sr_java_thread *thread1 = create_real_main_thread_objects();

  assert(0 == sr_java_thread_cmp(thread0, thread1));
  assert(0 == sr_thread_cmp(thread0, thread1));

  sr_java_frame_free_full(thread1->frames);
  thread1->frames = NULL;

  assert(0 != sr_java_thread_cmp(thread0, thread1));
  assert(0 != sr_thread_cmp(thread0, thread1));

  sr_java_thread_free(thread1);

  thread1 = create_real_main_thread_objects();
  free(thread1->name);
  thread1->name = sr_strdup("worker");

  assert(0 != sr_java_thread_cmp(thread0, thread1));
  assert(0 != sr_thread_cmp(thread0, thread1));

  sr_java_thread_free(thread0);
  sr_java_thread_free(thread1);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_thread.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_thread_cmp sr_java_thread_cmp.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_cmp sr_java_thread_cmp.c $LIBS" "java_thread.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_cmp sr_java_thread_cmp.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_thread.at:8: ./sr_java_thread_cmp"
at_fn_check_prepare_trace "java_thread.at:8"
( $at_check_trace; ./sr_java_thread_cmp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_56
#AT_START_57
at_fn_group_banner 57 'java_thread.at:53' \
  "sr_java_thread_dup" "                             " 8
at_xfail=no
(
  $as_echo "57. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_thread_dup.c <<'_ATEOF'

#include "java/thread.h"
#include "java/frame.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#include "java_testcases.c"

int
main(void)
{
  struct sr_java_thread *thread0 = create_real_main_thread_objects();
  struct sr_java_thread *thread1 = sr_java_thread_dup(thread0, false);

  assert(0 == sr_java_thread_cmp(thread0, thread1));

  sr_java_thread_free(thread0);
  sr_java_thread_free(thread1);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_thread.at:53: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_thread_dup sr_java_thread_dup.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_dup sr_java_thread_dup.c $LIBS" "java_thread.at:53"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_dup sr_java_thread_dup.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:53"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_thread.at:53: ./sr_java_thread_dup"
at_fn_check_prepare_trace "java_thread.at:53"
( $at_check_trace; ./sr_java_thread_dup
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:53"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_57
#AT_START_58
at_fn_group_banner 58 'java_thread.at:82' \
  "sr_java_thread_remove_frame" "                    " 8
at_xfail=no
(
  $as_echo "58. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_thread_remove_frame.c <<'_ATEOF'

#include "java/frame.h"
#include "location.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

#include "java_testcases.c"

int
main(void)
{
  struct sr_java_thread thread;
  sr_java_thread_init(&thread);

  struct sr_java_frame *exception2 = create_real_stacktrace_objects();
  thread.frames = exception2;

  struct sr_java_frame *removed = exception2;

  assert(sr_java_thread_remove_frame(&thread, removed) || !"Remove the top of stack");
  assert(removed != thread.frames);

  removed = sr_java_frame_get_last(thread.frames);

  assert(sr_java_thread_remove_frame(&thread, removed) || !"Remove the bottom of stack");
  assert(removed != sr_java_frame_get_last(thread.frames));

  removed = thread.frames->next;

  assert(sr_java_thread_remove_frame(&thread, removed) || !"Remove the middle of stack");
  assert(removed != thread.frames->next);

  assert(0 == sr_java_thread_remove_frame(&thread, removed) || !"Remove a nonexisting frame");

  sr_java_frame_free_full(thread.frames);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_thread.at:82: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_thread_remove_frame sr_java_thread_remove_frame.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_remove_frame sr_java_thread_remove_frame.c $LIBS" "java_thread.at:82"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_remove_frame sr_java_thread_remove_frame.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:82"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_thread.at:82: ./sr_java_thread_remove_frame"
at_fn_check_prepare_trace "java_thread.at:82"
( $at_check_trace; ./sr_java_thread_remove_frame
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:82"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_58
#AT_START_59
at_fn_group_banner 59 'java_thread.at:127' \
  "sr_java_thread_remove_frames_above" "             " 8
at_xfail=no
(
  $as_echo "59. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_thread_remove_frames_above.c <<'_ATEOF'

#include "java/frame.h"
#include "location.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

#include "java_testcases.c"

int
main(void)
{
  struct sr_java_thread thread;
  sr_java_thread_init(&thread);

  struct sr_java_frame *exception2 = create_real_stacktrace_objects();
  thread.frames = exception2;

  struct sr_java_frame *top = exception2;

  assert(sr_java_thread_remove_frames_above(&thread, top) || !"Remove above the top of stack");
  assert(top == thread.frames);

  top = thread.frames->next;

  assert(sr_java_thread_remove_frames_above(&thread, top) || !"Remove above the middle of stack");
  assert(top == thread.frames);

  struct sr_java_frame *above = thread.frames;
  top = sr_java_frame_get_last(thread.frames);

  assert(sr_java_thread_remove_frames_above(&thread, top) || !"Remove above the bottom of stack");
  assert(top == thread.frames);

  assert(0 == sr_java_thread_remove_frames_above(&thread, above) || !"Remove above a nonexisting frame");

  sr_java_frame_free_full(thread.frames);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_thread.at:127: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_thread_remove_frames_above sr_java_thread_remove_frames_above.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_remove_frames_above sr_java_thread_remove_frames_above.c $LIBS" "java_thread.at:127"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_remove_frames_above sr_java_thread_remove_frames_above.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:127"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_thread.at:127: ./sr_java_thread_remove_frames_above"
at_fn_check_prepare_trace "java_thread.at:127"
( $at_check_trace; ./sr_java_thread_remove_frames_above
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:127"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_59
#AT_START_60
at_fn_group_banner 60 'java_thread.at:173' \
  "sr_java_thread_remove_frames_below_n" "           " 8
at_xfail=no
(
  $as_echo "60. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_thread_remove_frames_below_n.c <<'_ATEOF'

#include "java/frame.h"
#include "location.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

#include "java_testcases.c"

int
main(void)
{
  struct sr_java_thread thread;
  sr_java_thread_init(&thread);

  struct sr_java_frame *exception2 = create_real_stacktrace_objects();
  thread.frames = exception2;

  struct sr_java_frame *bottom = sr_java_frame_get_last(thread.frames);

  /* Remove below too large */
  sr_java_thread_remove_frames_below_n(&thread, 100);
  assert(bottom != thread.frames);
  assert(bottom == sr_java_frame_get_last(thread.frames));

  bottom = thread.frames->next;

  /* Remove below the second frame */
  sr_java_thread_remove_frames_below_n(&thread, 2);
  assert(thread.frames);
  assert(bottom == thread.frames->next);
  assert(NULL == thread.frames->next->next);

  /* Remove below 'over the top' frame */
  sr_java_thread_remove_frames_below_n(&thread, 0);
  assert(NULL == thread.frames);

  sr_java_frame_free_full(thread.frames);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_thread.at:173: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_thread_remove_frames_below_n sr_java_thread_remove_frames_below_n.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_remove_frames_below_n sr_java_thread_remove_frames_below_n.c $LIBS" "java_thread.at:173"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_remove_frames_below_n sr_java_thread_remove_frames_below_n.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_thread.at:173: ./sr_java_thread_remove_frames_below_n"
at_fn_check_prepare_trace "java_thread.at:173"
( $at_check_trace; ./sr_java_thread_remove_frames_below_n
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:173"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_60
#AT_START_61
at_fn_group_banner 61 'java_thread.at:221' \
  "sr_java_thread_parse" "                           " 8
at_xfail=no
(
  $as_echo "61. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_thread_parse.c <<'_ATEOF'

#include "java/thread.h"
#include "java/frame.h"
#include "location.h"
#include "strbuf.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#include "java_testcases.c"

static void
check(const char *input,
      struct sr_java_thread *expected_thread)
{
  printf("================================================================================\n"
         "Testing input:\n%s", input);

  const char *old_input = input;
  struct sr_location location;
  sr_location_init(&location);
  struct sr_java_thread *thread = sr_java_thread_parse((const char **)&input, &location);
  assert(!expected_thread || thread);
  if (thread)
  {
    struct sr_strbuf *output = sr_strbuf_new();
    sr_java_thread_append_to_str(thread, output);
    printf("--------------------------------------------------------------------------------\n"
         "Parsed :\n%s", output->buf);

    sr_strbuf_free(output);

    assert(*input == '\0');
    assert(0 == sr_java_thread_cmp(thread, expected_thread));
    sr_java_thread_free(thread);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
    assert(!expected_thread);
  }
  printf("================================================================================\n");
}

int
main(void)
{
  struct sr_java_thread *thread = create_real_main_thread_objects();

  struct sr_location location;
  sr_location_init(&location);

  check(get_real_thread_stacktrace() , thread);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_thread.at:221: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_thread_parse sr_java_thread_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_parse sr_java_thread_parse.c $LIBS" "java_thread.at:221"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_thread_parse sr_java_thread_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:221"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_thread.at:221: ./sr_java_thread_parse"
at_fn_check_prepare_trace "java_thread.at:221"
( $at_check_trace; ./sr_java_thread_parse
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_thread.at:221"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_61
#AT_START_62
at_fn_group_banner 62 'java_stacktrace.at:8' \
  "sr_java_stacktrace_cmp" "                         " 9
at_xfail=no
(
  $as_echo "62. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_stacktrace_cmp.c <<'_ATEOF'

#include "java/stacktrace.h"
#include "java/thread.h"
#include "java/frame.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#include "java_testcases.c"

int
main(void)
{
  struct sr_java_stacktrace *stacktrace0 = sr_java_stacktrace_new();
  stacktrace0->threads = create_real_main_thread_objects();

  struct sr_java_stacktrace *stacktrace1 = sr_java_stacktrace_new();
  stacktrace1->threads = create_real_main_thread_objects();

  assert(0 == sr_java_stacktrace_cmp(stacktrace0, stacktrace1));

  sr_java_thread_free(stacktrace1->threads);
  stacktrace1->threads = NULL;

  assert(0 != sr_java_stacktrace_cmp(stacktrace0, stacktrace1));

  sr_java_stacktrace_free(stacktrace0);
  sr_java_stacktrace_free(stacktrace1);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_stacktrace.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_stacktrace_cmp sr_java_stacktrace_cmp.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_stacktrace_cmp sr_java_stacktrace_cmp.c $LIBS" "java_stacktrace.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_stacktrace_cmp sr_java_stacktrace_cmp.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_stacktrace.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_stacktrace.at:8: ./sr_java_stacktrace_cmp"
at_fn_check_prepare_trace "java_stacktrace.at:8"
( $at_check_trace; ./sr_java_stacktrace_cmp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_stacktrace.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_62
#AT_START_63
at_fn_group_banner 63 'java_stacktrace.at:45' \
  "sr_java_stacktrace_dup" "                         " 9
at_xfail=no
(
  $as_echo "63. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_stacktrace_dup.c <<'_ATEOF'

#include "java/stacktrace.h"
#include "java/thread.h"
#include "java/frame.h"
#include "location.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#include "java_testcases.c"

int
main(void)
{
  struct sr_java_stacktrace *stacktrace0 = create_real_main_thread_objects();
  stacktrace0->threads = create_real_main_thread_objects();

  struct sr_java_stacktrace *stacktrace1 = sr_java_stacktrace_dup(stacktrace0);

  assert(0 == sr_java_stacktrace_cmp(stacktrace0, stacktrace1));

  sr_java_stacktrace_free(stacktrace0);
  sr_java_stacktrace_free(stacktrace1);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_stacktrace.at:45: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_stacktrace_dup sr_java_stacktrace_dup.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_stacktrace_dup sr_java_stacktrace_dup.c $LIBS" "java_stacktrace.at:45"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_stacktrace_dup sr_java_stacktrace_dup.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_stacktrace.at:45"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_stacktrace.at:45: ./sr_java_stacktrace_dup"
at_fn_check_prepare_trace "java_stacktrace.at:45"
( $at_check_trace; ./sr_java_stacktrace_dup
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_stacktrace.at:45"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_63
#AT_START_64
at_fn_group_banner 64 'java_stacktrace.at:77' \
  "sr_java_stacktrace_parse" "                       " 9
at_xfail=no
(
  $as_echo "64. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_stacktrace_parse.c <<'_ATEOF'

#include "java/stacktrace.h"
#include "java/thread.h"
#include "java/frame.h"
#include "location.h"
#include "stacktrace.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

#include "java_testcases.c"

static void
check(char *input,
      struct sr_java_stacktrace *expected_stacktrace)
{
  printf("===============================================\n"
         "Testing input:\n%s", input);

  char *old_input = input;
  struct sr_location location;
  sr_location_init(&location);
  struct sr_java_stacktrace *stacktrace = sr_java_stacktrace_parse(&input, &location);
  assert(!expected_stacktrace || stacktrace);
  if (stacktrace)
  {
    assert(*input == '\0');
    assert(0 == sr_java_stacktrace_cmp(stacktrace, expected_stacktrace));

    /* check sr_stacktrace_parse */
    char *error;
    input = old_input;
    struct sr_stacktrace *stacktrace2 = sr_stacktrace_parse(SR_REPORT_JAVA, input, &error);
    assert(stacktrace2);
    char *json1 = sr_stacktrace_to_json(stacktrace);
    char *json2 = sr_stacktrace_to_json(stacktrace2);
    assert(json1 && json2 && 0 == strcmp(json1, json2));
    free(json1);
    free(json2);
    sr_stacktrace_free(stacktrace2);

    sr_java_stacktrace_free(stacktrace);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
    assert(!expected_stacktrace);
  }
}

int
main(void)
{
  struct sr_java_stacktrace *stacktrace0 = create_real_main_thread_objects();
  stacktrace0->threads = create_real_main_thread_objects();

  check(get_real_thread_stacktrace(), stacktrace0);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_stacktrace.at:77: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_stacktrace_parse sr_java_stacktrace_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_stacktrace_parse sr_java_stacktrace_parse.c $LIBS" "java_stacktrace.at:77"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_stacktrace_parse sr_java_stacktrace_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_stacktrace.at:77"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_stacktrace.at:77: ./sr_java_stacktrace_parse"
at_fn_check_prepare_trace "java_stacktrace.at:77"
( $at_check_trace; ./sr_java_stacktrace_parse
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_stacktrace.at:77"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_64
#AT_START_65
at_fn_group_banner 65 'java_stacktrace.at:144' \
  "sr_java_stacktrace_reason" "                      " 9
at_xfail=no
(
  $as_echo "65. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_java_stacktrace_reason.c <<'_ATEOF'

#include "java/stacktrace.h"
#include "location.h"
#include "utils.h"
#include <assert.h>

int main(void)
{
  char *err_msg = NULL;
  char *full_input = sr_file_to_string("../../java_stacktraces/java-01",
                                       &err_msg);
  assert(full_input && err_msg == NULL);

  struct sr_location loc;
  struct sr_java_stacktrace *s = sr_java_stacktrace_parse(&full_input, &loc);
  assert(s);

  char *reason = sr_java_stacktrace_get_reason(s);
  assert(reason);
  free(reason);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/java_stacktrace.at:144: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_java_stacktrace_reason sr_java_stacktrace_reason.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_stacktrace_reason sr_java_stacktrace_reason.c $LIBS" "java_stacktrace.at:144"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_java_stacktrace_reason sr_java_stacktrace_reason.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_stacktrace.at:144"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/java_stacktrace.at:144: ./sr_java_stacktrace_reason"
at_fn_check_prepare_trace "java_stacktrace.at:144"
( $at_check_trace; ./sr_java_stacktrace_reason
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/java_stacktrace.at:144"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_65
#AT_START_66
at_fn_group_banner 66 'koops_frame.at:9' \
  "sr_koops_skip_timestamp" "                        " 10
at_xfail=no
(
  $as_echo "66. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_koops_skip_timestamp.c <<'_ATEOF'

#include "koops/frame.h"
#include <assert.h>
#include <stdlib.h>

static void
check(bool success, char *input)
{
  char *old_input = input;
  assert(success == sr_koops_skip_timestamp(&input));

  if (success)
    assert(*input == '\0');
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int
main(void)
{
  check(true, "[  120.836230]");
  check(true, "[110417.280595]");
  check(false, "--2012-06-28 ");
  check(false, "[<ffffffff81479782>]");
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/koops_frame.at:9: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_koops_skip_timestamp sr_koops_skip_timestamp.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_skip_timestamp sr_koops_skip_timestamp.c $LIBS" "koops_frame.at:9"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_skip_timestamp sr_koops_skip_timestamp.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/koops_frame.at:9: ./sr_koops_skip_timestamp"
at_fn_check_prepare_trace "koops_frame.at:9"
( $at_check_trace; ./sr_koops_skip_timestamp
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_66
#AT_START_67
at_fn_group_banner 67 'koops_frame.at:45' \
  "sr_koops_parse_address" "                         " 10
at_xfail=no
(
  $as_echo "67. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_koops_parse_address.c <<'_ATEOF'

#include "koops/frame.h"
#include <assert.h>
#include <stdlib.h>

static void
check(bool success, char *input, uint64_t expected_address)
{
  char *old_input = input;
  uint64_t address;
  assert(success == sr_koops_parse_address(&input, &address));

  if (success)
  {
    assert(*input == '\0');
    assert(address == expected_address);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int
main(void)
{
  check(true, "[<ffffffff81479782>]", 0xffffffff81479782);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/koops_frame.at:45: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_koops_parse_address sr_koops_parse_address.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_parse_address sr_koops_parse_address.c $LIBS" "koops_frame.at:45"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_parse_address sr_koops_parse_address.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:45"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/koops_frame.at:45: ./sr_koops_parse_address"
at_fn_check_prepare_trace "koops_frame.at:45"
( $at_check_trace; ./sr_koops_parse_address
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:45"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_67
#AT_START_68
at_fn_group_banner 68 'koops_frame.at:82' \
  "sr_koops_parse_module_name" "                     " 10
at_xfail=no
(
  $as_echo "68. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_koops_parse_module_name.c <<'_ATEOF'

#include "koops/frame.h"
#include <assert.h>
#include <stdlib.h>

static void
check(bool success,
      char *input,
      char *expected_module_name)
{
  char *old_input = input;
  char *module_name;
  assert(success == sr_koops_parse_module_name(&input,
                                               &module_name));

  if (success)
  {
    assert(strcmp(module_name, expected_module_name) == 0);
    assert(*input == '\0');
    free(module_name);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int
main(void)
{
  check(true, "[ppp_generic]", "ppp_generic");
  check(false, "ppp_generic", NULL);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/koops_frame.at:82: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_koops_parse_module_name sr_koops_parse_module_name.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_parse_module_name sr_koops_parse_module_name.c $LIBS" "koops_frame.at:82"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_parse_module_name sr_koops_parse_module_name.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:82"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/koops_frame.at:82: ./sr_koops_parse_module_name"
at_fn_check_prepare_trace "koops_frame.at:82"
( $at_check_trace; ./sr_koops_parse_module_name
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:82"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_68
#AT_START_69
at_fn_group_banner 69 'koops_frame.at:124' \
  "sr_koops_parse_function" "                        " 10
at_xfail=no
(
  $as_echo "69. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_koops_parse_function.c <<'_ATEOF'

#include "koops/frame.h"
#include <assert.h>
#include <stdlib.h>
#include <stdint.h>

static void
check(bool success,
      char *input,
      char *expected_function_name,
      uint64_t expected_function_offset,
      uint64_t expected_function_length,
      char *expected_module_name)
{
  char *old_input = input;
  char *function_name = NULL, *module_name = NULL;
  uint64_t function_offset, function_length;
  assert(success == sr_koops_parse_function(&input,
                                            &function_name,
                                            &function_offset,
                                            &function_length,
                                            &module_name));

  if (success)
  {
    assert(strcmp(function_name, expected_function_name) == 0);
    assert(function_offset == expected_function_offset);
    assert(function_length == expected_function_length);
    assert(sr_strcmp0(module_name, expected_module_name) == 0);
    assert(*input == '\0');
    free(function_name);
    free(module_name);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int
main(void)
{
  check(true, "warn_slowpath_common+0x7f/0xc0", "warn_slowpath_common", 0x7f, 0xc0, NULL);
  check(true, "(_raw_spin_lock_irqsave+0x48/0x5c)", "_raw_spin_lock_irqsave", 0x48, 0x5c, NULL);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/koops_frame.at:124: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_koops_parse_function sr_koops_parse_function.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_parse_function sr_koops_parse_function.c $LIBS" "koops_frame.at:124"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_parse_function sr_koops_parse_function.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:124"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/koops_frame.at:124: ./sr_koops_parse_function"
at_fn_check_prepare_trace "koops_frame.at:124"
( $at_check_trace; ./sr_koops_parse_function
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:124"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_69
#AT_START_70
at_fn_group_banner 70 'koops_frame.at:178' \
  "sr_koops_frame_parse" "                           " 10
at_xfail=no
(
  $as_echo "70. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_koops_frame_parse.c <<'_ATEOF'

#include "koops/frame.h"
#include <assert.h>
#include <stdlib.h>
#include <stdint.h>

static void
check(bool success,
      char *input,
      struct sr_koops_frame *expected_frame)
{
  char *old_input = input;

  struct sr_koops_frame *frame = sr_koops_frame_parse(&input);
  assert(!!frame == success);

  if (success)
  {
    assert(0 == sr_koops_frame_cmp(frame, expected_frame));
    assert(*input == '\0');
    sr_koops_frame_free(frame);
  }
  else
  {
    /* Check that the pointer is not moved. */
    assert(old_input == input);
  }
}

int
main(void)
{
  struct sr_koops_frame frame;
  sr_koops_frame_init(&frame);
  frame.address = 0xffffffff8151f860;
  frame.reliable = false;
  frame.function_name = "ip_forward_options";
  frame.function_offset = 0x1f0;
  frame.function_length = 0x1f0;

  check(true, "[<ffffffff8151f860>] ? ip_forward_options+0x1f0/0x1f0", &frame);

  sr_koops_frame_init(&frame);
  frame.address = 0xc02f671c;
  frame.reliable = true;
  frame.function_name = "_raw_spin_lock_irqsave";
  frame.function_offset = 0x48;
  frame.function_length = 0x5c;
  frame.from_address = 0xbf054120;
  frame.from_function_name = "mxs_mmc_enable_sdio_irq";
  frame.from_function_offset = 0x18;
  frame.from_function_length = 0xdc;
  frame.from_module_name = "mxs_mmc";

  check(true, "[<c02f671c>] (_raw_spin_lock_irqsave+0x48/0x5c) from [<bf054120>] (mxs_mmc_enable_sdio_irq+0x18/0xdc [mxs_mmc])", &frame);

  sr_koops_frame_init(&frame);
  frame.reliable = true;
  frame.function_name = "sys_delete_module";
  frame.function_offset = 0x11f;
  frame.function_length = 0x280;

  check(true, "sys_delete_module+0x11f/0x280", &frame);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/koops_frame.at:178: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_koops_frame_parse sr_koops_frame_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_frame_parse sr_koops_frame_parse.c $LIBS" "koops_frame.at:178"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_frame_parse sr_koops_frame_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:178"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/koops_frame.at:178: ./sr_koops_frame_parse"
at_fn_check_prepare_trace "koops_frame.at:178"
( $at_check_trace; ./sr_koops_frame_parse
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:178"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_70
#AT_START_71
at_fn_group_banner 71 'koops_frame.at:250' \
  "sr_koops_frame_to_json" "                         " 10
at_xfail=no
(
  $as_echo "71. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_koops_frame_to_json.c <<'_ATEOF'

#include "koops/frame.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  struct sr_koops_frame frame;
  sr_koops_frame_init(&frame);
  frame.address = 0xc02f671c;
  frame.reliable = true;
  frame.function_name = "_raw_spin_lock_irqsave";
  frame.function_offset = 0x48;
  frame.function_length = 0x5c;
  frame.from_address = 0xbf054120;
  frame.from_function_name = "mxs_mmc_enable_sdio_irq";
  frame.from_function_offset = 0x18;
  frame.from_function_length = 0xdc;
  frame.from_module_name = "mxs_mmc";

  char *json = sr_koops_frame_to_json(&frame);
  puts(json);
  assert(0 == strcmp(json,
            "{   \"address\": 3224332060\n"
            ",   \"reliable\": true\n"
            ",   \"function_name\": \"_raw_spin_lock_irqsave\"\n"
            ",   \"function_offset\": 72\n"
            ",   \"function_length\": 92\n"
            ",   \"from_address\": 3204792608\n"
            ",   \"from_function_name\": \"mxs_mmc_enable_sdio_irq\"\n"
            ",   \"from_function_offset\": 24\n"
            ",   \"from_function_length\": 220\n"
            ",   \"from_module_name\": \"mxs_mmc\"\n"
            "}"));

  free(json);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/koops_frame.at:250: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_koops_frame_to_json sr_koops_frame_to_json.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_frame_to_json sr_koops_frame_to_json.c $LIBS" "koops_frame.at:250"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_frame_to_json sr_koops_frame_to_json.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:250"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/koops_frame.at:250: ./sr_koops_frame_to_json"
at_fn_check_prepare_trace "koops_frame.at:250"
( $at_check_trace; ./sr_koops_frame_to_json
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_frame.at:250"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_71
#AT_START_72
at_fn_group_banner 72 'koops_stacktrace.at:8' \
  "sr_koops_stacktrace_parse_modules" "              " 11
at_xfail=no
(
  $as_echo "72. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_koops_stacktrace_parse_modules.c <<'_ATEOF'

#include "koops/stacktrace.h"
#include <assert.h>
#include <stdlib.h>

static void
check(bool success,
      char *input,
      char **expected_modules)
{
    char *old_input = input;
    char **modules = sr_koops_stacktrace_parse_modules(&input);
    assert(!!modules == success);

    if (modules)
    {
        int offset = 0;
        while (modules[offset])
        {
            assert(expected_modules[offset]);
            assert(0 == strcmp(modules[offset], expected_modules[offset]));
            ++offset;
        }
        assert(!expected_modules[offset]);

        offset = 0;
        while (modules[offset])
        {
            free(modules[offset]);
            ++offset;
        }

        free(modules);
    }
    else
    {
        /* Check that the pointer is not moved. */
        assert(old_input == input);
    }
}

int
main(void)
{
    char *modules[] = { "vfat", "fat", "usb_storage", NULL };
    check(true, "Modules linked in: vfat fat usb_storage", modules);

    check(true, "Modules linked in: vfat fat usb_storage [last unloaded: scsi_wait_scan]\n",
          modules);

    check(true, "Modules linked in: vfat fat usb_storage \n[last unloaded: scsi_wait_scan]\n",
          modules);

    check(true, " Modules linked in: vfat fat usb_storage\n [last unloaded: scsi_wait_scan]\n",
          modules);

    check(true, "Modules linked in: vfat fat usb_st\norage [last unloaded: scsi_wait_scan]\n",
          modules);

    check(true, "Modules linked in: vfat fat \nusb_storage [last unloaded: scsi_wait_scan]\n",
          modules);

    check(true, "Modules linked in: vfat fat\n usb_storage [last unloaded: scsi_wait_scan]\n",
          modules);

    check(true,
          "Modules linked in: vfat fat usb_storage\n"
          "Pid: 31337, comm: ksoftirqd/2\n",
          modules);

    check(false, "I hate autotest", modules);

    return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/koops_stacktrace.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_koops_stacktrace_parse_modules sr_koops_stacktrace_parse_modules.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_stacktrace_parse_modules sr_koops_stacktrace_parse_modules.c $LIBS" "koops_stacktrace.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_stacktrace_parse_modules sr_koops_stacktrace_parse_modules.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_stacktrace.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/koops_stacktrace.at:8: ./sr_koops_stacktrace_parse_modules"
at_fn_check_prepare_trace "koops_stacktrace.at:8"
( $at_check_trace; ./sr_koops_stacktrace_parse_modules
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_stacktrace.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_72
#AT_START_73
at_fn_group_banner 73 'koops_stacktrace.at:89' \
  "sr_koops_stacktrace_parse" "                      " 11
at_xfail=no
(
  $as_echo "73. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_koops_stacktrace_parse.c <<'_ATEOF'

#include "koops/stacktrace.h"
#include "koops/frame.h"
#include "location.h"
#include "utils.h"
#include "thread.h"
#include "stacktrace.h"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>

static void
check(const char *path,
      const char *first_function_name,
      const char *last_function_name,
      int frame_count,
      int taint_count,
      int module_count,
      char *first_frame_stack,
      char *last_frame_stack)
{
  char *error_message;
  char *full_input = sr_file_to_string(path, &error_message);
  assert(full_input);
  char *input = full_input;

  struct sr_location location;
  sr_location_init(&location);
  struct sr_koops_stacktrace *stacktrace =
      sr_koops_stacktrace_parse(&input, &location);

  assert(stacktrace);
  assert(*input == '\0');

  if (stacktrace->frames)
  {
      assert(0 == sr_strcmp0(stacktrace->frames->function_name, first_function_name));
      assert(0 == sr_strcmp0(stacktrace->frames->special_stack, first_frame_stack));

      struct sr_koops_frame *last = stacktrace->frames;
      while (last->next)
          last = last->next;

      assert(0 == sr_strcmp0(last->function_name, last_function_name));
      assert(0 == sr_strcmp0(last->special_stack, last_frame_stack));
  }
  else
      assert(!first_function_name && !last_function_name && 0 == frame_count);

  printf("expected: %d, got: %d\n", frame_count,
         sr_thread_frame_count((struct sr_thread*) stacktrace));
  assert(frame_count == sr_thread_frame_count((struct sr_thread*) stacktrace));

  char *reason = sr_koops_stacktrace_get_reason(stacktrace);
  assert(reason);
  char *reason2 = sr_stacktrace_get_reason(stacktrace);
  assert(reason2);
  assert(0 == strcmp(reason, reason2));
  free(reason);
  free(reason2);

  int actual_taint_count =
    stacktrace->taint_module_proprietary +
    stacktrace->taint_module_out_of_tree +
    stacktrace->taint_forced_module +
    stacktrace->taint_forced_removal +
    stacktrace->taint_smp_unsafe +
    stacktrace->taint_mce +
    stacktrace->taint_page_release +
    stacktrace->taint_userspace +
    stacktrace->taint_died_recently +
    stacktrace->taint_acpi_overridden +
    stacktrace->taint_warning +
    stacktrace->taint_staging_driver +
    stacktrace->taint_firmware_workaround;

  assert(actual_taint_count == taint_count);

  int actual_module_count = 0;
  char** mod = stacktrace->modules;
  while (mod && *mod)
  {
    mod++;
    actual_module_count++;
  }
  assert(actual_module_count == module_count);

  /* test parsing via sr_stacktrace_parse */
  input = full_input;
  char *error;
  struct sr_stacktrace *stacktrace2 = sr_stacktrace_parse(SR_REPORT_KERNELOOPS, input, &error);

  assert(stacktrace2);
  reason = sr_stacktrace_get_reason(stacktrace);
  reason2 = sr_stacktrace_get_reason(stacktrace2);

  assert(reason && reason2);
  assert(0 == strcmp(reason, reason2));

  free(reason);
  free(reason2);
  sr_stacktrace_free(stacktrace2);

  sr_koops_stacktrace_free(stacktrace);
  free(full_input);
}

int
main(void)
{
  check("../../kerneloopses/gitlog-01", "unwind_backtrace", "kthread", 15, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-02", "unwind_backtrace", "cpu_idle", 27, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-03", "lockdep_rcu_suspicious", "system_call_fastpath", 19, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-04", "lockdep_rcu_suspicious", "addrconf_forward_change", 7, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-05", "mark_held_locks", "sysenter_do_call", 26, 1, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-06", "lock_acquire", "kernel_thread_helper", 23, 1, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-07", "__slab_alloc.isra.50.constprop.56", "sysenter_do_call", 14, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-08", "unwind_backtrace", "sys_write", 13, 1, 0, NULL, NULL);

  check("../../kerneloopses/gitlog-09", "unwind_backtrace", "cpu_idle", 11, 1, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-10", NULL, NULL, 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-11", "lockdep_rcu_suspicious", "out_of_memory", 12, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-12", "unwind_backtrace", "regulator_get_voltage", 6, 1, 0, NULL, NULL);
/*
  check("../../kerneloopses/gitlog-13", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-14", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-15", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-16", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-17", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-18", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-19", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-20", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-21", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-22", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-23", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-24", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-25", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-26", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-27", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-28", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-29", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-30", "", "", 0, 0, 0, NULL, NULL);
  check("../../kerneloopses/gitlog-31", "", "", 0, 0, 0, NULL, NULL);
*/

  check("../../kerneloopses/rhbz-827868", "warn_slowpath_common", "gs_change", 32, 0, 119, NULL, NULL);
  check("../../kerneloopses/rhbz-836206", "__might_sleep", "system_call_fastpath", 23, 0, 59, NULL, NULL);
  check("../../kerneloopses/rhbz-865695-0", "wdev_priv.part.8", "sysenter_do_call", 25, 3, 56, NULL, NULL);
  check("../../kerneloopses/rhbz-865695-2", "wdev_priv.part.8", "system_call_fastpath", 20, 2, 103, NULL, NULL);
  check("../../kerneloopses/rhbz-865695-2-notime", "wdev_priv.part.8", "system_call_fastpath", 20, 2, 103, NULL, NULL);

  check("../../kerneloopses/rhbz-1040900-s390x-1", "will_oops_init", NULL, 6, 2, 24, NULL, NULL);
  check("../../kerneloopses/rhbz-1040900-s390x-2", NULL, NULL, 17, 0, 2, NULL, NULL);
  check("../../kerneloopses/rhbz-1040900-ppc64-1", "eeh_dev_check_failure", "syscall_exit", 20, 0, 13, NULL, NULL);

  check("../../kerneloopses/github-102", "dump_stack", "kthread_create_on_node", 17, 6, 104, NULL, NULL);
  check("../../kerneloopses/github-73", "dump_stack", "common_interrupt", 33, 0, 100, "IRQ", "IRQ");
  check("../../kerneloopses/github-73-modified", "dump_stack", "common_interrupt", 33, 0, 100, "NMI", NULL);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/koops_stacktrace.at:89: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_koops_stacktrace_parse sr_koops_stacktrace_parse.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_stacktrace_parse sr_koops_stacktrace_parse.c $LIBS" "koops_stacktrace.at:89"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_stacktrace_parse sr_koops_stacktrace_parse.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_stacktrace.at:89"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/koops_stacktrace.at:89: ./sr_koops_stacktrace_parse"
at_fn_check_prepare_trace "koops_stacktrace.at:89"
( $at_check_trace; ./sr_koops_stacktrace_parse
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_stacktrace.at:89"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_73
#AT_START_74
at_fn_group_banner 74 'koops_stacktrace.at:256' \
  "sr_koops_stacktrace_to_json" "                    " 11
at_xfail=no
(
  $as_echo "74. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_koops_stacktrace_to_json.c <<'_ATEOF'

#include "stacktrace.h"
#include "koops/stacktrace.h"
#include "location.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  char *error_message;
  char *full_input = sr_file_to_string("../../kerneloopses/rhbz-827868-modified",
                                        &error_message);

  assert(full_input);
  char *input = full_input;

  struct sr_location location;
  sr_location_init(&location);
  struct sr_koops_stacktrace *stacktrace =
      sr_koops_stacktrace_parse(&input, &location);

  assert(stacktrace);
  assert(*input == '\0');
  free(full_input);

  char *json = sr_koops_stacktrace_to_json(stacktrace);
  puts(json);
  assert(0 == strcmp(json,
    "{   \"raw_oops\": \"[110417.280426] WARNING: at mm/page_alloc.c:2204 __alloc_pages_nodemask+0x231/0x8f0()\\n"
    "[110417.280429] Hardware name: Latitude E6420\\n"
    "[110417.280431] Modules linked in: vfat fat usb_storage authenc l2tp_ppp pppox ppp_generic slhc l2tp_netlink "
    "l2tp_core rmd160 crypto_null camellia lzo cast6 cast5 deflate zlib_deflate cts gcm ccm serpent_sse2_x86_64 "
    "serpent_generic blowfish_generic blowfish_x86_64 blowfish_common twofish_generic twofish_x86_64_3way lrw "
    "twofish_x86_64 twofish_common xcbc sha256_generic sha512_generic des_generic ah6 ah4 esp6 esp4 "
    "xfrm4_mode_beet xfrm4_tunnel tunnel4 xfrm4_mode_tunnel xfrm4_mode_transport xfrm6_mode_transport "
    "xfrm6_mode_ro xfrm6_mode_beet xfrm6_mode_tunnel ipcomp ipcomp6 xfrm_ipcomp xfrm6_tunnel tunnel6 af_key "
    "snd_usb_audio snd_usbmidi_lib snd_rawmidi sctp libcrc32c tcp_lp wacom fuse lockd rfcomm bnep "
    "snd_hda_codec_hdmi snd_hda_codec_idt binfmt_misc arc4 uvcvideo snd_hda_intel videobuf2_core videodev "
    "snd_hda_codec ppdev media dell_wmi videobuf2_vmalloc sparse_keymap videobuf2_memops dell_laptop snd_hwdep "
    "snd_seq uinput dcdbas snd_seq_device btusb bluetooth iwlwifi snd_pcm parport_pc \\n"
    "joydev parport snd_timer microcode mac80211 snd soundcore snd_page_alloc i2c_i801 cfg80211 iTCO_wdt "
    "iTCO_vendor_support rfkill e1000e sunrpc xts gf128mul dm_crypt sdhci_pci sdhci mmc_core wmi i915 "
    "drm_kms_helper drm i2c_algo_bit i2c_core video [last unloaded: scsi_wait_scan]\\n"
    "[110417.280525] Pid: 3, comm: ksoftirqd/0 Tainted: P    B D    O 3.3.7-1.fc16.x86_64 #1\\n"
    "[110417.280528] Call Trace:\\n"
    "[110417.280535]  [<ffffffff81057adf>] warn_slowpath_common+0x7f/0xc0\\n"
    "[110417.280539]  [<ffffffff81057b3a>] warn_slowpath_null+0x1a/0x20\\n"
    "[110417.280544]  [<ffffffff811296d1>] __alloc_pages_nodemask+0x231/0x8f0\\n"
    "[110417.280550]  [<ffffffff8151fd80>] ? ip_copy_metadata+0x1c0/0x1c0\\n"
    "[110417.280555]  [<ffffffff8151f860>] ? ip_forward_options+0x1f0/0x1f0\\n"
    "[110417.280559]  [<ffffffff81160a93>] alloc_pages_current+0xa3/0x110\\n"
    "[110417.280563]  [<ffffffff81125514>] __get_free_pages+0x14/0x50\\n"
    "[110417.280569]  [<ffffffff8116bb5f>] kmalloc_order_trace+0x3f/0xd0\\n"
    "[110417.280573]  [<ffffffff8116ca87>] __kmalloc+0x177/0x1a0\\n"
    "[110417.280578]  [<ffffffffa0642332>] ? pppol2tp_xmit+0x42/0x220 [l2tp_ppp]\\n"
    "[110417.280583]  [<ffffffff814db0a7>] pskb_expand_head+0x87/0x310\\n"
    "[110417.280588]  [<ffffffff8113dc59>] ? __mod_zone_page_state+0x49/0x50\\n"
    "[110417.280591]  [<ffffffff814da0f5>] ? kfree_skb+0x45/0xc0\\n"
    "[110417.280595]  [<ffffffffa06424dd>] pppol2tp_xmit+0x1ed/0x220 [l2tp_ppp]\\n"
    "[110417.280600]  [<ffffffffa062dd5b>] ppp_push+0x15b/0x650 [ppp_generic]\\n"
    "[110417.280604]  [<ffffffff814db264>] ? pskb_expand_head+0x244/0x310\\n"
    "[110417.280608]  [<ffffffff8112860b>] ? free_compound_page+0x1b/0x20\\n"
    "[110417.280612]  [<ffffffff8112d053>] ? __put_compound_page+0x23/0x30\\n"
    "[110417.280615]  [<ffffffff8112d1d5>] ? put_compound_page+0x125/0x1c0\\n"
    "[110417.280619]  [<ffffffffa062e89f>] ppp_xmit_process+0x46f/0x660 [ppp_generic]\\n"
    "[110417.280624]  [<ffffffffa062ebc8>] ppp_start_xmit+0x138/0x1d0 [ppp_generic]\\n"
    "[110417.280628]  [<ffffffff814e85b2>] dev_hard_start_xmit+0x332/0x6d0\\n"
    "[110417.280632]  [<ffffffff8150447a>] sch_direct_xmit+0xfa/0x1d0\\n"
    "[110417.280635]  [<ffffffff815045f6>] __qdisc_run+0xa6/0x130\\n"
    "[110417.280639]  [<ffffffff814e6883>] net_tx_action+0xe3/0x1f0\\n"
    "[110417.280643]  [<ffffffff8105f0c8>] __do_softirq+0xb8/0x230\\n"
    "[110417.280646]  [<ffffffff8105f2fa>] run_ksoftirqd+0xba/0x170\\n"
    "[110417.280649]  [<ffffffff8105f240>] ? __do_softirq+0x230/0x230\\n"
    "[110417.280654]  [<ffffffff81079da3>] kthread+0x93/0xa0\\n"
    "[110417.280658]  [<ffffffff815fd8e4>] kernel_thread_helper+0x4/0x10\\n"
    "[110417.280663]  [<ffffffff81079d10>] ? kthread_freezable_should_stop+0x70/0x70\\n"
    "[110417.280666]  [<ffffffff815fd8e0>] ? gs_change+0x13/0x13\\n\"\n"
    ",   \"taint_flags\": [ \"module_proprietary\"\n"
    "                   , \"page_release\"\n"
    "                   , \"died_recently\"\n"
    "                   , \"module_out_of_tree\" ]\n"
    ",   \"modules\":\n"
    "      [ \"vfat\"\n"
    "      , \"fat\"\n"
    "      , \"usb_storage\"\n"
    "      , \"authenc\"\n"
    "      , \"l2tp_ppp\"\n"
    "      , \"pppox\"\n"
    "      , \"ppp_generic\"\n"
    "      , \"slhc\"\n"
    "      , \"l2tp_netlink\"\n"
    "      , \"l2tp_core\"\n"
    "      , \"rmd160\"\n"
    "      , \"crypto_null\"\n"
    "      , \"camellia\"\n"
    "      , \"lzo\"\n"
    "      , \"cast6\"\n"
    "      , \"cast5\"\n"
    "      , \"deflate\"\n"
    "      , \"zlib_deflate\"\n"
    "      , \"cts\"\n"
    "      , \"gcm\"\n"
    "      , \"ccm\"\n"
    "      , \"serpent_sse2_x86_64\"\n"
    "      , \"serpent_generic\"\n"
    "      , \"blowfish_generic\"\n"
    "      , \"blowfish_x86_64\"\n"
    "      , \"blowfish_common\"\n"
    "      , \"twofish_generic\"\n"
    "      , \"twofish_x86_64_3way\"\n"
    "      , \"lrw\"\n"
    "      , \"twofish_x86_64\"\n"
    "      , \"twofish_common\"\n"
    "      , \"xcbc\"\n"
    "      , \"sha256_generic\"\n"
    "      , \"sha512_generic\"\n"
    "      , \"des_generic\"\n"
    "      , \"ah6\"\n"
    "      , \"ah4\"\n"
    "      , \"esp6\"\n"
    "      , \"esp4\"\n"
    "      , \"xfrm4_mode_beet\"\n"
    "      , \"xfrm4_tunnel\"\n"
    "      , \"tunnel4\"\n"
    "      , \"xfrm4_mode_tunnel\"\n"
    "      , \"xfrm4_mode_transport\"\n"
    "      , \"xfrm6_mode_transport\"\n"
    "      , \"xfrm6_mode_ro\"\n"
    "      , \"xfrm6_mode_beet\"\n"
    "      , \"xfrm6_mode_tunnel\"\n"
    "      , \"ipcomp\"\n"
    "      , \"ipcomp6\"\n"
    "      , \"xfrm_ipcomp\"\n"
    "      , \"xfrm6_tunnel\"\n"
    "      , \"tunnel6\"\n"
    "      , \"af_key\"\n"
    "      , \"snd_usb_audio\"\n"
    "      , \"snd_usbmidi_lib\"\n"
    "      , \"snd_rawmidi\"\n"
    "      , \"sctp\"\n"
    "      , \"libcrc32c\"\n"
    "      , \"tcp_lp\"\n"
    "      , \"wacom\"\n"
    "      , \"fuse\"\n"
    "      , \"lockd\"\n"
    "      , \"rfcomm\"\n"
    "      , \"bnep\"\n"
    "      , \"snd_hda_codec_hdmi\"\n"
    "      , \"snd_hda_codec_idt\"\n"
    "      , \"binfmt_misc\"\n"
    "      , \"arc4\"\n"
    "      , \"uvcvideo\"\n"
    "      , \"snd_hda_intel\"\n"
    "      , \"videobuf2_core\"\n"
    "      , \"videodev\"\n"
    "      , \"snd_hda_codec\"\n"
    "      , \"ppdev\"\n"
    "      , \"media\"\n"
    "      , \"dell_wmi\"\n"
    "      , \"videobuf2_vmalloc\"\n"
    "      , \"sparse_keymap\"\n"
    "      , \"videobuf2_memops\"\n"
    "      , \"dell_laptop\"\n"
    "      , \"snd_hwdep\"\n"
    "      , \"snd_seq\"\n"
    "      , \"uinput\"\n"
    "      , \"dcdbas\"\n"
    "      , \"snd_seq_device\"\n"
    "      , \"btusb\"\n"
    "      , \"bluetooth\"\n"
    "      , \"iwlwifi\"\n"
    "      , \"snd_pcm\"\n"
    "      , \"parport_pc\"\n"
    "      , \"joydev\"\n"
    "      , \"parport\"\n"
    "      , \"snd_timer\"\n"
    "      , \"microcode\"\n"
    "      , \"mac80211\"\n"
    "      , \"snd\"\n"
    "      , \"soundcore\"\n"
    "      , \"snd_page_alloc\"\n"
    "      , \"i2c_i801\"\n"
    "      , \"cfg80211\"\n"
    "      , \"iTCO_wdt\"\n"
    "      , \"iTCO_vendor_support\"\n"
    "      , \"rfkill\"\n"
    "      , \"e1000e\"\n"
    "      , \"sunrpc\"\n"
    "      , \"xts\"\n"
    "      , \"gf128mul\"\n"
    "      , \"dm_crypt\"\n"
    "      , \"sdhci_pci\"\n"
    "      , \"sdhci\"\n"
    "      , \"mmc_core\"\n"
    "      , \"wmi\"\n"
    "      , \"i915\"\n"
    "      , \"drm_kms_helper\"\n"
    "      , \"drm\"\n"
    "      , \"i2c_algo_bit\"\n"
    "      , \"i2c_core\"\n"
    "      , \"video\" ]\n"
    ",   \"frames\":\n"
    "      [ {   \"address\": 18446744071579204319\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"warn_slowpath_common\"\n"
    "        ,   \"function_offset\": 127\n"
    "        ,   \"function_length\": 192\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071579204410\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"warn_slowpath_null\"\n"
    "        ,   \"function_offset\": 26\n"
    "        ,   \"function_length\": 32\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071580063441\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"__alloc_pages_nodemask\"\n"
    "        ,   \"function_offset\": 561\n"
    "        ,   \"function_length\": 2288\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071584218496\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"ip_copy_metadata\"\n"
    "        ,   \"function_offset\": 448\n"
    "        ,   \"function_length\": 448\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071584217184\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"ip_forward_options\"\n"
    "        ,   \"function_offset\": 496\n"
    "        ,   \"function_length\": 496\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071580289683\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"alloc_pages_current\"\n"
    "        ,   \"function_offset\": 163\n"
    "        ,   \"function_length\": 272\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071580046612\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"__get_free_pages\"\n"
    "        ,   \"function_offset\": 20\n"
    "        ,   \"function_length\": 80\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071580334943\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"kmalloc_order_trace\"\n"
    "        ,   \"function_offset\": 63\n"
    "        ,   \"function_length\": 208\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071580338823\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"__kmalloc\"\n"
    "        ,   \"function_offset\": 375\n"
    "        ,   \"function_length\": 416\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744072105501490\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"pppol2tp_xmit\"\n"
    "        ,   \"function_offset\": 66\n"
    "        ,   \"function_length\": 544\n"
    "        ,   \"module_name\": \"l2tp_ppp\"\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071583936679\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"pskb_expand_head\"\n"
    "        ,   \"function_offset\": 135\n"
    "        ,   \"function_length\": 784\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071580146777\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"__mod_zone_page_state\"\n"
    "        ,   \"function_offset\": 73\n"
    "        ,   \"function_length\": 80\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071583932661\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"kfree_skb\"\n"
    "        ,   \"function_offset\": 69\n"
    "        ,   \"function_length\": 192\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744072105501917\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"pppol2tp_xmit\"\n"
    "        ,   \"function_offset\": 493\n"
    "        ,   \"function_length\": 544\n"
    "        ,   \"module_name\": \"l2tp_ppp\"\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744072105418075\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"ppp_push\"\n"
    "        ,   \"function_offset\": 347\n"
    "        ,   \"function_length\": 1616\n"
    "        ,   \"module_name\": \"ppp_generic\"\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071583937124\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"pskb_expand_head\"\n"
    "        ,   \"function_offset\": 580\n"
    "        ,   \"function_length\": 784\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071580059147\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"free_compound_page\"\n"
    "        ,   \"function_offset\": 27\n"
    "        ,   \"function_length\": 32\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071580078163\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"__put_compound_page\"\n"
    "        ,   \"function_offset\": 35\n"
    "        ,   \"function_length\": 48\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071580078549\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"put_compound_page\"\n"
    "        ,   \"function_offset\": 293\n"
    "        ,   \"function_length\": 448\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744072105420959\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"ppp_xmit_process\"\n"
    "        ,   \"function_offset\": 1135\n"
    "        ,   \"function_length\": 1632\n"
    "        ,   \"module_name\": \"ppp_generic\"\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744072105421768\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"ppp_start_xmit\"\n"
    "        ,   \"function_offset\": 312\n"
    "        ,   \"function_length\": 464\n"
    "        ,   \"module_name\": \"ppp_generic\"\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071583991218\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"dev_hard_start_xmit\"\n"
    "        ,   \"function_offset\": 818\n"
    "        ,   \"function_length\": 1744\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071584105594\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"sch_direct_xmit\"\n"
    "        ,   \"function_offset\": 250\n"
    "        ,   \"function_length\": 464\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071584105974\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"__qdisc_run\"\n"
    "        ,   \"function_offset\": 166\n"
    "        ,   \"function_length\": 304\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071583983747\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"net_tx_action\"\n"
    "        ,   \"function_offset\": 227\n"
    "        ,   \"function_length\": 496\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071579234504\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"__do_softirq\"\n"
    "        ,   \"function_offset\": 184\n"
    "        ,   \"function_length\": 560\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071579235066\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"run_ksoftirqd\"\n"
    "        ,   \"function_offset\": 186\n"
    "        ,   \"function_length\": 368\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071579234880\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"__do_softirq\"\n"
    "        ,   \"function_offset\": 560\n"
    "        ,   \"function_length\": 560\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071579344291\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"kthread\"\n"
    "        ,   \"function_offset\": 147\n"
    "        ,   \"function_length\": 160\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071585126628\n"
    "        ,   \"reliable\": true\n"
    "        ,   \"function_name\": \"kernel_thread_helper\"\n"
    "        ,   \"function_offset\": 4\n"
    "        ,   \"function_length\": 16\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071579344144\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"kthread_freezable_should_stop\"\n"
    "        ,   \"function_offset\": 112\n"
    "        ,   \"function_length\": 112\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        }\n"
    "      , {   \"address\": 18446744071585126624\n"
    "        ,   \"reliable\": false\n"
    "        ,   \"function_name\": \"gs_change\"\n"
    "        ,   \"function_offset\": 19\n"
    "        ,   \"function_length\": 19\n"
    "        ,   \"from_function_offset\": 0\n"
    "        ,   \"from_function_length\": 0\n"
    "        } ]\n"
    "}"));

  char *json2 = sr_stacktrace_to_json(stacktrace);
  assert(0 == strcmp(json, json2));
  free(json2);

  sr_koops_stacktrace_free(stacktrace);
  free(json);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/koops_stacktrace.at:256: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_koops_stacktrace_to_json sr_koops_stacktrace_to_json.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_stacktrace_to_json sr_koops_stacktrace_to_json.c $LIBS" "koops_stacktrace.at:256"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_koops_stacktrace_to_json sr_koops_stacktrace_to_json.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_stacktrace.at:256"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/koops_stacktrace.at:256: ./sr_koops_stacktrace_to_json"
at_fn_check_prepare_trace "koops_stacktrace.at:256"
( $at_check_trace; ./sr_koops_stacktrace_to_json
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/koops_stacktrace.at:256"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_74
#AT_START_75
at_fn_group_banner 75 'core_frame.at:9' \
  "sr_core_frame_dup" "                              " 12
at_xfail=no
(
  $as_echo "75. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_core_frame_dup.c <<'_ATEOF'

#include "core/frame.h"
#include "utils.h"
#include <assert.h>

int
main(void)
{
  struct sr_core_frame *frame1 = sr_core_frame_new();;
  frame1->address = 0xffffffff1;
  frame1->build_id = sr_strdup("aabbccddeeff1");
  frame1->build_id_offset = 2561;
  frame1->function_name = sr_strdup("test1");
  frame1->file_name = sr_strdup("executable1");
  frame1->fingerprint = sr_strdup("ab");

  struct sr_core_frame *frame0 = sr_core_frame_new();;
  frame0->address = 0xffffffff0;
  frame0->build_id = sr_strdup("aabbccddeeff0");
  frame0->build_id_offset = 2560;
  frame0->function_name = sr_strdup("test0");
  frame0->file_name = sr_strdup("executable0");
  frame0->fingerprint = sr_strdup("ab");
  frame0->next = frame1;

  /* Test the duplication without siblings. */
  struct sr_core_frame *frame = sr_core_frame_dup(frame0, false);
  assert(NULL == frame->next);
  assert(frame->build_id != frame0->build_id);
  assert(frame->function_name != frame0->function_name);
  assert(frame->file_name != frame0->file_name);
  assert(0 == sr_core_frame_cmp(frame, frame0));
  sr_core_frame_free(frame);

  /* Test the duplication with the siblings. */
  frame = sr_core_frame_dup(frame0, true);
  assert(frame->build_id != frame0->build_id);
  assert(frame->function_name != frame0->function_name);
  assert(frame->file_name != frame0->file_name);
  assert(0 == sr_core_frame_cmp(frame, frame0));
  assert(frame->next != frame1);
  assert(0 == sr_core_frame_cmp(frame->next, frame1));
  sr_core_frame_free(frame->next);
  sr_core_frame_free(frame);

  sr_core_frame_free(frame1);
  sr_core_frame_free(frame0);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/core_frame.at:9: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_core_frame_dup sr_core_frame_dup.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_frame_dup sr_core_frame_dup.c $LIBS" "core_frame.at:9"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_frame_dup sr_core_frame_dup.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_frame.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/core_frame.at:9: ./sr_core_frame_dup"
at_fn_check_prepare_trace "core_frame.at:9"
( $at_check_trace; ./sr_core_frame_dup
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_frame.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_75
#AT_START_76
at_fn_group_banner 76 'core_frame.at:65' \
  "sr_core_frame_to_json" "                          " 12
at_xfail=no
(
  $as_echo "76. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_core_frame_to_json.c <<'_ATEOF'

#include "core/frame.h"
#include "utils.h"
#include <assert.h>

int
main(void)
{
  struct sr_core_frame *frame = sr_core_frame_new();;
  frame->address = 0xffffffff1;
  frame->build_id = sr_strdup("aabbccddeeff1");
  frame->build_id_offset = 2561;
  frame->function_name = sr_strdup("test1");
  frame->file_name = sr_strdup("executable1");
  frame->fingerprint = sr_strdup("ab");

  char *json = sr_core_frame_to_json(frame);
  assert(0 == strcmp(json,
           "{   \"address\": 68719476721\n"
           ",   \"build_id\": \"aabbccddeeff1\"\n"
           ",   \"build_id_offset\": 2561\n"
           ",   \"function_name\": \"test1\"\n"
           ",   \"file_name\": \"executable1\"\n"
           ",   \"fingerprint\": \"ab\"\n"
           "}"));

  sr_core_frame_free(frame);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/core_frame.at:65: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_core_frame_to_json sr_core_frame_to_json.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_frame_to_json sr_core_frame_to_json.c $LIBS" "core_frame.at:65"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_frame_to_json sr_core_frame_to_json.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_frame.at:65"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/core_frame.at:65: ./sr_core_frame_to_json"
at_fn_check_prepare_trace "core_frame.at:65"
( $at_check_trace; ./sr_core_frame_to_json
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_frame.at:65"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_76
#AT_START_77
at_fn_group_banner 77 'core_frame.at:101' \
  "sr_core_frame_abstract_functions" "               " 12
at_xfail=no
(
  $as_echo "77. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_core_frame_abstract_functions.c <<'_ATEOF'

#include "core/frame.h"
#include "strbuf.h"
#include "frame.h"
#include <assert.h>

int
main(void)
{
  struct sr_core_frame *frame = sr_core_frame_new();;
  frame->address = 0xffffffff1;
  frame->build_id = sr_strdup("aabbccddeeff1");
  frame->build_id_offset = 2561;
  frame->function_name = sr_strdup("test1");
  frame->file_name = sr_strdup("executable1");
  frame->fingerprint = sr_strdup("ab");
  frame->next = 0xdeadbeef;

  assert(sr_frame_next((struct sr_frame*)frame) == (void*)0xdeadbeef);

  struct sr_strbuf *strbuf = sr_strbuf_new();
  sr_frame_append_to_str((struct sr_frame*)frame, strbuf);
  char *res = sr_strbuf_free_nobuf(strbuf);

  assert(0 == strcmp(res, "test1 in executable1"));
  free(res);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/core_frame.at:101: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_core_frame_abstract_functions sr_core_frame_abstract_functions.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_frame_abstract_functions sr_core_frame_abstract_functions.c $LIBS" "core_frame.at:101"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_frame_abstract_functions sr_core_frame_abstract_functions.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_frame.at:101"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/core_frame.at:101: ./sr_core_frame_abstract_functions"
at_fn_check_prepare_trace "core_frame.at:101"
( $at_check_trace; ./sr_core_frame_abstract_functions
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_frame.at:101"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_77
#AT_START_78
at_fn_group_banner 78 'core_thread.at:9' \
  "sr_core_thread_to_json" "                         " 13
at_xfail=no
(
  $as_echo "78. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_core_thread_to_json.c <<'_ATEOF'

#include "core/thread.h"
#include "core/frame.h"
#include "utils.h"
#include <assert.h>

int
main(void)
{
  struct sr_core_frame *frame1 = sr_core_frame_new();
  frame1->address = 0xffffffff0;
  frame1->build_id = sr_strdup("aabbccddeeff0");
  frame1->build_id_offset = 2560;
  frame1->function_name = sr_strdup("test0");
  frame1->file_name = sr_strdup("executable0");

  struct sr_core_frame *frame0 = sr_core_frame_new();;
  frame0->address = 0xffffffff1;
  frame0->build_id = sr_strdup("aabbccddeeff1");
  frame0->build_id_offset = 2561;
  frame0->function_name = sr_strdup("test1");
  frame0->file_name = sr_strdup("executable1");
  frame0->fingerprint = sr_strdup("ab");
  frame0->next = frame1;

  struct sr_core_thread *thread = sr_core_thread_new();
  thread->frames = frame0;

  char *json = sr_core_thread_to_json(thread, false);
  puts(json);
  assert(0 == strcmp(json,
           "{   \"frames\":\n"
           "      [ {   \"address\": 68719476721\n"
           "        ,   \"build_id\": \"aabbccddeeff1\"\n"
           "        ,   \"build_id_offset\": 2561\n"
           "        ,   \"function_name\": \"test1\"\n"
           "        ,   \"file_name\": \"executable1\"\n"
           "        ,   \"fingerprint\": \"ab\"\n"
           "        }\n"
           "      , {   \"address\": 68719476720\n"
           "        ,   \"build_id\": \"aabbccddeeff0\"\n"
           "        ,   \"build_id_offset\": 2560\n"
           "        ,   \"function_name\": \"test0\"\n"
           "        ,   \"file_name\": \"executable0\"\n"
           "        } ]\n"
           "}"));

  free(json);
  sr_core_thread_free(thread);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/core_thread.at:9: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_core_thread_to_json sr_core_thread_to_json.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_thread_to_json sr_core_thread_to_json.c $LIBS" "core_thread.at:9"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_thread_to_json sr_core_thread_to_json.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_thread.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/core_thread.at:9: ./sr_core_thread_to_json"
at_fn_check_prepare_trace "core_thread.at:9"
( $at_check_trace; ./sr_core_thread_to_json
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_thread.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_78
#AT_START_79
at_fn_group_banner 79 'core_thread.at:67' \
  "sr_core_thread_abstract_functions" "              " 13
at_xfail=no
(
  $as_echo "79. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_core_thread_abstract_functions.c <<'_ATEOF'

#include "core/thread.h"
#include "core/frame.h"
#include "utils.h"
#include "thread.h"
#include <assert.h>

int
main(void)
{
  struct sr_core_frame *frame1 = sr_core_frame_new();
  frame1->address = 0xffffffff0;
  frame1->build_id = sr_strdup("aabbccddeeff0");
  frame1->build_id_offset = 2560;
  frame1->function_name = sr_strdup("test0");
  frame1->file_name = sr_strdup("executable0");

  struct sr_core_frame *frame0 = sr_core_frame_new();;
  frame0->address = 0xffffffff1;
  frame0->build_id = sr_strdup("aabbccddeeff1");
  frame0->build_id_offset = 2561;
  frame0->function_name = sr_strdup("test1");
  frame0->file_name = sr_strdup("executable1");
  frame0->fingerprint = sr_strdup("ab");
  frame0->next = frame1;

  struct sr_core_thread *thread = sr_core_thread_new();
  thread->frames = frame0;

  assert(sr_thread_frames((struct sr_thread*) thread) == thread->frames);
  assert(sr_thread_next((struct sr_thread*) thread) == thread->next);
  assert(sr_thread_frame_count((struct sr_thread*) thread) == 2);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/core_thread.at:67: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_core_thread_abstract_functions sr_core_thread_abstract_functions.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_thread_abstract_functions sr_core_thread_abstract_functions.c $LIBS" "core_thread.at:67"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_thread_abstract_functions sr_core_thread_abstract_functions.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_thread.at:67"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/core_thread.at:67: ./sr_core_thread_abstract_functions"
at_fn_check_prepare_trace "core_thread.at:67"
( $at_check_trace; ./sr_core_thread_abstract_functions
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_thread.at:67"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_79
#AT_START_80
at_fn_group_banner 80 'core_stacktrace.at:9' \
  "sr_core_stacktrace_to_json" "                     " 14
at_xfail=no
(
  $as_echo "80. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_core_stacktrace_to_json.c <<'_ATEOF'

#include "stacktrace.h"
#include "core/stacktrace.h"
#include "core/thread.h"
#include "core/frame.h"
#include "utils.h"
#include <assert.h>
#include <signal.h>

int
main(void)
{
  struct sr_core_frame *frame1 = sr_core_frame_new();
  frame1->address = 0xffffffff0;
  frame1->build_id = sr_strdup("aabbccddeeff0");
  frame1->build_id_offset = 2560;
  frame1->function_name = sr_strdup("test0");
  frame1->file_name = sr_strdup("executable0");

  struct sr_core_frame *frame0 = sr_core_frame_new();;
  frame0->address = 0xffffffff1;
  frame0->build_id = sr_strdup("aabbccddeeff1");
  frame0->build_id_offset = 2561;
  frame0->function_name = sr_strdup("test1");
  frame0->file_name = sr_strdup("executable1");
  frame0->fingerprint = sr_strdup("ab");
  frame0->next = frame1;

  struct sr_core_thread *thread1 = sr_core_thread_new();
  thread1->frames = frame0;

  struct sr_core_frame *frame3 = sr_core_frame_new();
  frame3->address = 0xffffffff3;
  frame3->build_id = sr_strdup("aabbccddeeff3");
  frame3->build_id_offset = 2563;
  frame3->function_name = sr_strdup("test3");
  frame3->file_name = sr_strdup("executable3");

  struct sr_core_frame *frame2 = sr_core_frame_new();;
  frame2->address = 0xffffffff2;
  frame2->build_id = sr_strdup("aabbccddeeff2");
  frame2->build_id_offset = 2562;
  frame2->function_name = sr_strdup("test2");
  frame2->file_name = sr_strdup("executable2");
  frame2->fingerprint = sr_strdup("ab");
  frame2->next = frame3;

  struct sr_core_thread *thread0 = sr_core_thread_new();
  thread0->frames = frame2;
  thread0->next = thread1;

  struct sr_core_stacktrace *stacktrace = sr_core_stacktrace_new();
  stacktrace->signal = SIGKILL;
  stacktrace->crash_thread = thread1;
  stacktrace->threads = thread0;

  char *reason = sr_core_stacktrace_get_reason(stacktrace);
  assert(reason);
  free(reason);

  reason = sr_stacktrace_get_reason((struct sr_stacktrace*) stacktrace);
  assert(reason);
  free(reason);

  char *json = sr_core_stacktrace_to_json(stacktrace);
  puts(json);
  assert(0 == strcmp(json,
            "{   \"signal\": 9\n"
            ",   \"stacktrace\":\n"
            "      [ {   \"frames\":\n"
            "              [ {   \"address\": 68719476722\n"
            "                ,   \"build_id\": \"aabbccddeeff2\"\n"
            "                ,   \"build_id_offset\": 2562\n"
            "                ,   \"function_name\": \"test2\"\n"
            "                ,   \"file_name\": \"executable2\"\n"
            "                ,   \"fingerprint\": \"ab\"\n"
            "                }\n"
            "              , {   \"address\": 68719476723\n"
            "                ,   \"build_id\": \"aabbccddeeff3\"\n"
            "                ,   \"build_id_offset\": 2563\n"
            "                ,   \"function_name\": \"test3\"\n"
            "                ,   \"file_name\": \"executable3\"\n"
            "                } ]\n"
            "        }\n"
            "      , {   \"crash_thread\": true\n"
            "        ,   \"frames\":\n"
            "              [ {   \"address\": 68719476721\n"
            "                ,   \"build_id\": \"aabbccddeeff1\"\n"
            "                ,   \"build_id_offset\": 2561\n"
            "                ,   \"function_name\": \"test1\"\n"
            "                ,   \"file_name\": \"executable1\"\n"
            "                ,   \"fingerprint\": \"ab\"\n"
            "                }\n"
            "              , {   \"address\": 68719476720\n"
            "                ,   \"build_id\": \"aabbccddeeff0\"\n"
            "                ,   \"build_id_offset\": 2560\n"
            "                ,   \"function_name\": \"test0\"\n"
            "                ,   \"file_name\": \"executable0\"\n"
            "                } ]\n"
            "        } ]\n"
            "}"));

  char *json2 = sr_stacktrace_to_json((struct sr_stacktrace*) stacktrace);
  assert(0 == strcmp(json, json2));

  sr_core_stacktrace_free(stacktrace);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/core_stacktrace.at:9: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_core_stacktrace_to_json sr_core_stacktrace_to_json.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_stacktrace_to_json sr_core_stacktrace_to_json.c $LIBS" "core_stacktrace.at:9"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_stacktrace_to_json sr_core_stacktrace_to_json.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_stacktrace.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/core_stacktrace.at:9: ./sr_core_stacktrace_to_json"
at_fn_check_prepare_trace "core_stacktrace.at:9"
( $at_check_trace; ./sr_core_stacktrace_to_json
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_stacktrace.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_80
#AT_START_81
at_fn_group_banner 81 'core_stacktrace.at:124' \
  "sr_core_stacktrace_from_json" "                   " 14
at_xfail=no
(
  $as_echo "81. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_core_stacktrace_from_json.c <<'_ATEOF'

#include "stacktrace.h"
#include "core/stacktrace.h"
#include "core/thread.h"
#include "core/frame.h"
#include "utils.h"
#include "report_type.h"
#include <assert.h>
#include <signal.h>

void
check(struct sr_core_stacktrace *stacktrace)
{
  assert(stacktrace);
  assert(stacktrace->signal == SIGABRT);
  assert(stacktrace->executable);
  assert(0 == strcmp(stacktrace->executable, "/usr/bin/will_abort"));
  assert(stacktrace->threads);

  assert(stacktrace->threads->next);
  assert(stacktrace->crash_thread == stacktrace->threads->next);

  struct sr_core_frame *f = stacktrace->threads->frames;
  assert(f->address == 87654);
  assert(0 == strcmp(f->build_id, "92ebaf825e4f492952c45189cb9ffc6541f8599b"));
  assert(f->build_id_offset == 42);
  assert(0 == strcmp(f->function_name, "fake_frame_for_the_sake_of_multiple_threads"));
  assert(0 == strcmp(f->file_name, "/usr/bin/will_abort"));
  assert(f->fingerprint == NULL);

  f = f->next;
  assert(f->address == 98346);
  assert(0 == strcmp(f->build_id, "92ebaf825e4f492952c45189cb9ffc6541f8599b"));
  assert(f->build_id_offset == 10734);
  assert(0 == strcmp(f->function_name, "fake_function"));
  assert(0 == strcmp(f->file_name, "/usr/bin/will_abort"));
  assert(f->fingerprint == NULL);

  f = stacktrace->threads->next->frames;
  assert(f->address == 237190207797);
  assert(0 == strcmp(f->build_id, "cc10c72da62c93033e227ffbe2670f2c4fbbde1a"));
  assert(f->build_id_offset == 219445);
  assert(0 == strcmp(f->function_name, "raise"));
  assert(0 == strcmp(f->file_name, "/usr/lib64/libc-2.15.so"));
  assert(0 == strcmp(f->fingerprint, "f33186a4c862fb0751bca60701f553b829210477"));

  f = f->next->next->next;
  assert(f->address == 237190125365);
  assert(0 == strcmp(f->build_id, "cc10c72da62c93033e227ffbe2670f2c4fbbde1a"));
  assert(f->build_id_offset == 137013);
  assert(0 == strcmp(f->function_name, "__libc_start_main"));
  assert(0 == strcmp(f->file_name, "/usr/lib64/libc-2.15.so"));
  assert(0 == strcmp(f->fingerprint, "5ff4a3d3743fdde711c49033d1e01784477e57fb"));
}

int
main(void)
{
  char *error_message;
  char *full_input = sr_file_to_string("../../json_files/core-01", &error_message);
  assert(full_input);

  struct sr_core_stacktrace *stacktrace = sr_core_stacktrace_from_json_text(full_input,
     &error_message);
  check(stacktrace);
  sr_core_stacktrace_free(stacktrace);

  stacktrace = (struct sr_core_stacktrace*) sr_stacktrace_parse(SR_REPORT_CORE,
     full_input, &error_message);
  check(stacktrace);
  sr_stacktrace_free((struct sr_stacktrace*) stacktrace);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/core_stacktrace.at:124: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_core_stacktrace_from_json sr_core_stacktrace_from_json.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_stacktrace_from_json sr_core_stacktrace_from_json.c $LIBS" "core_stacktrace.at:124"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_core_stacktrace_from_json sr_core_stacktrace_from_json.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_stacktrace.at:124"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/core_stacktrace.at:124: ./sr_core_stacktrace_from_json"
at_fn_check_prepare_trace "core_stacktrace.at:124"
( $at_check_trace; ./sr_core_stacktrace_from_json
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/core_stacktrace.at:124"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_81
#AT_START_82
at_fn_group_banner 82 'operating_system.at:8' \
  "sr_operating_system_parse_etc_system_release" "   " 15
at_xfail=no
(
  $as_echo "82. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_operating_system_parse_etc_system_release.c <<'_ATEOF'

#include "operating_system.h"
#include "utils.h"
#include <stdio.h>
#include <assert.h>

void check(const char *etc_system_release,
           const char *expected_name,
           const char *expected_version)
{
    printf("Testing %s.\n", etc_system_release);
    char *name, *version;
    bool success = sr_operating_system_parse_etc_system_release(
        etc_system_release,
        &name,
        &version);

    assert(success);
    assert(0 == strcmp(name, expected_name));
    assert(0 == strcmp(version, expected_version));
    free(name);
    free(version);
}

int
main(void)
{
    check("Fedora release 16 (Verne)", "fedora", "16");
    check("Red Hat Enterprise Linux release 6.2", "red hat enterprise linux", "6.2");
    return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/operating_system.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_operating_system_parse_etc_system_release sr_operating_system_parse_etc_system_release.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_operating_system_parse_etc_system_release sr_operating_system_parse_etc_system_release.c $LIBS" "operating_system.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_operating_system_parse_etc_system_release sr_operating_system_parse_etc_system_release.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/operating_system.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/operating_system.at:8: ./sr_operating_system_parse_etc_system_release"
at_fn_check_prepare_trace "operating_system.at:8"
( $at_check_trace; ./sr_operating_system_parse_etc_system_release
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/operating_system.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_82
#AT_START_83
at_fn_group_banner 83 'operating_system.at:45' \
  "sr_operating_system_parse_etc_os_release" "       " 15
at_xfail=no
(
  $as_echo "83. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_operating_system_parse_etc_os_release.c <<'_ATEOF'

#include "operating_system.h"
#include "utils.h"
#include <stdio.h>
#include <assert.h>

void check(const char *etc_os_release,
           const char *expected_name,
           const char *expected_version)
{
    struct sr_operating_system *os = sr_operating_system_new();
    bool success = sr_operating_system_parse_etc_os_release(
        etc_os_release, os);

    assert(success);
    assert(0 == strcmp(os->name, expected_name));
    assert(0 == strcmp(os->version, expected_version));
    sr_operating_system_free(os);
}

int
main(void)
{
    char *f19 =
"NAME=Fedora\n"
"VERSION=\"19 (Schrödinger’s Cat)\"\n"
"ID=fedora\n"
"VERSION_ID=19\n"
"PRETTY_NAME=\"Fedora 19 (Schrödinger’s Cat)\"\n"
"ANSI_COLOR=\"0;34\"\n"
"CPE_NAME=\"cpe:/o:fedoraproject:fedora:19\"\n";

    char *raw =
"NAME=Fedora\n"
"VERSION=\"20 (Rawhide)\"\n"
"ID=fedora\n"
"VERSION_ID=20\n"
"PRETTY_NAME=\"Fedora 20 (Rawhide)\"\n"
"ANSI_COLOR=\"0;34\"\n"
"CPE_NAME=\"cpe:/o:fedoraproject:fedora:20\"\n"
"REDHAT_BUGZILLA_PRODUCT=\"Fedora\"\n"
"REDHAT_BUGZILLA_PRODUCT_VERSION=Rawhide\n"
"REDHAT_SUPPORT_PRODUCT=\"Fedora\"\n"
"REDHAT_SUPPORT_PRODUCT_VERSION=Rawhide\n";

    char *el7 =
"NAME=\"Red Hat Enterprise Linux Workstation\"\n"
"VERSION=\"7.0 (Codename)\"\n"
"ID=\"rhel\"\n"
"VERSION_ID=\"7.0\"\n"
"PRETTY_NAME=\"Red Hat Enterprise Linux Workstation 7.0 (Codename)\"\n"
"ANSI_COLOR=\"0;31\"\n"
"CPE_NAME=\"cpe:/o:redhat:enterprise_linux:7.0:beta:workstation\"\n"
"\n"
"REDHAT_BUGZILLA_PRODUCT=\"Red Hat Enterprise Linux 7\"\n"
"REDHAT_BUGZILLA_PRODUCT_VERSION=7.0\n"
"REDHAT_SUPPORT_PRODUCT=\"Red Hat Enterprise Linux\"\n"
"REDHAT_SUPPORT_PRODUCT_VERSION=7.0\n";

    check(f19, "fedora", "19");
    check(raw, "fedora", "rawhide");
    check(el7, "rhel", "7.0");

    return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/operating_system.at:45: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_operating_system_parse_etc_os_release sr_operating_system_parse_etc_os_release.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_operating_system_parse_etc_os_release sr_operating_system_parse_etc_os_release.c $LIBS" "operating_system.at:45"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_operating_system_parse_etc_os_release sr_operating_system_parse_etc_os_release.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/operating_system.at:45"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/operating_system.at:45: ./sr_operating_system_parse_etc_os_release"
at_fn_check_prepare_trace "operating_system.at:45"
( $at_check_trace; ./sr_operating_system_parse_etc_os_release
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/operating_system.at:45"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_83
#AT_START_84
at_fn_group_banner 84 'normalize.at:47' \
  "sr_normalize_gdb_thread_removes_zeroes" "         " 16
at_xfail=no
(
  $as_echo "84. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_normalize_gdb_thread_removes_zeroes.c <<'_ATEOF'

#include "normalize.h"
#include "gdb/frame.h"
#include "gdb/thread.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  struct sr_gdb_frame *frame2 = sr_gdb_frame_new();
  frame2->function_name = sr_strdup("??");
  frame2->number = 2;
  frame2->address = 0x0000;

  struct sr_gdb_frame *frame1 = sr_gdb_frame_new();
  frame1->function_name = sr_strdup("write_to_temp_file");
  frame1->number = 1;
  frame1->source_file = sr_strdup("gfileutils.c");
  frame1->source_line = 980;
  frame1->address = 0x322160e7fdULL;
  frame1->next = frame2;

  struct sr_gdb_frame *frame0 = sr_gdb_frame_new();
  frame0->function_name = sr_strdup("??");
  frame0->number = 0;
  frame0->address = 0x0000;
  frame0->next = frame1;

  struct sr_gdb_thread thread;
  sr_gdb_thread_init(&thread);
  thread.number = 0;
  thread.frames = frame0;

  sr_normalize_gdb_thread(&thread);
  assert(thread.frames == frame1);
  assert(thread.frames->next == NULL);

  sr_gdb_frame_free(frame1);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/normalize.at:47: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_normalize_gdb_thread_removes_zeroes sr_normalize_gdb_thread_removes_zeroes.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_normalize_gdb_thread_removes_zeroes sr_normalize_gdb_thread_removes_zeroes.c $LIBS" "normalize.at:47"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_normalize_gdb_thread_removes_zeroes sr_normalize_gdb_thread_removes_zeroes.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/normalize.at:47"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/normalize.at:47: ./sr_normalize_gdb_thread_removes_zeroes"
at_fn_check_prepare_trace "normalize.at:47"
( $at_check_trace; ./sr_normalize_gdb_thread_removes_zeroes
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/normalize.at:47"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_84
#AT_START_85
at_fn_group_banner 85 'normalize.at:92' \
  "sr_normalize_gdb_paired_unknown_function_names" " " 16
at_xfail=no
(
  $as_echo "85. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_normalize_gdb_paired_unknown_function_names.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include "normalize.h"
#include <stdlib.h>
#include <assert.h>

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}


int
main()
{
  struct sr_gdb_thread *threads[6];
  struct sr_gdb_frame *frame;
  threads[0] = create_thread(5, "aa", "??", "??", "??", "??");
  threads[1] = create_thread(5, "bb", "aa", "??", "??", "??");
  threads[2] = create_thread(5, "aa", "??", "??", "??", "??");
  threads[3] = create_thread(5, "bb", "aa", "??", "??", "??");

  threads[4] = sr_gdb_thread_dup(threads[0], false);
  threads[5] = sr_gdb_thread_dup(threads[1], false);
  sr_normalize_gdb_paired_unknown_function_names(threads[4], threads[5]);
  assert(!sr_gdb_thread_cmp(threads[2], threads[4]));
  assert(!sr_gdb_thread_cmp(threads[3], threads[5]));

  threads[4] = sr_gdb_thread_dup(threads[0], false);
  threads[5] = sr_gdb_thread_dup(threads[1], false);
  sr_normalize_gdb_paired_unknown_function_names(threads[5], threads[4]);
  assert(!sr_gdb_thread_cmp(threads[2], threads[4]));
  assert(!sr_gdb_thread_cmp(threads[3], threads[5]));

  threads[0] = create_thread(5, "aa", "??", "cc", "cc", "??");
  threads[1] = create_thread(5, "bb", "aa", "??", "cc", "??");
  threads[2] = create_thread(5, "aa", "__unknown_function_0", "cc", "cc", "__unknown_function_1");
  threads[3] = create_thread(5, "bb", "aa","__unknown_function_0", "cc", "__unknown_function_1");

  threads[4] = sr_gdb_thread_dup(threads[0], false);
  threads[5] = sr_gdb_thread_dup(threads[1], false);
  sr_normalize_gdb_paired_unknown_function_names(threads[4], threads[5]);
  assert(!sr_gdb_thread_cmp(threads[2], threads[4]));
  assert(!sr_gdb_thread_cmp(threads[3], threads[5]));

  threads[0] = create_thread(5, "aa", "??", "cc", "??", "dd");
  threads[1] = create_thread(5, "bb", "??", "cc", "??", "dd");
  threads[2] = create_thread(5, "aa", "??", "cc", "__unknown_function_0", "dd");
  threads[3] = create_thread(5, "bb", "??", "cc", "__unknown_function_0", "dd");

  threads[4] = sr_gdb_thread_dup(threads[0], false);
  threads[5] = sr_gdb_thread_dup(threads[1], false);
  sr_normalize_gdb_paired_unknown_function_names(threads[4], threads[5]);
  assert(!sr_gdb_thread_cmp(threads[2], threads[4]));
  assert(!sr_gdb_thread_cmp(threads[3], threads[5]));

  threads[0] = create_thread(5, "aa", "cc", "??", "??", "??");
  threads[1] = create_thread(5, "bb", "??", "??", "??", "??");
  threads[2] = create_thread(5, "aa", "cc", "??", "??", "??");
  threads[3] = create_thread(5, "bb", "??", "??", "??", "??");

  threads[4] = sr_gdb_thread_dup(threads[0], false);
  threads[5] = sr_gdb_thread_dup(threads[1], false);
  sr_normalize_gdb_paired_unknown_function_names(threads[4], threads[5]);
  assert(!sr_gdb_thread_cmp(threads[2], threads[4]));
  assert(!sr_gdb_thread_cmp(threads[3], threads[5]));

  threads[4] = sr_gdb_thread_dup(threads[0], false);
  threads[5] = sr_gdb_thread_dup(threads[1], false);
  sr_normalize_gdb_paired_unknown_function_names(threads[5], threads[4]);
  assert(!sr_gdb_thread_cmp(threads[2], threads[4]));
  assert(!sr_gdb_thread_cmp(threads[3], threads[5]));

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/normalize.at:92: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_normalize_gdb_paired_unknown_function_names sr_normalize_gdb_paired_unknown_function_names.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_normalize_gdb_paired_unknown_function_names sr_normalize_gdb_paired_unknown_function_names.c $LIBS" "normalize.at:92"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_normalize_gdb_paired_unknown_function_names sr_normalize_gdb_paired_unknown_function_names.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/normalize.at:92"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/normalize.at:92: ./sr_normalize_gdb_paired_unknown_function_names"
at_fn_check_prepare_trace "normalize.at:92"
( $at_check_trace; ./sr_normalize_gdb_paired_unknown_function_names
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/normalize.at:92"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_85
#AT_START_86
at_fn_group_banner 86 'normalize.at:166' \
  "sr_normalize_gdb_thread_jvm_frames" "             " 16
at_xfail=no
(
  $as_echo "86. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_normalize_gdb_thread_jvm_frames.c <<'_ATEOF'

#include "normalize.h"
#include "gdb/frame.h"
#include "gdb/thread.h"
#include "utils.h"
#include <assert.h>
#include <stdlib.h>

int
main(void)
{
  struct sr_gdb_frame *frame3 = sr_gdb_frame_new();
  frame3->function_name = sr_strdup("jthread_map_push");
  frame3->number = 3;
  frame3->source_file = sr_strdup("jthread_map.c");
  frame3->source_line = 110;
  frame3->address = 0x7fda9a03f920ULL;
  frame3->next = NULL;

  struct sr_gdb_frame *frame2 = sr_gdb_frame_new();
  frame2->function_name = sr_strdup("JVM_handle_linux_signal");
  frame2->number = 2;
  frame2->source_file = sr_strdup("os_linux_x86.cpp");
  frame2->source_line = 531;
  frame2->address = 0x7fda9af3106fULL;
  frame2->next = frame3;

  struct sr_gdb_frame *frame1 = sr_gdb_frame_new();
  frame1->function_name = sr_strdup("VMError::report_and_die");
  frame1->number = 1;
  frame1->source_file = sr_strdup("vmError.cpp");
  frame1->source_line = 1053;
  frame1->address = 0x7fda9b0a83efULL;
  frame1->next = frame2;

  struct sr_gdb_frame *frame0 = sr_gdb_frame_new();
  frame0->function_name = sr_strdup("os::abort");
  frame0->number = 0;
  frame0->source_file = sr_strdup("os_linux.cpp");
  frame0->source_line = 1594;
  frame0->address = 0x7fda9af29259ULL;
  frame0->next = frame1;

  struct sr_gdb_thread thread;
  sr_gdb_thread_init(&thread);
  thread.number = 0;
  thread.frames = frame0;

  sr_normalize_gdb_thread(&thread);
  sr_normalize_gdb_thread(&thread);
  assert(thread.frames != frame0);
  assert(thread.frames != frame1);
  assert(thread.frames != frame2);
  assert(thread.frames == frame3);
  assert(thread.frames->next == NULL);

  sr_gdb_frame_free(frame3);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/normalize.at:166: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_normalize_gdb_thread_jvm_frames sr_normalize_gdb_thread_jvm_frames.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_normalize_gdb_thread_jvm_frames sr_normalize_gdb_thread_jvm_frames.c $LIBS" "normalize.at:166"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_normalize_gdb_thread_jvm_frames sr_normalize_gdb_thread_jvm_frames.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/normalize.at:166"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/normalize.at:166: ./sr_normalize_gdb_thread_jvm_frames"
at_fn_check_prepare_trace "normalize.at:166"
( $at_check_trace; ./sr_normalize_gdb_thread_jvm_frames
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/normalize.at:166"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_86
#AT_START_87
at_fn_group_banner 87 'metrics.at:48' \
  "metrics_all_one_thread_empty" "                   " 17
at_xfail=no
(
  $as_echo "87. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_all_one_thread_empty.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(0);
  struct sr_gdb_thread *thread2 = create_thread(3, "??", "ds", "main");
  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);
  assert(is_dist_equal(0.0, sr_distance(SR_DISTANCE_JARO_WINKLER, thread1, thread2)));
  assert(is_dist_equal(1.0, sr_distance(SR_DISTANCE_JACCARD, thread1, thread2)));
  assert(is_dist_equal(1.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:48: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_all_one_thread_empty metrics_all_one_thread_empty.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_one_thread_empty metrics_all_one_thread_empty.c $LIBS" "metrics.at:48"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_one_thread_empty metrics_all_one_thread_empty.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:48"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:48: ./metrics_all_one_thread_empty"
at_fn_check_prepare_trace "metrics.at:48"
( $at_check_trace; ./metrics_all_one_thread_empty
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:48"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_87
#AT_START_88
at_fn_group_banner 88 'metrics.at:65' \
  "metrics_all_both_threads_empty" "                 " 17
at_xfail=no
(
  $as_echo "88. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_all_both_threads_empty.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(0);
  struct sr_gdb_thread *thread2 = create_thread(0);
  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);
  assert(is_dist_equal(1.0, sr_distance(SR_DISTANCE_JARO_WINKLER, thread1, thread2)));
  assert(is_dist_equal(0.0, sr_distance(SR_DISTANCE_JACCARD, thread1, thread2)));
  assert(is_dist_equal(0.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:65: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_all_both_threads_empty metrics_all_both_threads_empty.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_threads_empty metrics_all_both_threads_empty.c $LIBS" "metrics.at:65"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_threads_empty metrics_all_both_threads_empty.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:65"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:65: ./metrics_all_both_threads_empty"
at_fn_check_prepare_trace "metrics.at:65"
( $at_check_trace; ./metrics_all_both_threads_empty
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:65"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_88
#AT_START_89
at_fn_group_banner 89 'metrics.at:82' \
  "metrics_all_both_starting_??_levendistance3_a" "  " 17
at_xfail=no
(
  $as_echo "89. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_all_both_starting_??_levendistance3_a.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(2, "??", "sd");
  struct sr_gdb_thread *thread2 = create_thread(3, "??", "ds", "main");
  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);
  assert(is_dist_equal(0.0, sr_distance(SR_DISTANCE_JARO_WINKLER, thread1, thread2)));
  assert(is_dist_equal(1.0, sr_distance(SR_DISTANCE_JACCARD, thread1, thread2)));
  assert(is_dist_equal(1.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:82: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_all_both_starting_??_levendistance3_a metrics_all_both_starting_??_levendistance3_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_starting_??_levendistance3_a metrics_all_both_starting_??_levendistance3_a.c $LIBS" "metrics.at:82"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_starting_??_levendistance3_a metrics_all_both_starting_??_levendistance3_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:82"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:82: ./metrics_all_both_starting_??_levendistance3_a"
at_fn_check_prepare_trace "metrics.at:82"
( $at_check_trace; ./metrics_all_both_starting_??_levendistance3_a
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:82"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_89
#AT_START_90
at_fn_group_banner 90 'metrics.at:99' \
  "metrics_all_both_starting_??_levendistance3_b" "  " 17
at_xfail=no
(
  $as_echo "90. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_all_both_starting_??_levendistance3_b.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(1, "??");
  struct sr_gdb_thread *thread2 = create_thread(3, "??", "ds", "main");
  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);
  assert(is_dist_equal(0.0, sr_distance(SR_DISTANCE_JARO_WINKLER, thread1, thread2)));
  assert(is_dist_equal(1.0, sr_distance(SR_DISTANCE_JACCARD, thread1, thread2)));
  assert(is_dist_equal(1.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:99: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_all_both_starting_??_levendistance3_b metrics_all_both_starting_??_levendistance3_b.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_starting_??_levendistance3_b metrics_all_both_starting_??_levendistance3_b.c $LIBS" "metrics.at:99"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_all_both_starting_??_levendistance3_b metrics_all_both_starting_??_levendistance3_b.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:99"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:99: ./metrics_all_both_starting_??_levendistance3_b"
at_fn_check_prepare_trace "metrics.at:99"
( $at_check_trace; ./metrics_all_both_starting_??_levendistance3_b
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:99"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_90
#AT_START_91
at_fn_group_banner 91 'metrics.at:116' \
  "metrics_levenshtein_random_??_levendistance0_a" " " 17
at_xfail=no
(
  $as_echo "91. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_levendistance0_a.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(3, "??", "ds", "main");
  struct sr_gdb_thread *thread2 = create_thread(3, "??", "ds", "main");
  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);
  assert(is_dist_equal(0.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:116: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_levendistance0_a metrics_levenshtein_random_??_levendistance0_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_levendistance0_a metrics_levenshtein_random_??_levendistance0_a.c $LIBS" "metrics.at:116"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_levendistance0_a metrics_levenshtein_random_??_levendistance0_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:116"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:116: ./metrics_levenshtein_random_??_levendistance0_a"
at_fn_check_prepare_trace "metrics.at:116"
( $at_check_trace; ./metrics_levenshtein_random_??_levendistance0_a
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:116"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_91
#AT_START_92
at_fn_group_banner 92 'metrics.at:131' \
  "metrics_levenshtein_random_??_levendistance0_b" " " 17
at_xfail=no
(
  $as_echo "92. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_levendistance0_b.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(4, "dg", "??", "ds", "main");
  struct sr_gdb_thread *thread2 = create_thread(4, "dg", "??", "ds", "main");
  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);
  assert(is_dist_equal(0.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:131: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_levendistance0_b metrics_levenshtein_random_??_levendistance0_b.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_levendistance0_b metrics_levenshtein_random_??_levendistance0_b.c $LIBS" "metrics.at:131"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_levendistance0_b metrics_levenshtein_random_??_levendistance0_b.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:131"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:131: ./metrics_levenshtein_random_??_levendistance0_b"
at_fn_check_prepare_trace "metrics.at:131"
( $at_check_trace; ./metrics_levenshtein_random_??_levendistance0_b
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:131"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_92
#AT_START_93
at_fn_group_banner 93 'metrics.at:146' \
  "metrics_levenshtein_random_??_distance1" "        " 17
at_xfail=no
(
  $as_echo "93. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_distance1.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(3, "dg", "??", "ds");
  struct sr_gdb_thread *thread2 = create_thread(4, "dg", "??", "ds", "main");
  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);
  assert(is_dist_equal(1/4.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:146: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_distance1 metrics_levenshtein_random_??_distance1.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance1 metrics_levenshtein_random_??_distance1.c $LIBS" "metrics.at:146"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance1 metrics_levenshtein_random_??_distance1.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:146: ./metrics_levenshtein_random_??_distance1"
at_fn_check_prepare_trace "metrics.at:146"
( $at_check_trace; ./metrics_levenshtein_random_??_distance1
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:146"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_93
#AT_START_94
at_fn_group_banner 94 'metrics.at:161' \
  "metrics_levenshtein_random_??_distance2_a" "      " 17
at_xfail=no
(
  $as_echo "94. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_distance2_a.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(2, "dg", "??");
  struct sr_gdb_thread *thread2 = create_thread(3, "dg", "??", "main");
  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);
  assert(is_dist_equal(2/3.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:161: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_distance2_a metrics_levenshtein_random_??_distance2_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_a metrics_levenshtein_random_??_distance2_a.c $LIBS" "metrics.at:161"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_a metrics_levenshtein_random_??_distance2_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:161"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:161: ./metrics_levenshtein_random_??_distance2_a"
at_fn_check_prepare_trace "metrics.at:161"
( $at_check_trace; ./metrics_levenshtein_random_??_distance2_a
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:161"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_94
#AT_START_95
at_fn_group_banner 95 'metrics.at:176' \
  "metrics_levenshtein_random_??_distance2_b" "      " 17
at_xfail=no
(
  $as_echo "95. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_distance2_b.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(3, "dg", "??", "??");
  struct sr_gdb_thread *thread2 = create_thread(4, "dg", "??", "??", "main");
  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);
  assert(is_dist_equal(3/4.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:176: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_distance2_b metrics_levenshtein_random_??_distance2_b.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_b metrics_levenshtein_random_??_distance2_b.c $LIBS" "metrics.at:176"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_b metrics_levenshtein_random_??_distance2_b.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:176"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:176: ./metrics_levenshtein_random_??_distance2_b"
at_fn_check_prepare_trace "metrics.at:176"
( $at_check_trace; ./metrics_levenshtein_random_??_distance2_b
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:176"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_95
#AT_START_96
at_fn_group_banner 96 'metrics.at:191' \
  "metrics_levenshtein_random_??_distance2_c" "      " 17
at_xfail=no
(
  $as_echo "96. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_random_??_distance2_c.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(3, "??", "??", "main");
  struct sr_gdb_thread *thread2 = create_thread(2, "??", "??");
  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);
  assert(is_dist_equal(1.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:191: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_random_??_distance2_c metrics_levenshtein_random_??_distance2_c.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_c metrics_levenshtein_random_??_distance2_c.c $LIBS" "metrics.at:191"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_random_??_distance2_c metrics_levenshtein_random_??_distance2_c.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:191"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:191: ./metrics_levenshtein_random_??_distance2_c"
at_fn_check_prepare_trace "metrics.at:191"
( $at_check_trace; ./metrics_levenshtein_random_??_distance2_c
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:191"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_96
#AT_START_97
at_fn_group_banner 97 'metrics.at:206' \
  "metrics_levenshtein_trans_??_distance2_a" "       " 17
at_xfail=no
(
  $as_echo "97. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_trans_??_distance2_a.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(5, "ale", "asd", "??", "agd", "dsa");

  struct sr_gdb_thread *thread2 = create_thread(5, "ale", "huga", "asd", "??", "agd");

  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);

  assert(is_dist_equal(2/5.0, sr_distance(SR_DISTANCE_DAMERAU_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:206: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_trans_??_distance2_a metrics_levenshtein_trans_??_distance2_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_trans_??_distance2_a metrics_levenshtein_trans_??_distance2_a.c $LIBS" "metrics.at:206"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_trans_??_distance2_a metrics_levenshtein_trans_??_distance2_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:206"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:206: ./metrics_levenshtein_trans_??_distance2_a"
at_fn_check_prepare_trace "metrics.at:206"
( $at_check_trace; ./metrics_levenshtein_trans_??_distance2_a
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:206"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_97
#AT_START_98
at_fn_group_banner 98 'metrics.at:224' \
  "metrics_levenshtein_trans_??_distance2_b" "       " 17
at_xfail=no
(
  $as_echo "98. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_trans_??_distance2_b.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(4, "asd", "??", "agd", "dsa");

  struct sr_gdb_thread *thread2 = create_thread(4, "asd", "agd", "??", "dsa");

  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);

  assert(is_dist_equal(2/4.0, sr_distance(SR_DISTANCE_DAMERAU_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:224: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_trans_??_distance2_b metrics_levenshtein_trans_??_distance2_b.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_trans_??_distance2_b metrics_levenshtein_trans_??_distance2_b.c $LIBS" "metrics.at:224"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_trans_??_distance2_b metrics_levenshtein_trans_??_distance2_b.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:224"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:224: ./metrics_levenshtein_trans_??_distance2_b"
at_fn_check_prepare_trace "metrics.at:224"
( $at_check_trace; ./metrics_levenshtein_trans_??_distance2_b
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:224"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_98
#AT_START_99
at_fn_group_banner 99 'metrics.at:242' \
  "metrics_levenshtein_swap_trans_distance2_a" "     " 17
at_xfail=no
(
  $as_echo "99. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_swap_trans_distance2_a.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(4, "a", "b", "c", "d");
  struct sr_gdb_thread *thread2 = create_thread(4, "b", "a", "d", "c");

  assert(is_dist_equal(2/4.0, sr_distance(SR_DISTANCE_DAMERAU_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:242: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_swap_trans_distance2_a metrics_levenshtein_swap_trans_distance2_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_swap_trans_distance2_a metrics_levenshtein_swap_trans_distance2_a.c $LIBS" "metrics.at:242"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_swap_trans_distance2_a metrics_levenshtein_swap_trans_distance2_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:242"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:242: ./metrics_levenshtein_swap_trans_distance2_a"
at_fn_check_prepare_trace "metrics.at:242"
( $at_check_trace; ./metrics_levenshtein_swap_trans_distance2_a
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:242"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_99
#AT_START_100
at_fn_group_banner 100 'metrics.at:257' \
  "metrics_levenshtein_swap_notrans_distance3_a" "   " 17
at_xfail=no
(
  $as_echo "100. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_levenshtein_swap_notrans_distance3_a.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(4, "a", "b", "c", "d");
  struct sr_gdb_thread *thread2 = create_thread(4, "b", "a", "d", "c");

  assert(is_dist_equal(3/4.0, sr_distance(SR_DISTANCE_LEVENSHTEIN, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:257: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_levenshtein_swap_notrans_distance3_a metrics_levenshtein_swap_notrans_distance3_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_swap_notrans_distance3_a metrics_levenshtein_swap_notrans_distance3_a.c $LIBS" "metrics.at:257"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_levenshtein_swap_notrans_distance3_a metrics_levenshtein_swap_notrans_distance3_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:257"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:257: ./metrics_levenshtein_swap_notrans_distance3_a"
at_fn_check_prepare_trace "metrics.at:257"
( $at_check_trace; ./metrics_levenshtein_swap_notrans_distance3_a
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:257"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_100
#AT_START_101
at_fn_group_banner 101 'metrics.at:272' \
  "metrics_jaccard_random_??_distance0_a" "          " 17
at_xfail=no
(
  $as_echo "101. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_jaccard_random_??_distance0_a.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(4, "asd", "agd", "agd", "??");

  struct sr_gdb_thread *thread2 = create_thread(3, "asd", "agd", "??");

  sr_normalize_gdb_paired_unknown_function_names(thread1, thread2);

  assert(is_dist_equal(0.0, sr_distance(SR_DISTANCE_JACCARD, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:272: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_jaccard_random_??_distance0_a metrics_jaccard_random_??_distance0_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance0_a metrics_jaccard_random_??_distance0_a.c $LIBS" "metrics.at:272"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance0_a metrics_jaccard_random_??_distance0_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:272"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:272: ./metrics_jaccard_random_??_distance0_a"
at_fn_check_prepare_trace "metrics.at:272"
( $at_check_trace; ./metrics_jaccard_random_??_distance0_a
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:272"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_101
#AT_START_102
at_fn_group_banner 102 'metrics.at:290' \
  "metrics_jaccard_random_??_distance23_a" "         " 17
at_xfail=no
(
  $as_echo "102. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_jaccard_random_??_distance23_a.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(3, "asd", "agd", "agd");

  struct sr_gdb_thread *thread2 = create_thread(2, "sad", "agd");

  assert(is_dist_equal(2/3.0, sr_distance(SR_DISTANCE_JACCARD, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:290: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_jaccard_random_??_distance23_a metrics_jaccard_random_??_distance23_a.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance23_a metrics_jaccard_random_??_distance23_a.c $LIBS" "metrics.at:290"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance23_a metrics_jaccard_random_??_distance23_a.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:290"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:290: ./metrics_jaccard_random_??_distance23_a"
at_fn_check_prepare_trace "metrics.at:290"
( $at_check_trace; ./metrics_jaccard_random_??_distance23_a
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:290"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_102
#AT_START_103
at_fn_group_banner 103 'metrics.at:306' \
  "metrics_jaccard_random_??_distance35" "           " 17
at_xfail=no
(
  $as_echo "103. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >metrics_jaccard_random_??_distance35.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *thread1 = create_thread(5, "asd", "agd", "gad", "sad", "abc");

  struct sr_gdb_thread *thread2 = create_thread(4, "sad", "sad", "sad", "gad");

  assert(is_dist_equal(3/5.0, sr_distance(SR_DISTANCE_JACCARD, thread1, thread2)));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:306: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o metrics_jaccard_random_??_distance35 metrics_jaccard_random_??_distance35.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance35 metrics_jaccard_random_??_distance35.c $LIBS" "metrics.at:306"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o metrics_jaccard_random_??_distance35 metrics_jaccard_random_??_distance35.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:306"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:306: ./metrics_jaccard_random_??_distance35"
at_fn_check_prepare_trace "metrics.at:306"
( $at_check_trace; ./metrics_jaccard_random_??_distance35
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:306"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_103
#AT_START_104
at_fn_group_banner 104 'metrics.at:322' \
  "distances_basic_properties" "                     " 17
at_xfail=no
(
  $as_echo "104. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >distances_basic_properties.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  int m = 50, n = 100, i, j;
  struct sr_distances *distances = sr_distances_new(m, n);
  float x;

  for (i = 0; i < m; i++)
    for (j = 0; j < n; j++)
      sr_distances_set_distance(distances, i, j, i + j / 1000.0);

  for (i = 0; i < m; i++)
    for (j = 0; j < n; j++)
    {
      x = sr_distances_get_distance(distances, i, j);
      if (i == j)
         assert(x == 0.0);
      else if (j < m && i < j)
         assert(is_dist_equal(j + i / 1000.0, x));
      else
         assert(is_dist_equal(i + j / 1000.0, x));
    }

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:322: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o distances_basic_properties distances_basic_properties.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o distances_basic_properties distances_basic_properties.c $LIBS" "metrics.at:322"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o distances_basic_properties distances_basic_properties.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:322"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:322: ./distances_basic_properties"
at_fn_check_prepare_trace "metrics.at:322"
( $at_check_trace; ./distances_basic_properties
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:322"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_104
#AT_START_105
at_fn_group_banner 105 'metrics.at:353' \
  "distances_threads_compare" "                      " 17
at_xfail=no
(
  $as_echo "105. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >distances_threads_compare.c <<'_ATEOF'

#include <stdarg.h>
#include "gdb/thread.h"
#include "gdb/frame.h"
#include "utils.h"
#include <stdlib.h>
#include <assert.h>
#include "normalize.h"
#include "distance.h"

static struct sr_gdb_thread *
create_thread(int count, ...)
{
  struct sr_gdb_thread *thread = sr_gdb_thread_new();
  if (count == 0)
     return thread;

  int i;
  va_list argp;
  va_start(argp, count);

  for (i=0; i < count; i++)
  {
    const char *fname = va_arg(argp, const char*);
    struct sr_gdb_frame *frame = sr_gdb_frame_new();
    frame->function_name = sr_strdup(fname);

    if (!thread->frames)
      thread->frames = frame;
    else
      sr_gdb_frame_append(thread->frames, frame);
  }

  va_end(argp);
  return thread;
}

static bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}


int
main()
{
  struct sr_gdb_thread *threads[4];
  threads[0] = create_thread(4, "asd", "agd", "das", "??");
  threads[1] = create_thread(3, "asd", "agd", "??");
  threads[2] = create_thread(3, "asd", "agd", "??");
  threads[3] = create_thread(3, "dg", "??", "??");

  struct sr_distances *distances = sr_threads_compare(threads, 3, 4, SR_DISTANCE_JACCARD);
  assert(is_dist_equal(0.6, sr_distances_get_distance(distances, 0, 1)));
  assert(is_dist_equal(0.6, sr_distances_get_distance(distances, 0, 2)));
  assert(is_dist_equal(1.0, sr_distances_get_distance(distances, 0, 3)));
  assert(is_dist_equal(0.0, sr_distances_get_distance(distances, 1, 2)));
  assert(is_dist_equal(1.0, sr_distances_get_distance(distances, 1, 3)));
  assert(is_dist_equal(1.0, sr_distances_get_distance(distances, 2, 3)));

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/metrics.at:353: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o distances_threads_compare distances_threads_compare.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o distances_threads_compare distances_threads_compare.c $LIBS" "metrics.at:353"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o distances_threads_compare distances_threads_compare.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:353"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/metrics.at:353: ./distances_threads_compare"
at_fn_check_prepare_trace "metrics.at:353"
( $at_check_trace; ./distances_threads_compare
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/metrics.at:353"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_105
#AT_START_106
at_fn_group_banner 106 'cluster.at:3' \
  "sr_distances_cluster_objects" "                   " 18
at_xfail=no
(
  $as_echo "106. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_distances_cluster_objects.c <<'_ATEOF'

#include "distance.h"
#include "cluster.h"
#include <assert.h>
#include <stdio.h>

bool
is_dist_equal(float x, float y)
{
  float epsilon = 1e-6;
  return x - epsilon <= y && x + epsilon >= y;
}

int
main()
{
  struct sr_distances *distances;
  struct sr_dendrogram *dendrogram;

  distances = sr_distances_new(3, 4);
  sr_distances_set_distance(distances, 0, 1, 1.0);
  sr_distances_set_distance(distances, 0, 2, 0.5);
  sr_distances_set_distance(distances, 0, 3, 0.0);
  sr_distances_set_distance(distances, 1, 2, 0.1);
  sr_distances_set_distance(distances, 1, 3, 0.3);
  sr_distances_set_distance(distances, 2, 3, 0.7);

  dendrogram = sr_distances_cluster_objects(distances);

  assert(dendrogram->size == 4);

  assert(dendrogram->order[0] == 0);
  assert(dendrogram->order[1] == 3);
  assert(dendrogram->order[2] == 1);
  assert(dendrogram->order[3] == 2);

  assert(is_dist_equal(dendrogram->merge_levels[0], 0.0));
  assert(is_dist_equal(dendrogram->merge_levels[1], 0.625));
  assert(is_dist_equal(dendrogram->merge_levels[2], 0.1));

  distances = sr_distances_new(1, 6);
  sr_distances_set_distance(distances, 0, 1, 1.0);
  sr_distances_set_distance(distances, 0, 2, 0.5);
  sr_distances_set_distance(distances, 0, 3, 0.3);
  sr_distances_set_distance(distances, 0, 4, 0.0);
  sr_distances_set_distance(distances, 0, 5, 0.9);

  dendrogram = sr_distances_cluster_objects(distances);

  assert(dendrogram->size == 6);

  assert(dendrogram->order[0] == 0);
  assert(dendrogram->order[1] == 4);
  assert(dendrogram->order[2] == 3);
  assert(dendrogram->order[3] == 2);
  assert(dendrogram->order[4] == 5);
  assert(dendrogram->order[5] == 1);

  assert(is_dist_equal(dendrogram->merge_levels[0], 0.0));
  assert(is_dist_equal(dendrogram->merge_levels[1], 0.3));
  assert(is_dist_equal(dendrogram->merge_levels[2], 0.5));
  assert(is_dist_equal(dendrogram->merge_levels[3], 0.9));
  assert(is_dist_equal(dendrogram->merge_levels[4], 1.0));

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/cluster.at:3: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_distances_cluster_objects sr_distances_cluster_objects.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_distances_cluster_objects sr_distances_cluster_objects.c $LIBS" "cluster.at:3"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_distances_cluster_objects sr_distances_cluster_objects.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cluster.at:3"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cluster.at:3: ./sr_distances_cluster_objects"
at_fn_check_prepare_trace "cluster.at:3"
( $at_check_trace; ./sr_distances_cluster_objects
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cluster.at:3"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_106
#AT_START_107
at_fn_group_banner 107 'cluster.at:72' \
  "sr_dendrogram_cut" "                              " 18
at_xfail=no
(
  $as_echo "107. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_dendrogram_cut.c <<'_ATEOF'

#include "cluster.h"
#include <assert.h>
#include <stdio.h>

int
main()
{
  struct sr_dendrogram *dendrogram;
  struct sr_cluster *cluster;

  dendrogram = sr_dendrogram_new(6);

  dendrogram->order[0] = 0;
  dendrogram->order[1] = 3;
  dendrogram->order[2] = 1;
  dendrogram->order[3] = 2;
  dendrogram->order[4] = 4;
  dendrogram->order[5] = 5;

  dendrogram->merge_levels[0] = 0.0;
  dendrogram->merge_levels[1] = 0.6;
  dendrogram->merge_levels[2] = 0.1;
  dendrogram->merge_levels[3] = 0.5;
  dendrogram->merge_levels[4] = 0.3;

  cluster = sr_dendrogram_cut(dendrogram, 0.2, 1);

  assert(cluster);

  assert(cluster->size == 1);
  assert(cluster->objects[0] == 5);
  assert(cluster->next);
  cluster = cluster->next;

  assert(cluster->size == 1);
  assert(cluster->objects[0] == 4);
  assert(cluster->next);
  cluster = cluster->next;

  assert(cluster->size == 2);
  assert(cluster->objects[0] == 1);
  assert(cluster->objects[1] == 2);
  assert(cluster->next);
  cluster = cluster->next;

  assert(cluster->size == 2);
  assert(cluster->objects[0] == 0);
  assert(cluster->objects[1] == 3);

  assert(!cluster->next);

  cluster = sr_dendrogram_cut(dendrogram, 0.5, 3);

  assert(cluster);

  assert(cluster->size == 4);
  assert(cluster->objects[0] == 1);
  assert(cluster->objects[1] == 2);
  assert(cluster->objects[2] == 4);
  assert(cluster->objects[3] == 5);

  assert(!cluster->next);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/cluster.at:72: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_dendrogram_cut sr_dendrogram_cut.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_dendrogram_cut sr_dendrogram_cut.c $LIBS" "cluster.at:72"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_dendrogram_cut sr_dendrogram_cut.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cluster.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/cluster.at:72: ./sr_dendrogram_cut"
at_fn_check_prepare_trace "cluster.at:72"
( $at_check_trace; ./sr_dendrogram_cut
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/cluster.at:72"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_107
#AT_START_108
at_fn_group_banner 108 'rpm.at:8' \
  "sr_rpm_package_parse_nvr" "                       " 19
at_xfail=no
(
  $as_echo "108. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_rpm_package_parse_nvr.c <<'_ATEOF'

#include "rpm.h"
#include <assert.h>

int
main(void)
{
  char *name, *version, *release;
  bool success = sr_rpm_package_parse_nvr("coreutils-8.4-19.el6",
                                          &name,
                                          &version,
                                          &release);

  assert(success);
  assert(0 == strcmp(name, "coreutils"));
  assert(0 == strcmp(version, "8.4"));
  assert(0 == strcmp(release, "19.el6"));
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/rpm.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_rpm_package_parse_nvr sr_rpm_package_parse_nvr.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_rpm_package_parse_nvr sr_rpm_package_parse_nvr.c $LIBS" "rpm.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_rpm_package_parse_nvr sr_rpm_package_parse_nvr.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/rpm.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/rpm.at:8: ./sr_rpm_package_parse_nvr"
at_fn_check_prepare_trace "rpm.at:8"
( $at_check_trace; ./sr_rpm_package_parse_nvr
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/rpm.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_108
#AT_START_109
at_fn_group_banner 109 'rpm.at:33' \
  "sr_rpm_package_parse_nevra" "                     " 19
at_xfail=no
(
  $as_echo "109. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_rpm_package_parse_nevra.c <<'_ATEOF'

#include "rpm.h"
#include <assert.h>
#include <stdint.h>

static void
check(char *input,
      bool expected_success,
      char *expected_name,
      uint32_t expected_epoch,
      char *expected_version,
      char *expected_release,
      char *expected_architecture)
{
  char *name, *version, *release, *architecture;
  uint32_t epoch;
  bool success = sr_rpm_package_parse_nevra(input,
                                            &name,
                                            &epoch,
                                            &version,
                                            &release,
                                            &architecture);

  assert(success == expected_success);
  if (success)
  {
    assert(0 == strcmp(name, expected_name));
    assert(epoch == expected_epoch);
    assert(0 == strcmp(version, expected_version));
    assert(0 == strcmp(release, expected_release));
    assert(0 == strcmp(architecture, expected_architecture));
  }
}

int
main(void)
{
  check("glibc-2.12-1.80.el6_3.5.x86_64",
        true,
        "glibc",
        0,
        "2.12",
        "1.80.el6_3.5",
        "x86_64");

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/rpm.at:33: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_rpm_package_parse_nevra sr_rpm_package_parse_nevra.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_rpm_package_parse_nevra sr_rpm_package_parse_nevra.c $LIBS" "rpm.at:33"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_rpm_package_parse_nevra sr_rpm_package_parse_nevra.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/rpm.at:33"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/rpm.at:33: ./sr_rpm_package_parse_nevra"
at_fn_check_prepare_trace "rpm.at:33"
( $at_check_trace; ./sr_rpm_package_parse_nevra
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/rpm.at:33"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_109
#AT_START_110
at_fn_group_banner 110 'rpm.at:86' \
  "sr_rpm_package_uniq" "                            " 19
at_xfail=no
(
  $as_echo "110. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_rpm_package_uniq.c <<'_ATEOF'

#include "rpm.h"
#include "utils.h"
#include <assert.h>
#include <stdint.h>

int
main(void)
{
  struct sr_rpm_package *p1 = sr_rpm_package_new();
  struct sr_rpm_package *p2 = sr_rpm_package_new();
  struct sr_rpm_package *p3 = sr_rpm_package_new();

  p1->name = sr_strdup("coreutils");
  p1->version = sr_strdup("8.15");
  p1->release = sr_strdup("10.fc17");
  p1->role = SR_ROLE_AFFECTED;
  p1->next = p2;

  p2->name = sr_strdup("coreutils");
  p2->version = sr_strdup("8.15");
  p2->release = sr_strdup("10.fc17");
  p2->architecture = sr_strdup("x86_64");
  p2->install_time = 1363628422;
  p2->next = p3;

  p3->name = sr_strdup("glibc");
  p3->version = sr_strdup("2.15");
  p3->release = sr_strdup("58.fc17");
  p3->architecture = sr_strdup("x86_64");
  p3->install_time = 1363628422;

  struct sr_rpm_package *packages = p1;
  packages = sr_rpm_package_uniq(packages);

  assert(0 == strcmp(packages->name, "coreutils") &&
         0 == strcmp(packages->version, "8.15") &&
         0 == strcmp(packages->release, "10.fc17") &&
         0 == strcmp(packages->architecture, "x86_64") &&
         packages->install_time == 1363628422 &&
         packages->role == SR_ROLE_AFFECTED);

  assert(0 == strcmp(packages->next->name, "glibc") &&
         0 == strcmp(packages->next->version, "2.15") &&
         0 == strcmp(packages->next->release, "58.fc17") &&
         0 == strcmp(packages->next->architecture, "x86_64") &&
         packages->next->install_time == 1363628422 &&
         packages->next->role == SR_ROLE_UNKNOWN);

  assert(packages->next->next == NULL);

  sr_rpm_package_free(packages, true);


  p1 = sr_rpm_package_new();
  p2 = sr_rpm_package_new();
  p3 = sr_rpm_package_new();

  p1->name = sr_strdup("glibc");
  p1->version = sr_strdup("2.15");
  p1->release = sr_strdup("58.fc17");
  p1->architecture = sr_strdup("x86_64");
  p1->install_time = 1363628422;
  p1->next = p2;

  p2->name = sr_strdup("coreutils");
  p2->version = sr_strdup("8.15");
  p2->release = sr_strdup("10.fc17");
  p2->next = p3;

  p3->name = sr_strdup("coreutils");
  p3->version = sr_strdup("8.15");
  p3->release = sr_strdup("10.fc17");
  p3->architecture = sr_strdup("x86_64");
  p3->install_time = 1363628422;
  p3->role = SR_ROLE_AFFECTED;

  packages = p1;
  packages = sr_rpm_package_uniq(packages);

  assert(0 == strcmp(packages->name, "glibc") &&
         0 == strcmp(packages->version, "2.15") &&
         0 == strcmp(packages->release, "58.fc17") &&
         0 == strcmp(packages->architecture, "x86_64") &&
         packages->install_time == 1363628422 &&
         packages->role == SR_ROLE_UNKNOWN);

  assert(0 == strcmp(packages->next->name, "coreutils") &&
         0 == strcmp(packages->next->version, "8.15") &&
         0 == strcmp(packages->next->release, "10.fc17") &&
         0 == strcmp(packages->next->architecture, "x86_64") &&
         packages->next->install_time == 1363628422 &&
         packages->next->role == SR_ROLE_AFFECTED);

  assert(packages->next->next == NULL);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/rpm.at:86: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_rpm_package_uniq sr_rpm_package_uniq.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_rpm_package_uniq sr_rpm_package_uniq.c $LIBS" "rpm.at:86"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_rpm_package_uniq sr_rpm_package_uniq.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/rpm.at:86"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/rpm.at:86: ./sr_rpm_package_uniq"
at_fn_check_prepare_trace "rpm.at:86"
( $at_check_trace; ./sr_rpm_package_uniq
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/rpm.at:86"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_110
#AT_START_111
at_fn_group_banner 111 'rpm.at:190' \
  "sr_rpm_package_uniq3" "                           " 19
at_xfail=no
(
  $as_echo "111. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_rpm_package_uniq3.c <<'_ATEOF'

#include "rpm.h"
#include "utils.h"
#include <assert.h>
#include <stdint.h>

int
main(void)
{
  struct sr_rpm_package *p1 = sr_rpm_package_new();
  struct sr_rpm_package *p2 = sr_rpm_package_new();
  struct sr_rpm_package *p3 = sr_rpm_package_new();

  p1->name = sr_strdup("pango");
  p1->version = sr_strdup("1.32.3");
  p1->release = sr_strdup("1.fc18");
  p1->architecture = sr_strdup("x86_64");
  p2->install_time = 1363628422;
  p1->next = p2;

  p2->name = sr_strdup("pango");
  p2->version = sr_strdup("1.32.3");
  p2->release = sr_strdup("1.fc18");
  p2->architecture = sr_strdup("x86_64");
  p2->install_time = 1363628422;
  p2->next = p3;

  p3->name = sr_strdup("pango");
  p3->version = sr_strdup("1.32.3");
  p3->release = sr_strdup("1.fc18");
  p3->architecture = sr_strdup("x86_64");
  p3->install_time = 1363628422;

  struct sr_rpm_package *packages = p1;
  packages = sr_rpm_package_uniq(packages);

  assert(packages);
  assert(!packages->next);

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/rpm.at:190: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_rpm_package_uniq3 sr_rpm_package_uniq3.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_rpm_package_uniq3 sr_rpm_package_uniq3.c $LIBS" "rpm.at:190"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_rpm_package_uniq3 sr_rpm_package_uniq3.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/rpm.at:190"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/rpm.at:190: ./sr_rpm_package_uniq3"
at_fn_check_prepare_trace "rpm.at:190"
( $at_check_trace; ./sr_rpm_package_uniq3
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/rpm.at:190"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_111
#AT_START_112
at_fn_group_banner 112 'abrt.at:8' \
  "sr_abrt_parse_dso_list" "                         " 20
at_xfail=no
(
  $as_echo "112. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_abrt_parse_dso_list.c <<'_ATEOF'

#include "abrt.h"
#include "rpm.h"
#include <assert.h>

int
main(void)
{
  char *dso_list =
    "/lib64/libbz2.so.1.0.4 bzip2-libs-1.0.5-7.el6_0.x86_64 (Scientific Linux) 1342032228\n"
    "/usr/lib64/libnssutil3.so nss-util-3.13.5-1.el6_3.x86_64 (Scientific Linux) 1342664268\n"
    "/usr/lib64/libunwind-coredump.so.0.0.0 libunwind-1.1-1.fc19.x86_64 (None) 1350312182\n"
    "/usr/lib64/librpm.so.1.0.0 rpm-libs-4.8.0-27.el6.x86_64 (Scientific Linux) 1348232255\n"
    "/lib64/libacl.so.1.1.0 libacl-2.2.49-6.el6.x86_64 (Scientific Linux) 1342032227\n"
    "/usr/lib64/libelf-0.152.so elfutils-libelf-0.152-1.el6.x86_64 (Scientific Linux) 1342032254\n"
    "/lib64/libnspr4.so nspr-4.9.1-2.el6_3.x86_64 (Scientific Linux) 1342664267\n"
    "/usr/lib64/libnss3.so nss-3.13.5-1.el6_3.x86_64 (Scientific Linux) 1342664269\n"
    "/lib64/libm-2.12.so glibc-2.12-1.80.el6_3.5.x86_64 (Scientific Linux) 1346116822\n"
    "/lib64/libplc4.so nspr-4.9.1-2.el6_3.x86_64 (Scientific Linux) 1342664267\n"
    "/lib64/libcap.so.2.16 libcap-2.16-5.5.el6.x86_64 (Scientific Linux) 1342032219\n"
    "/lib64/libdl-2.12.so glibc-2.12-1.80.el6_3.5.x86_64 (Scientific Linux) 1346116822\n"
    "/lib64/libdb-4.7.so db4-4.7.25-17.el6.x86_64 (Scientific Linux) 1348232155\n"
    "/lib64/libplds4.so nspr-4.9.1-2.el6_3.x86_64 (Scientific Linux) 1342664267\n"
    "/usr/lib64/liblua-5.1.so lua-5.1.4-4.1.el6.x86_64 (Scientific Linux) 1342032244\n"
    "/usr/lib64/librpmio.so.1.0.0 rpm-libs-4.8.0-27.el6.x86_64 (Scientific Linux) 1348232255\n"
    "/lib64/libpopt.so.0.0.0 popt-1.13-7.el6.x86_64 (Scientific Linux) 1342032221\n"
    "/usr/lib64/liblzma.so.0.0.0 xz-libs-4.999.9-0.3.beta.20091007git.el6.x86_64 (Scientific Linux) 1342032252\n"
    "/lib64/libz.so.1.2.3 zlib-1.2.3-27.el6.x86_64 (Scientific Linux) 1342032220\n"
    "/usr/lib64/libunwind-x86_64.so.8.0.1 libunwind-1.1-1.fc19.x86_64 (None) 1350312182\n"
    "/lib64/libgcc_s-4.4.6-20120305.so.1 libgcc-4.4.6-4.el6.x86_64 (Scientific Linux) 1348232150\n"
    "/lib64/ld-2.12.so glibc-2.12-1.80.el6_3.5.x86_64 (Scientific Linux) 1346116822\n"
    "/lib64/libattr.so.1.1.0 libattr-2.4.44-7.el6.x86_64 (Scientific Linux) 1342032219\n"
    "/lib64/librt-2.12.so glibc-2.12-1.80.el6_3.5.x86_64 (Scientific Linux) 1346116822\n"
    "/lib64/libc-2.12.so glibc-2.12-1.80.el6_3.5.x86_64 (Scientific Linux) 1346116822\n"
    "/lib64/libselinux.so.1 libselinux-2.0.94-5.3.el6.x86_64 (Scientific Linux) 1348232151\n"
    "/usr/lib64/libunwind.so.8.0.1 libunwind-1.1-1.fc19.x86_64 (None) 1350312182\n"
    "/lib64/libpthread-2.12.so glibc-2.12-1.80.el6_3.5.x86_64 (Scientific Linux) 1346116822\n";

  struct sr_rpm_package *packages =
    sr_abrt_parse_dso_list(dso_list);

  assert(packages);

  struct sr_rpm_package *p = packages;
  assert(0 == strcmp(p->name, "bzip2-libs"));
  assert(0 == strcmp(p->version, "1.0.5"));
  assert(0 == strcmp(p->release, "7.el6_0"));
  assert(0 == strcmp(p->architecture, "x86_64"));
  assert(0 == p->epoch);
  assert(p->install_time == 1342032228);

  /* last package */
  while(p->next)
    p = p->next;

  assert(0 == strcmp(p->name, "glibc"));
  assert(0 == strcmp(p->version, "2.12"));
  assert(0 == strcmp(p->release, "1.80.el6_3.5"));
  assert(0 == strcmp(p->architecture, "x86_64"));
  assert(0 == p->epoch);
  assert(p->install_time == 1346116822);

  sr_rpm_package_free(packages, true);
  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/abrt.at:8: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_abrt_parse_dso_list sr_abrt_parse_dso_list.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_abrt_parse_dso_list sr_abrt_parse_dso_list.c $LIBS" "abrt.at:8"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_abrt_parse_dso_list sr_abrt_parse_dso_list.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/abrt.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/abrt.at:8: ./sr_abrt_parse_dso_list"
at_fn_check_prepare_trace "abrt.at:8"
( $at_check_trace; ./sr_abrt_parse_dso_list
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/abrt.at:8"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_112
#AT_START_113
at_fn_group_banner 113 'report.at:9' \
  "sr_report_type_to_string" "                       " 21
at_xfail=no
(
  $as_echo "113. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_report_type_to_string.c <<'_ATEOF'

#include <assert.h>
#include "report_type.h"

void check(enum sr_report_type type, char *str)
{
  assert(0 == sr_strcmp0(sr_report_type_to_string(type), str));
}

int main(void)
{
  check(SR_REPORT_INVALID, "invalid");
  check(SR_REPORT_CORE, "core");
  check(SR_REPORT_KERNELOOPS, "kerneloops");
  check(SR_REPORT_GDB, "gdb");
  check(SR_REPORT_NUM, "invalid");
  check(5000, "invalid");
  check(-42, "invalid");

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/report.at:9: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_report_type_to_string sr_report_type_to_string.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_report_type_to_string sr_report_type_to_string.c $LIBS" "report.at:9"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_report_type_to_string sr_report_type_to_string.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/report.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/report.at:9: ./sr_report_type_to_string"
at_fn_check_prepare_trace "report.at:9"
( $at_check_trace; ./sr_report_type_to_string
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/report.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_113
#AT_START_114
at_fn_group_banner 114 'report.at:37' \
  "sr_report_type_from_string" "                     " 21
at_xfail=no
(
  $as_echo "114. $at_setup_line: testing $at_desc ..."
  $at_traceon

cat >sr_report_type_from_string.c <<'_ATEOF'

#include <assert.h>
#include <stdio.h>
#include "report_type.h"

void check(enum sr_report_type type, char *str)
{
  assert(sr_report_type_from_string(str) == type);
}

int main(void)
{
  check(SR_REPORT_INVALID, "invalid");
  check(SR_REPORT_CORE, "core");
  check(SR_REPORT_PYTHON, "python");
  check(SR_REPORT_GDB, "gdb");
  check(SR_REPORT_INVALID, NULL);
  check(SR_REPORT_INVALID, "visual basic");

  return 0;
}
_ATEOF

{ set +x
$as_echo "$at_srcdir/report.at:37: \$LIBTOOL --mode=link \$CC \$CFLAGS \$LDFLAGS -o sr_report_type_from_string sr_report_type_from_string.c \$LIBS"
at_fn_check_prepare_dynamic "$LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_report_type_from_string sr_report_type_from_string.c $LIBS" "report.at:37"
( $at_check_trace; $LIBTOOL --mode=link $CC $CFLAGS $LDFLAGS -o sr_report_type_from_string sr_report_type_from_string.c $LIBS
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/report.at:37"
$at_failed && at_fn_log_failure
$at_traceon; }

{ set +x
$as_echo "$at_srcdir/report.at:37: ./sr_report_type_from_string"
at_fn_check_prepare_trace "report.at:37"
( $at_check_trace; ./sr_report_type_from_string
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/report.at:37"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_114
#AT_START_115
at_fn_group_banner 115 'python_bindings.at:9' \
  "python_bindings_for_misc" "                       " 22
at_xfail=no
(
  $as_echo "115. $at_setup_line: testing $at_desc ..."
  $at_traceon

{ set +x
$as_echo "$at_srcdir/python_bindings.at:9: PYTHONPATH=../../../python/.libs/ ../../python/misc.py -v"
at_fn_check_prepare_trace "python_bindings.at:9"
( $at_check_trace; PYTHONPATH=../../../python/.libs/ ../../python/misc.py -v
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/python_bindings.at:9"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_115
#AT_START_116
at_fn_group_banner 116 'python_bindings.at:10' \
  "python_bindings_for_gdb" "                        " 22
at_xfail=no
(
  $as_echo "116. $at_setup_line: testing $at_desc ..."
  $at_traceon

{ set +x
$as_echo "$at_srcdir/python_bindings.at:10: PYTHONPATH=../../../python/.libs/ ../../python/gdb.py -v"
at_fn_check_prepare_trace "python_bindings.at:10"
( $at_check_trace; PYTHONPATH=../../../python/.libs/ ../../python/gdb.py -v
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/python_bindings.at:10"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_116
#AT_START_117
at_fn_group_banner 117 'python_bindings.at:11' \
  "python_bindings_for_koops" "                      " 22
at_xfail=no
(
  $as_echo "117. $at_setup_line: testing $at_desc ..."
  $at_traceon

{ set +x
$as_echo "$at_srcdir/python_bindings.at:11: PYTHONPATH=../../../python/.libs/ ../../python/koops.py -v"
at_fn_check_prepare_trace "python_bindings.at:11"
( $at_check_trace; PYTHONPATH=../../../python/.libs/ ../../python/koops.py -v
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/python_bindings.at:11"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_117
#AT_START_118
at_fn_group_banner 118 'python_bindings.at:12' \
  "python_bindings_for_python" "                     " 22
at_xfail=no
(
  $as_echo "118. $at_setup_line: testing $at_desc ..."
  $at_traceon

{ set +x
$as_echo "$at_srcdir/python_bindings.at:12: PYTHONPATH=../../../python/.libs/ ../../python/python.py -v"
at_fn_check_prepare_trace "python_bindings.at:12"
( $at_check_trace; PYTHONPATH=../../../python/.libs/ ../../python/python.py -v
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/python_bindings.at:12"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_118
#AT_START_119
at_fn_group_banner 119 'python_bindings.at:13' \
  "python_bindings_for_java" "                       " 22
at_xfail=no
(
  $as_echo "119. $at_setup_line: testing $at_desc ..."
  $at_traceon

{ set +x
$as_echo "$at_srcdir/python_bindings.at:13: PYTHONPATH=../../../python/.libs/ ../../python/java.py -v"
at_fn_check_prepare_trace "python_bindings.at:13"
( $at_check_trace; PYTHONPATH=../../../python/.libs/ ../../python/java.py -v
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/python_bindings.at:13"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_119
#AT_START_120
at_fn_group_banner 120 'python_bindings.at:14' \
  "python_bindings_for_core" "                       " 22
at_xfail=no
(
  $as_echo "120. $at_setup_line: testing $at_desc ..."
  $at_traceon

{ set +x
$as_echo "$at_srcdir/python_bindings.at:14: PYTHONPATH=../../../python/.libs/ ../../python/core.py -v"
at_fn_check_prepare_trace "python_bindings.at:14"
( $at_check_trace; PYTHONPATH=../../../python/.libs/ ../../python/core.py -v
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/python_bindings.at:14"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_120
#AT_START_121
at_fn_group_banner 121 'python_bindings.at:15' \
  "python_bindings_for_metrics" "                    " 22
at_xfail=no
(
  $as_echo "121. $at_setup_line: testing $at_desc ..."
  $at_traceon

{ set +x
$as_echo "$at_srcdir/python_bindings.at:15: PYTHONPATH=../../../python/.libs/ ../../python/metrics.py -v"
at_fn_check_prepare_trace "python_bindings.at:15"
( $at_check_trace; PYTHONPATH=../../../python/.libs/ ../../python/metrics.py -v
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/python_bindings.at:15"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_121
#AT_START_122
at_fn_group_banner 122 'python_bindings.at:16' \
  "python_bindings_for_report" "                     " 22
at_xfail=no
(
  $as_echo "122. $at_setup_line: testing $at_desc ..."
  $at_traceon

{ set +x
$as_echo "$at_srcdir/python_bindings.at:16: PYTHONPATH=../../../python/.libs/ ../../python/report.py -v"
at_fn_check_prepare_trace "python_bindings.at:16"
( $at_check_trace; PYTHONPATH=../../../python/.libs/ ../../python/report.py -v
) >>"$at_stdout" 2>>"$at_stderr" 5>&-
at_status=$? at_failed=false
$at_check_filter
echo stderr:; cat "$at_stderr"
echo stdout:; cat "$at_stdout"
at_fn_check_status 0 $at_status "$at_srcdir/python_bindings.at:16"
$at_failed && at_fn_log_failure
$at_traceon; }

  set +x
  $at_times_p && times >"$at_times_file"
) 5>&1 2>&1 7>&- | eval $at_tee_pipe
read at_status <"$at_status_file"
#AT_STOP_122
